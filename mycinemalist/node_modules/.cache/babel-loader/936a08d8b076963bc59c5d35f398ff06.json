{"ast":null,"code":"/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\nimport { getDocument } from './dom/getDocument';\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\n\nexport function modalize(target) {\n  var _a;\n\n  var affectedNodes = [];\n  var targetDocument = getDocument(target) || document; // start at target, then recurse and do the same for parent, until we reach <body>\n\n  while (target !== targetDocument.body) {\n    // grab all siblings of current element\n    for (var _i = 0, _b = target.parentElement.children; _i < _b.length; _i++) {\n      var sibling = _b[_i]; // but ignore elements that are already aria-hidden\n\n      if (sibling !== target && ((_a = sibling.getAttribute('aria-hidden')) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'true') {\n        affectedNodes.push(sibling);\n      }\n    }\n\n    if (!target.parentElement) {\n      break;\n    }\n\n    target = target.parentElement;\n  } // take all those elements and set aria-hidden=true on them\n\n\n  affectedNodes.forEach(function (node) {\n    node.setAttribute('aria-hidden', 'true');\n  });\n  return function () {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n/**\n * Undoes the changes that modalize() did.\n */\n\nfunction unmodalize(affectedNodes) {\n  affectedNodes.forEach(function (node) {\n    // set instead of removing in case other components explicitly set aria-hidden and do ==\"true\" or ==\"false\"\n    node.setAttribute('aria-hidden', 'false');\n  });\n}","map":{"version":3,"mappings":"AAAA;;;;;AAMA,SAASA,WAAT,QAA4B,mBAA5B;AAEA;;;;;AAIA,OAAM,SAAUC,QAAV,CAAmBC,MAAnB,EAAsC;;;AAC1C,MAAIC,aAAa,GAAkB,EAAnC;AACA,MAAMC,cAAc,GAAGJ,WAAW,CAACE,MAAD,CAAX,IAAuBG,QAA9C,CAF0C,CAI1C;;AACA,SAAOH,MAAM,KAAKE,cAAc,CAACE,IAAjC,EAAuC;AACrC;AACA,SAAsB,iBAACJ,MAAM,CAACK,aAAP,CAAsBC,QAA7C,EAAsBC,cAAtB,EAAsBA,IAAtB,EAAyF;AAApF,UAAMC,OAAO,SAAb,CAAoF,CACvF;;AACA,UAAIA,OAAO,KAAKR,MAAZ,IAAsB,cAAO,CAACS,YAAR,CAAqB,aAArB,OAAmC,IAAnC,IAAmCC,aAAnC,GAAmC,MAAnC,GAAmCA,GAAEC,WAAF,EAAnC,MAAuD,MAAjF,EAAyF;AACvFV,qBAAa,CAACW,IAAd,CAAmBJ,OAAnB;AACD;AACF;;AAED,QAAI,CAACR,MAAM,CAACK,aAAZ,EAA2B;AACzB;AACD;;AACDL,UAAM,GAAGA,MAAM,CAACK,aAAhB;AACD,GAlByC,CAoB1C;;;AACAJ,eAAa,CAACY,OAAd,CAAsB,gBAAI;AACxBC,QAAI,CAACC,YAAL,CAAkB,aAAlB,EAAiC,MAAjC;AACD,GAFD;AAIA,SAAO;AACLC,cAAU,CAACf,aAAD,CAAV;AACAA,iBAAa,GAAG,EAAhB,CAFK,CAEe;AACrB,GAHD;AAID;AAED;;;;AAGA,SAASe,UAAT,CAAoBf,aAApB,EAAgD;AAC9CA,eAAa,CAACY,OAAd,CAAsB,gBAAI;AACxB;AACAC,QAAI,CAACC,YAAL,CAAkB,aAAlB,EAAiC,OAAjC;AACD,GAHD;AAID","names":["getDocument","modalize","target","affectedNodes","targetDocument","document","body","parentElement","children","_i","sibling","getAttribute","_a","toLowerCase","push","forEach","node","setAttribute","unmodalize"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\src\\modalize.ts"],"sourcesContent":["/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\n\nimport { getDocument } from './dom/getDocument';\n\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target: HTMLElement): () => void {\n  let affectedNodes: HTMLElement[] = [];\n  const targetDocument = getDocument(target) || document;\n\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body) {\n    // grab all siblings of current element\n    for (const sibling of (target.parentElement!.children as unknown) as Array<HTMLElement>) {\n      // but ignore elements that are already aria-hidden\n      if (sibling !== target && sibling.getAttribute('aria-hidden')?.toLowerCase() !== 'true') {\n        affectedNodes.push(sibling);\n      }\n    }\n\n    if (!target.parentElement) {\n      break;\n    }\n    target = target.parentElement;\n  }\n\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(node => {\n    node.setAttribute('aria-hidden', 'true');\n  });\n\n  return () => {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes: HTMLElement[]) {\n  affectedNodes.forEach(node => {\n    // set instead of removing in case other components explicitly set aria-hidden and do ==\"true\" or ==\"false\"\n    node.setAttribute('aria-hidden', 'false');\n  });\n}\n"]},"metadata":{},"sourceType":"module"}