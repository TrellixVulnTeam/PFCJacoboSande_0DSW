{"ast":null,"code":"import { IsFocusVisibleClassName } from '../../Utilities';\nimport { HighContrastSelector, getFocusStyle } from '../../Styling'; // Size breakpoint when the default border width changes from 2px to 4px.\n\nvar CELL_BORDER_BREAKPOINT = 24;\nvar LARGE_BORDER = 4;\nvar SMALL_BORDER = 2;\nvar DIVIDING_PADDING = 2;\nvar DEFAULT_CELL_SIZE = 20;\nvar cellHighContrastFocus = {\n  left: -2,\n  top: -2,\n  bottom: -2,\n  right: -2,\n  border: 'none',\n  outlineColor: 'ButtonText'\n};\nexport var getStyles = function getStyles(props) {\n  var _a, _b, _c, _d, _e;\n\n  var theme = props.theme,\n      disabled = props.disabled,\n      selected = props.selected,\n      circle = props.circle,\n      isWhite = props.isWhite,\n      _f = props.height,\n      height = _f === void 0 ? DEFAULT_CELL_SIZE : _f,\n      _g = props.width,\n      width = _g === void 0 ? DEFAULT_CELL_SIZE : _g,\n      borderWidth = props.borderWidth;\n  var semanticColors = theme.semanticColors,\n      palette = theme.palette;\n  var buttonBorderHovered = palette.neutralLighter;\n  var buttonBorderChecked = palette.neutralLight;\n  var buttonBorderCheckedHovered = palette.neutralSecondary;\n  var buttonBorderIsWhite = palette.neutralTertiary; // If user provided a value, use it. If not, then we decide depending on the 24px size breakpoint.\n\n  var calculatedBorderWidth = borderWidth ? borderWidth : width < CELL_BORDER_BREAKPOINT ? SMALL_BORDER : LARGE_BORDER;\n  return {\n    // this is a button that wraps the color\n    colorCell: [getFocusStyle(theme, {\n      inset: -1,\n      position: 'relative',\n      highContrastStyle: cellHighContrastFocus\n    }), {\n      backgroundColor: semanticColors.bodyBackground,\n      padding: 0,\n      position: 'relative',\n      boxSizing: 'border-box',\n      display: 'inline-block',\n      cursor: 'pointer',\n      userSelect: 'none',\n      borderRadius: 0,\n      border: 'none',\n      height: height,\n      width: width\n    }, !circle && {\n      selectors: (_a = {}, _a[\".\" + IsFocusVisibleClassName + \" &:focus::after\"] = {\n        // -1px so that we don't increase visually the size of the cell.\n        outlineOffset: calculatedBorderWidth - 1 + \"px\"\n      }, _a)\n    }, // In focus state for circle we want a round border which is not possible with outline.\n    circle && {\n      borderRadius: '50%',\n      selectors: (_b = {}, _b[\".\" + IsFocusVisibleClassName + \" &:focus::after\"] = {\n        outline: 'none',\n        borderColor: semanticColors.focusBorder,\n        borderRadius: '50%',\n        left: -calculatedBorderWidth,\n        right: -calculatedBorderWidth,\n        top: -calculatedBorderWidth,\n        bottom: -calculatedBorderWidth,\n        selectors: (_c = {}, _c[HighContrastSelector] = {\n          outline: \"1px solid ButtonText\"\n        }, _c)\n      }, _b)\n    }, selected && {\n      padding: DIVIDING_PADDING,\n      border: calculatedBorderWidth + \"px solid \" + buttonBorderChecked,\n      selectors: (_d = {}, _d['&:hover::before'] = {\n        content: '\"\"',\n        height: height,\n        width: width,\n        position: 'absolute',\n        top: -calculatedBorderWidth,\n        left: -calculatedBorderWidth,\n        borderRadius: circle ? '50%' : 'default',\n        boxShadow: \"inset 0 0 0 1px \" + buttonBorderCheckedHovered\n      }, _d)\n    }, !selected && {\n      selectors: (_e = {}, _e['&:hover, &:active, &:focus'] = {\n        backgroundColor: semanticColors.bodyBackground,\n        padding: DIVIDING_PADDING,\n        border: calculatedBorderWidth + \"px solid \" + buttonBorderHovered\n      }, _e['&:focus'] = {\n        borderColor: semanticColors.bodyBackground,\n        padding: 0,\n        selectors: {\n          ':hover': {\n            borderColor: theme.palette.neutralLight,\n            padding: DIVIDING_PADDING\n          }\n        }\n      }, _e)\n    }, disabled && {\n      color: semanticColors.disabledBodyText,\n      pointerEvents: 'none',\n      opacity: 0.3\n    }, isWhite && !selected && {\n      // fake a border for white\n      backgroundColor: buttonBorderIsWhite,\n      padding: 1\n    }],\n    // the <svg> that holds the color\n    svg: [{\n      width: '100%',\n      height: '100%'\n    }, circle && {\n      borderRadius: '50%'\n    }]\n  };\n};","map":{"version":3,"mappings":"AAAA,SAASA,uBAAT,QAAwC,iBAAxC;AACA,SAASC,oBAAT,EAA+BC,aAA/B,QAAoD,eAApD,C,CAGA;;AACA,IAAMC,sBAAsB,GAAG,EAA/B;AACA,IAAMC,YAAY,GAAG,CAArB;AACA,IAAMC,YAAY,GAAG,CAArB;AACA,IAAMC,gBAAgB,GAAG,CAAzB;AACA,IAAMC,iBAAiB,GAAG,EAA1B;AAEA,IAAMC,qBAAqB,GAAG;AAC5BC,MAAI,EAAE,CAAC,CADqB;AAE5BC,KAAG,EAAE,CAAC,CAFsB;AAG5BC,QAAM,EAAE,CAAC,CAHmB;AAI5BC,OAAK,EAAE,CAAC,CAJoB;AAK5BC,QAAM,EAAE,MALoB;AAM5BC,cAAY,EAAE;AANc,CAA9B;AASA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAsC;;;AAE3D;AAAA,MACAC,yBADA;AAAA,MAEAC,yBAFA;AAAA,MAGAC,qBAHA;AAAA,MAIAC,uBAJA;AAAA,MAKAC,iBALA;AAAA,MAKAC,+CALA;AAAA,MAMAC,gBANA;AAAA,MAMAC,8CANA;AAAA,MAOAC,+BAPA;AASM;AAAA,MAAgBC,uBAAhB;AAER,MAAMC,mBAAmB,GAAGD,OAAO,CAACE,cAApC;AACA,MAAMC,mBAAmB,GAAGH,OAAO,CAACI,YAApC;AACA,MAAMC,0BAA0B,GAAGL,OAAO,CAACM,gBAA3C;AACA,MAAMC,mBAAmB,GAAGP,OAAO,CAACQ,eAApC,CAhB6D,CAkB7D;;AACA,MAAMC,qBAAqB,GAAGV,WAAW,GACrCA,WADqC,GAErCD,KAAK,GAAGrB,sBAAR,GACAE,YADA,GAEAD,YAJJ;AAMA,SAAO;AACL;AACAgC,aAAS,EAAE,CACTlC,aAAa,CAACmC,KAAD,EAAQ;AAAEC,WAAK,EAAE,CAAC,CAAV;AAAaC,cAAQ,EAAE,UAAvB;AAAmCC,uBAAiB,EAAEhC;AAAtD,KAAR,CADJ,EAET;AACEiC,qBAAe,EAAEC,cAAc,CAACC,cADlC;AAEEC,aAAO,EAAE,CAFX;AAGEL,cAAQ,EAAE,UAHZ;AAIEM,eAAS,EAAE,YAJb;AAKEC,aAAO,EAAE,cALX;AAMEC,YAAM,EAAE,SANV;AAOEC,gBAAU,EAAE,MAPd;AAQEC,kBAAY,EAAE,CARhB;AASEpC,YAAM,EAAE,MATV;AAUES,YAAM,EAAEA,MAVV;AAWEE,WAAK,EAAEA;AAXT,KAFS,EAeT,CAACL,MAAD,IAAW;AACT+B,eAAS,YACPC,GAAC,MAAInD,uBAAJ,GAA2B,iBAA5B,IAAgD;AAC9C;AACAoD,qBAAa,EAAKjB,qBAAqB,GAAG,CAAxB,GAAyB;AAFG,OADzC;AADA,KAfF,EAuBT;AACAhB,UAAM,IAAI;AACR8B,kBAAY,EAAE,KADN;AAERC,eAAS,YACPG,GAAC,MAAIrD,uBAAJ,GAA2B,iBAA5B,IAAgD;AAC9CsD,eAAO,EAAE,MADqC;AAE9CC,mBAAW,EAAEb,cAAc,CAACc,WAFkB;AAG9CP,oBAAY,EAAE,KAHgC;AAI9CxC,YAAI,EAAE,CAAC0B,qBAJuC;AAK9CvB,aAAK,EAAE,CAACuB,qBALsC;AAM9CzB,WAAG,EAAE,CAACyB,qBANwC;AAO9CxB,cAAM,EAAE,CAACwB,qBAPqC;AAQ9Ce,iBAAS,YACPO,GAACxD,oBAAD,IAAwB;AACtBqD,iBAAO,EAAE;AADa,SADjB;AARqC,OADzC;AAFD,KAxBD,EA2CTpC,QAAQ,IAAI;AACV0B,aAAO,EAAEtC,gBADC;AAEVO,YAAM,EAAKsB,qBAAqB,cAArB,GAAiCN,mBAFlC;AAGVqB,eAAS,YACPQ,GAAC,iBAAD,IAAqB;AACnBC,eAAO,EAAE,IADU;AAEnBrC,cAAM,EAAEA,MAFW;AAGnBE,aAAK,EAAEA,KAHY;AAInBe,gBAAQ,EAAE,UAJS;AAKnB7B,WAAG,EAAE,CAACyB,qBALa;AAMnB1B,YAAI,EAAE,CAAC0B,qBANY;AAOnBc,oBAAY,EAAE9B,MAAM,GAAG,KAAH,GAAW,SAPZ;AAQnByC,iBAAS,EAAE,qBAAmB7B;AARX,OADd;AAHC,KA3CH,EA2DT,CAACb,QAAD,IAAa;AACXgC,eAAS,YACPW,GAAC,4BAAD,IAAgC;AAC9BpB,uBAAe,EAAEC,cAAc,CAACC,cADF;AAE9BC,eAAO,EAAEtC,gBAFqB;AAG9BO,cAAM,EAAKsB,qBAAqB,cAArB,GAAiCR;AAHd,OADzB,EAMPkC,GAAC,SAAD,IAAa;AACXN,mBAAW,EAAEb,cAAc,CAACC,cADjB;AAEXC,eAAO,EAAE,CAFE;AAGXM,iBAAS,EAAE;AACT,oBAAU;AACRK,uBAAW,EAAElB,KAAK,CAACX,OAAN,CAAcI,YADnB;AAERc,mBAAO,EAAEtC;AAFD;AADD;AAHA,OANN;AADE,KA3DJ,EA8ETW,QAAQ,IAAI;AACV6C,WAAK,EAAEpB,cAAc,CAACqB,gBADZ;AAEVC,mBAAa,EAAE,MAFL;AAGVC,aAAO,EAAE;AAHC,KA9EH,EAmFT7C,OAAO,IACL,CAACF,QADH,IACe;AACX;AACAuB,qBAAe,EAAER,mBAFN;AAGXW,aAAO,EAAE;AAHE,KApFN,CAFN;AA4FL;AACAsB,OAAG,EAAE,CACH;AACE1C,WAAK,EAAE,MADT;AAEEF,YAAM,EAAE;AAFV,KADG,EAKHH,MAAM,IAAI;AACR8B,kBAAY,EAAE;AADN,KALP;AA7FA,GAAP;AAuGD,CAhIM","names":["IsFocusVisibleClassName","HighContrastSelector","getFocusStyle","CELL_BORDER_BREAKPOINT","LARGE_BORDER","SMALL_BORDER","DIVIDING_PADDING","DEFAULT_CELL_SIZE","cellHighContrastFocus","left","top","bottom","right","border","outlineColor","getStyles","props","disabled","selected","circle","isWhite","_f","height","_g","width","borderWidth","palette","buttonBorderHovered","neutralLighter","buttonBorderChecked","neutralLight","buttonBorderCheckedHovered","neutralSecondary","buttonBorderIsWhite","neutralTertiary","calculatedBorderWidth","colorCell","theme","inset","position","highContrastStyle","backgroundColor","semanticColors","bodyBackground","padding","boxSizing","display","cursor","userSelect","borderRadius","selectors","_a","outlineOffset","_b","outline","borderColor","focusBorder","_c","_d","content","boxShadow","_e","color","disabledBodyText","pointerEvents","opacity","svg"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\SwatchColorPicker\\ColorPickerGridCell.styles.ts"],"sourcesContent":["import { IsFocusVisibleClassName } from '../../Utilities';\nimport { HighContrastSelector, getFocusStyle } from '../../Styling';\nimport { IColorPickerGridCellStyleProps, IColorPickerGridCellStyles } from './ColorPickerGridCell.types';\n\n// Size breakpoint when the default border width changes from 2px to 4px.\nconst CELL_BORDER_BREAKPOINT = 24;\nconst LARGE_BORDER = 4;\nconst SMALL_BORDER = 2;\nconst DIVIDING_PADDING = 2;\nconst DEFAULT_CELL_SIZE = 20;\n\nconst cellHighContrastFocus = {\n  left: -2,\n  top: -2,\n  bottom: -2,\n  right: -2,\n  border: 'none',\n  outlineColor: 'ButtonText',\n};\n\nexport const getStyles = (props: IColorPickerGridCellStyleProps): IColorPickerGridCellStyles => {\n  const {\n    theme,\n    disabled,\n    selected,\n    circle,\n    isWhite,\n    height = DEFAULT_CELL_SIZE,\n    width = DEFAULT_CELL_SIZE,\n    borderWidth,\n  } = props;\n  const { semanticColors, palette } = theme;\n\n  const buttonBorderHovered = palette.neutralLighter;\n  const buttonBorderChecked = palette.neutralLight;\n  const buttonBorderCheckedHovered = palette.neutralSecondary;\n  const buttonBorderIsWhite = palette.neutralTertiary;\n\n  // If user provided a value, use it. If not, then we decide depending on the 24px size breakpoint.\n  const calculatedBorderWidth = borderWidth\n    ? borderWidth\n    : width < CELL_BORDER_BREAKPOINT\n    ? SMALL_BORDER\n    : LARGE_BORDER;\n\n  return {\n    // this is a button that wraps the color\n    colorCell: [\n      getFocusStyle(theme, { inset: -1, position: 'relative', highContrastStyle: cellHighContrastFocus }),\n      {\n        backgroundColor: semanticColors.bodyBackground,\n        padding: 0,\n        position: 'relative',\n        boxSizing: 'border-box',\n        display: 'inline-block',\n        cursor: 'pointer',\n        userSelect: 'none',\n        borderRadius: 0,\n        border: 'none',\n        height: height,\n        width: width,\n      },\n      !circle && {\n        selectors: {\n          [`.${IsFocusVisibleClassName} &:focus::after`]: {\n            // -1px so that we don't increase visually the size of the cell.\n            outlineOffset: `${calculatedBorderWidth - 1}px`,\n          },\n        },\n      },\n      // In focus state for circle we want a round border which is not possible with outline.\n      circle && {\n        borderRadius: '50%',\n        selectors: {\n          [`.${IsFocusVisibleClassName} &:focus::after`]: {\n            outline: 'none',\n            borderColor: semanticColors.focusBorder,\n            borderRadius: '50%',\n            left: -calculatedBorderWidth,\n            right: -calculatedBorderWidth,\n            top: -calculatedBorderWidth,\n            bottom: -calculatedBorderWidth,\n            selectors: {\n              [HighContrastSelector]: {\n                outline: `1px solid ButtonText`,\n              },\n            },\n          },\n        },\n      },\n      selected && {\n        padding: DIVIDING_PADDING,\n        border: `${calculatedBorderWidth}px solid ${buttonBorderChecked}`,\n        selectors: {\n          ['&:hover::before']: {\n            content: '\"\"',\n            height: height,\n            width: width,\n            position: 'absolute',\n            top: -calculatedBorderWidth,\n            left: -calculatedBorderWidth,\n            borderRadius: circle ? '50%' : 'default',\n            boxShadow: `inset 0 0 0 1px ${buttonBorderCheckedHovered}`,\n          },\n        },\n      },\n      !selected && {\n        selectors: {\n          ['&:hover, &:active, &:focus']: {\n            backgroundColor: semanticColors.bodyBackground, // overwrite white's override\n            padding: DIVIDING_PADDING,\n            border: `${calculatedBorderWidth}px solid ${buttonBorderHovered}`,\n          },\n          ['&:focus']: {\n            borderColor: semanticColors.bodyBackground,\n            padding: 0,\n            selectors: {\n              ':hover': {\n                borderColor: theme.palette.neutralLight,\n                padding: DIVIDING_PADDING,\n              },\n            },\n          },\n        },\n      },\n      disabled && {\n        color: semanticColors.disabledBodyText,\n        pointerEvents: 'none',\n        opacity: 0.3,\n      },\n      isWhite &&\n        !selected && {\n          // fake a border for white\n          backgroundColor: buttonBorderIsWhite,\n          padding: 1,\n        },\n    ],\n    // the <svg> that holds the color\n    svg: [\n      {\n        width: '100%',\n        height: '100%',\n      },\n      circle && {\n        borderRadius: '50%',\n      },\n    ],\n  };\n};\n"]},"metadata":{},"sourceType":"module"}