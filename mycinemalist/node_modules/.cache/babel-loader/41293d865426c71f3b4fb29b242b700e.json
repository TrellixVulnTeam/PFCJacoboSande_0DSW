{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, AutoScroll, classNamesFunction, findScrollableParent, getDistanceBetweenPoints, getRTL, initializeComponentRef } from '../../Utilities';\nvar getClassNames = classNamesFunction(); // We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\n\nvar MIN_DRAG_DISTANCE = 5;\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\n\nvar MarqueeSelectionBase =\n/** @class */\nfunction (_super) {\n  __extends(MarqueeSelectionBase, _super);\n\n  function MarqueeSelectionBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n\n    _this._onMouseDown = function (ev) {\n      var _a = _this.props,\n          isEnabled = _a.isEnabled,\n          onShouldStartSelection = _a.onShouldStartSelection; // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n\n      if (_this._isMouseEventOnScrollbar(ev)) {\n        return;\n      }\n\n      if (_this._isInSelectionToggle(ev)) {\n        return;\n      }\n\n      if (!_this._isTouch && isEnabled && !_this._isDragStartInSelection(ev) && (!onShouldStartSelection || onShouldStartSelection(ev))) {\n        if (_this._scrollableSurface && ev.button === 0 && _this._root.current) {\n          _this._selectedIndicies = {};\n          _this._preservedIndicies = undefined;\n\n          _this._events.on(window, 'mousemove', _this._onAsyncMouseMove, true);\n\n          _this._events.on(_this._scrollableParent, 'scroll', _this._onAsyncMouseMove);\n\n          _this._events.on(window, 'click', _this._onMouseUp, true);\n\n          _this._autoScroll = new AutoScroll(_this._root.current);\n          _this._scrollTop = _this._scrollableSurface.scrollTop;\n          _this._scrollLeft = _this._scrollableSurface.scrollLeft;\n          _this._rootRect = _this._root.current.getBoundingClientRect();\n\n          _this._onMouseMove(ev);\n        }\n      }\n    };\n\n    _this._onTouchStart = function (ev) {\n      _this._isTouch = true;\n\n      _this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 0);\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._isTouch = true;\n\n        _this._async.setTimeout(function () {\n          _this._isTouch = false;\n        }, 0);\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      dragRect: undefined\n    };\n    return _this;\n  }\n\n  MarqueeSelectionBase.prototype.componentDidMount = function () {\n    this._scrollableParent = findScrollableParent(this._root.current);\n    this._scrollableSurface = this._scrollableParent === window ? document.body : this._scrollableParent; // When scroll events come from window, we need to read scrollTop values from the body.\n\n    var hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  };\n\n  MarqueeSelectionBase.prototype.componentWillUnmount = function () {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  MarqueeSelectionBase.prototype.render = function () {\n    var _a = this.props,\n        rootProps = _a.rootProps,\n        children = _a.children,\n        theme = _a.theme,\n        className = _a.className,\n        styles = _a.styles;\n    var dragRect = this.state.dragRect;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    return React.createElement(\"div\", __assign({}, rootProps, {\n      className: classNames.root,\n      ref: this._root\n    }), children, dragRect && React.createElement(\"div\", {\n      className: classNames.dragMask\n    }), dragRect && React.createElement(\"div\", {\n      className: classNames.box,\n      style: dragRect\n    }, React.createElement(\"div\", {\n      className: classNames.boxFill\n    })));\n  };\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n\n\n  MarqueeSelectionBase.prototype._isMouseEventOnScrollbar = function (ev) {\n    var targetElement = ev.target;\n    var targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n\n    if (targetScrollbarWidth) {\n      var targetRect = targetElement.getBoundingClientRect(); // Check vertical scroll\n\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      } // Check horizontal scroll\n\n\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._getRootRect = function () {\n    return {\n      left: this._rootRect.left + (this._scrollLeft - this._scrollableSurface.scrollLeft),\n      top: this._rootRect.top + (this._scrollTop - this._scrollableSurface.scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height\n    };\n  };\n\n  MarqueeSelectionBase.prototype._onAsyncMouseMove = function (ev) {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      _this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  MarqueeSelectionBase.prototype._onMouseMove = function (ev) {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    var rootRect = this._getRootRect();\n\n    var currentPoint = {\n      left: ev.clientX - rootRect.left,\n      top: ev.clientY - rootRect.top\n    };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          var selection = this.props.selection;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        } // We need to constrain the current point to the rootRect boundaries.\n\n\n        var constrainedPoint = this.props.isDraggingConstrainedToRoot ? {\n          left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent.clientX - rootRect.left)),\n          top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent.clientY - rootRect.top))\n        } : {\n          left: this._lastMouseEvent.clientX - rootRect.left,\n          top: this._lastMouseEvent.clientY - rootRect.top\n        };\n        var dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0))\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({\n          dragRect: dragRect\n        });\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._onMouseUp = function (ev) {\n    this._events.off(window);\n\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined\n      });\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  MarqueeSelectionBase.prototype._isPointInRectangle = function (rectangle, point) {\n    return !!point.top && rectangle.top < point.top && rectangle.bottom > point.top && !!point.left && rectangle.left < point.left && rectangle.right > point.left;\n  };\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n\n\n  MarqueeSelectionBase.prototype._isDragStartInSelection = function (ev) {\n    var selection = this.props.selection;\n\n    if (!this._root.current || selection && selection.getSelectedCount() === 0) {\n      return false;\n    }\n\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = Number(element.getAttribute('data-selection-index'));\n\n      if (selection.isIndexSelected(index)) {\n        var itemRect = element.getBoundingClientRect();\n\n        if (this._isPointInRectangle(itemRect, {\n          left: ev.clientX,\n          top: ev.clientY\n        })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._isInSelectionToggle = function (ev) {\n    var element = ev.target;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._evaluateSelection = function (dragRect, rootRect) {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    var selection = this.props.selection;\n\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = element.getAttribute('data-selection-index'); // Pull the memoized rectangle for the item, or the get the rect and memoize.\n\n      var itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect(); // Normalize the item rect to the dragRect coordinates.\n\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (itemRect.top < dragRect.top + dragRect.height && itemRect.bottom > dragRect.top && itemRect.left < dragRect.left + dragRect.width && itemRect.right > dragRect.left) {\n        this._selectedIndicies[index] = true;\n      } else {\n        delete this._selectedIndicies[index];\n      }\n    } // set previousSelectedIndices to be all of the selected indices from last time\n\n\n    var previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {}; // set all indices that are supposed to be selected in _allSelectedIndices\n\n    for (var index in this._selectedIndicies) {\n      if (this._selectedIndicies.hasOwnProperty(index)) {\n        this._allSelectedIndices[index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (var _i = 0, _a = this._preservedIndicies; _i < _a.length; _i++) {\n        var index = _a[_i];\n        this._allSelectedIndices[index] = true;\n      }\n    } // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n\n\n    var needToUpdate = false;\n\n    for (var index in this._allSelectedIndices) {\n      if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (var index in previousSelectedIndices) {\n        if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    } // only update selection when needed\n\n\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (var _b = 0, _c = Object.keys(this._allSelectedIndices); _b < _c.length; _b++) {\n        var index = _c[_b];\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  };\n\n  MarqueeSelectionBase.defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true\n  };\n  return MarqueeSelectionBase;\n}(React.Component);\n\nexport { MarqueeSelectionBase };","map":{"version":3,"mappings":"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","names":["React","Async","EventGroup","AutoScroll","classNamesFunction","findScrollableParent","getDistanceBetweenPoints","getRTL","initializeComponentRef","getClassNames","MIN_DRAG_DISTANCE","__extends","props","_super","_this","createRef","ev","isEnabled","onShouldStartSelection","_isMouseEventOnScrollbar","_isInSelectionToggle","_isTouch","_isDragStartInSelection","_scrollableSurface","button","_root","current","_selectedIndicies","_preservedIndicies","undefined","_events","on","window","_onAsyncMouseMove","_scrollableParent","_onMouseUp","_autoScroll","_scrollTop","scrollTop","_scrollLeft","scrollLeft","_rootRect","getBoundingClientRect","_onMouseMove","_async","setTimeout","pointerType","state","dragRect","MarqueeSelectionBase","document","body","hitTarget","isDraggingConstrainedToRoot","_onMouseDown","_onTouchStart","_onPointerDown","dispose","rootProps","children","theme","className","styles","classNames","root","ref","dragMask","box","style","boxFill","targetElement","target","targetScrollbarWidth","offsetWidth","clientWidth","targetRect","clientX","left","clientY","top","clientHeight","width","height","requestAnimationFrame","stopPropagation","preventDefault","_lastMouseEvent","rootRect","_getRootRect","currentPoint","_dragOrigin","buttons","shiftKey","selection","setAllSelected","getSelectedIndices","constrainedPoint","Math","max","min","abs","_evaluateSelection","setState","off","_itemRectCache","rectangle","point","bottom","right","getSelectedCount","allElements","querySelectorAll","i","length","element","index","Number","getAttribute","isIndexSelected","itemRect","_isPointInRectangle","parentElement","previousSelectedIndices","_allSelectedIndices","hasOwnProperty","_i","needToUpdate","setChangeEvents","keys","_b","setIndexSelected","rootTagName","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\MarqueeSelection\\MarqueeSelection.base.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport {\n  Async,\n  EventGroup,\n  AutoScroll,\n  Point,\n  IRectangle,\n  classNamesFunction,\n  findScrollableParent,\n  getDistanceBetweenPoints,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\n\nimport { IMarqueeSelectionProps, IMarqueeSelectionStyleProps, IMarqueeSelectionStyles } from './MarqueeSelection.types';\nimport {} from '@uifabric/utilities';\n\nconst getClassNames = classNamesFunction<IMarqueeSelectionStyleProps, IMarqueeSelectionStyles>();\n\nexport interface IMarqueeSelectionState {\n  dragOrigin?: Point;\n  dragRect?: IRectangle;\n}\n\n// We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\nconst MIN_DRAG_DISTANCE = 5;\n\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\nexport class MarqueeSelectionBase extends React.Component<IMarqueeSelectionProps, IMarqueeSelectionState> {\n  public static defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _dragOrigin: Point | undefined;\n  private _rootRect: IRectangle;\n  private _lastMouseEvent: MouseEvent | undefined;\n  private _autoScroll: AutoScroll | undefined;\n  private _selectedIndicies: { [key: string]: boolean } | undefined;\n  private _preservedIndicies: number[] | undefined;\n  private _itemRectCache: { [key: string]: IRectangle } | undefined;\n  private _allSelectedIndices: { [key: string]: boolean } | undefined;\n  private _scrollableParent: HTMLElement;\n  private _scrollableSurface: HTMLElement;\n  private _scrollTop: number;\n  private _scrollLeft: number;\n  private _isTouch: boolean;\n\n  constructor(props: IMarqueeSelectionProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      dragRect: undefined,\n    };\n  }\n\n  public componentDidMount(): void {\n    this._scrollableParent = findScrollableParent(this._root.current) as HTMLElement;\n    this._scrollableSurface = this._scrollableParent === (window as any) ? document.body : this._scrollableParent;\n    // When scroll events come from window, we need to read scrollTop values from the body.\n\n    const hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  }\n\n  public componentWillUnmount(): void {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { rootProps, children, theme, className, styles } = this.props;\n    const { dragRect } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    return (\n      <div {...rootProps} className={classNames.root} ref={this._root}>\n        {children}\n        {dragRect && <div className={classNames.dragMask} />}\n        {dragRect && (\n          <div className={classNames.box} style={dragRect}>\n            <div className={classNames.boxFill} />\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n  private _isMouseEventOnScrollbar(ev: MouseEvent): boolean {\n    const targetElement = ev.target as HTMLElement;\n    const targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n\n    if (targetScrollbarWidth) {\n      const targetRect = targetElement.getBoundingClientRect();\n\n      // Check vertical scroll\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      }\n\n      // Check horizontal scroll\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseDown = (ev: MouseEvent): void => {\n    const { isEnabled, onShouldStartSelection } = this.props;\n\n    // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n    if (this._isMouseEventOnScrollbar(ev)) {\n      return;\n    }\n\n    if (this._isInSelectionToggle(ev)) {\n      return;\n    }\n\n    if (\n      !this._isTouch &&\n      isEnabled &&\n      !this._isDragStartInSelection(ev) &&\n      (!onShouldStartSelection || onShouldStartSelection(ev))\n    ) {\n      if (this._scrollableSurface && ev.button === 0 && this._root.current) {\n        this._selectedIndicies = {};\n        this._preservedIndicies = undefined;\n        this._events.on(window, 'mousemove', this._onAsyncMouseMove, true);\n        this._events.on(this._scrollableParent, 'scroll', this._onAsyncMouseMove);\n        this._events.on(window, 'click', this._onMouseUp, true);\n\n        this._autoScroll = new AutoScroll(this._root.current);\n        this._scrollTop = this._scrollableSurface.scrollTop;\n        this._scrollLeft = this._scrollableSurface.scrollLeft;\n        this._rootRect = this._root.current.getBoundingClientRect();\n\n        this._onMouseMove(ev);\n      }\n    }\n  };\n\n  private _onTouchStart = (ev: TouchEvent): void => {\n    this._isTouch = true;\n\n    this._async.setTimeout(() => {\n      this._isTouch = false;\n    }, 0);\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._isTouch = true;\n\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 0);\n    }\n  };\n\n  private _getRootRect(): IRectangle {\n    return {\n      left: this._rootRect.left + (this._scrollLeft - this._scrollableSurface.scrollLeft),\n      top: this._rootRect.top + (this._scrollTop - this._scrollableSurface.scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height,\n    };\n  }\n\n  private _onAsyncMouseMove(ev: MouseEvent): void {\n    this._async.requestAnimationFrame(() => {\n      this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  }\n\n  private _onMouseMove(ev: MouseEvent): boolean | undefined {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    const rootRect = this._getRootRect();\n    const currentPoint = { left: ev.clientX - rootRect.left, top: ev.clientY - rootRect.top };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          const { selection } = this.props;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        }\n\n        // We need to constrain the current point to the rootRect boundaries.\n        const constrainedPoint = this.props.isDraggingConstrainedToRoot\n          ? {\n              left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent!.clientX - rootRect.left)),\n              top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent!.clientY - rootRect.top)),\n            }\n          : {\n              left: this._lastMouseEvent!.clientX - rootRect.left,\n              top: this._lastMouseEvent!.clientY - rootRect.top,\n            };\n\n        const dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0)),\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({ dragRect });\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseUp(ev: MouseEvent): void {\n    this._events.off(window);\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined,\n      });\n\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _isPointInRectangle(rectangle: IRectangle, point: Point): boolean {\n    return (\n      !!point.top &&\n      rectangle.top < point.top &&\n      rectangle.bottom! > point.top &&\n      !!point.left &&\n      rectangle.left < point.left &&\n      rectangle.right! > point.left\n    );\n  }\n\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n  private _isDragStartInSelection(ev: MouseEvent): boolean {\n    const selection = this.props.selection;\n    if (!this._root.current || (selection && selection.getSelectedCount() === 0)) {\n      return false;\n    }\n\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = Number(element.getAttribute('data-selection-index'));\n      if (selection.isIndexSelected(index)) {\n        const itemRect = element.getBoundingClientRect();\n        if (this._isPointInRectangle(itemRect, { left: ev.clientX, top: ev.clientY })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private _isInSelectionToggle(ev: MouseEvent): boolean {\n    let element: HTMLElement | null = ev.target as HTMLElement;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  }\n\n  private _evaluateSelection(dragRect: IRectangle, rootRect: IRectangle): void {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    const { selection } = this.props;\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = element.getAttribute('data-selection-index') as string;\n\n      // Pull the memoized rectangle for the item, or the get the rect and memoize.\n      let itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect();\n\n        // Normalize the item rect to the dragRect coordinates.\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height,\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (\n        itemRect.top < dragRect.top + dragRect.height &&\n        itemRect.bottom! > dragRect.top &&\n        itemRect.left < dragRect.left + dragRect.width &&\n        itemRect.right! > dragRect.left\n      ) {\n        this._selectedIndicies![index] = true;\n      } else {\n        delete this._selectedIndicies![index];\n      }\n    }\n\n    // set previousSelectedIndices to be all of the selected indices from last time\n    const previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {};\n\n    // set all indices that are supposed to be selected in _allSelectedIndices\n    for (const index in this._selectedIndicies!) {\n      if (this._selectedIndicies!.hasOwnProperty(index)) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (const index of this._preservedIndicies!) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n    let needToUpdate = false;\n    for (const index in this._allSelectedIndices!) {\n      if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (const index in previousSelectedIndices!) {\n        if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    }\n\n    // only update selection when needed\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (const index of Object.keys(this._allSelectedIndices!)) {\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}