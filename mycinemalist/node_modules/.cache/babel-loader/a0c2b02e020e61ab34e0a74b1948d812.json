{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, divProperties, doesElementContainFocus, getDocument, getNativeProps, on, getWindow, elementContains } from '../../Utilities';\n/**\n * This adds accessibility to Dialog and Panel controls\n */\n\nvar Popup =\n/** @class */\nfunction (_super) {\n  __extends(Popup, _super);\n\n  function Popup(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._disposables = [];\n\n    _this._onKeyDown = function (ev) {\n      switch (ev.which) {\n        case KeyCodes.escape:\n          if (_this.props.onDismiss) {\n            _this.props.onDismiss(ev);\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n\n          break;\n      }\n    };\n\n    _this._onFocus = function () {\n      _this._containsFocus = true;\n    };\n\n    _this._onBlur = function (ev) {\n      /** The popup should update this._containsFocus when:\n       * relatedTarget exists AND\n       * the relatedTarget is not contained within the popup.\n       * If the relatedTarget is within the popup, that means the popup still has focus\n       * and focused moved from one element to another within the popup.\n       * If relatedTarget is undefined or null that usually means that a\n       * keyboard event occured and focus didn't change\n       */\n      if (_this._root.current && ev.relatedTarget && !elementContains(_this._root.current, ev.relatedTarget)) {\n        _this._containsFocus = false;\n      }\n    };\n\n    _this._async = new Async(_this);\n    _this.state = {\n      needsVerticalScrollBar: false\n    };\n    return _this;\n  }\n\n  Popup.prototype.UNSAFE_componentWillMount = function () {\n    this._originalFocusedElement = getDocument().activeElement;\n  };\n\n  Popup.prototype.componentDidMount = function () {\n    if (this._root.current) {\n      this._disposables.push(on(this._root.current, 'focus', this._onFocus, true), on(this._root.current, 'blur', this._onBlur, true));\n\n      var currentWindow = getWindow(this._root.current);\n\n      if (currentWindow) {\n        this._disposables.push(on(currentWindow, 'keydown', this._onKeyDown));\n      }\n\n      if (doesElementContainFocus(this._root.current)) {\n        this._containsFocus = true;\n      }\n    }\n\n    this._updateScrollBarAsync();\n  };\n\n  Popup.prototype.componentDidUpdate = function () {\n    this._updateScrollBarAsync();\n\n    this._async.dispose();\n  };\n\n  Popup.prototype.componentWillUnmount = function () {\n    var _a;\n\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    }); // eslint-disable-next-line deprecation/deprecation\n\n\n    if (this.props.shouldRestoreFocus) {\n      var _b = this.props.onRestoreFocus,\n          onRestoreFocus = _b === void 0 ? defaultFocusRestorer : _b;\n      onRestoreFocus({\n        originalElement: this._originalFocusedElement,\n        containsFocus: this._containsFocus,\n        documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false\n      });\n    } // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n\n\n    delete this._originalFocusedElement;\n  };\n\n  Popup.prototype.render = function () {\n    var _a = this.props,\n        role = _a.role,\n        className = _a.className,\n        ariaLabel = _a.ariaLabel,\n        ariaLabelledBy = _a.ariaLabelledBy,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        style = _a.style;\n    return React.createElement(\"div\", __assign({\n      ref: this._root\n    }, getNativeProps(this.props, divProperties), {\n      className: className,\n      role: role,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy,\n      onKeyDown: this._onKeyDown,\n      style: __assign({\n        overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined,\n        outline: 'none'\n      }, style)\n    }), this.props.children);\n  };\n\n  Popup.prototype._updateScrollBarAsync = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      _this._getScrollBar();\n    });\n  };\n\n  Popup.prototype._getScrollBar = function () {\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\n    if (this.props.style && this.props.style.overflowY) {\n      return;\n    }\n\n    var needsVerticalScrollBar = false;\n\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\n      // ClientHeight returns the client height of an element rounded to an\n      // integer. On some browsers at different zoom levels this rounding\n      // can generate different results for the root container and child even\n      // though they are the same height. This causes us to show a scroll bar\n      // when not needed. Ideally we would use BoundingClientRect().height\n      // instead however seems that the API is 90% slower than using ClientHeight.\n      // Therefore instead we will calculate the difference between heights and\n      // allow for a 1px difference to still be considered ok and not show the\n      // scroll bar.\n      var rootHeight = this._root.current.clientHeight;\n      var firstChildHeight = this._root.current.firstElementChild.clientHeight;\n\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\n        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n      }\n    }\n\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\n      this.setState({\n        needsVerticalScrollBar: needsVerticalScrollBar\n      });\n    }\n  };\n\n  Popup.defaultProps = {\n    shouldRestoreFocus: true\n  };\n  return Popup;\n}(React.Component);\n\nexport { Popup };\n\nfunction defaultFocusRestorer(options) {\n  var originalElement = options.originalElement,\n      containsFocus = options.containsFocus;\n\n  if (originalElement && containsFocus && originalElement !== window) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    if (originalElement.focus) {\n      originalElement.focus();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["React","Async","KeyCodes","divProperties","doesElementContainFocus","getDocument","getNativeProps","on","getWindow","elementContains","__extends","props","_super","_this","createRef","ev","which","escape","onDismiss","preventDefault","stopPropagation","_containsFocus","_root","current","relatedTarget","_async","state","needsVerticalScrollBar","Popup","_originalFocusedElement","activeElement","_disposables","push","_onFocus","_onBlur","currentWindow","_onKeyDown","_updateScrollBarAsync","dispose","forEach","shouldRestoreFocus","onRestoreFocus","originalElement","containsFocus","documentContainsFocus","_a","hasFocus","role","className","ariaLabel","ariaLabelledBy","ariaDescribedBy","style","ref","onKeyDown","overflowY","undefined","outline","children","requestAnimationFrame","_getScrollBar","firstElementChild","rootHeight","clientHeight","firstChildHeight","setState","Component","defaultFocusRestorer","options","window","focus"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\Popup\\Popup.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  KeyCodes,\n  divProperties,\n  doesElementContainFocus,\n  getDocument,\n  getNativeProps,\n  on,\n  getWindow,\n  elementContains,\n} from '../../Utilities';\nimport { IPopupProps } from './Popup.types';\n\nexport interface IPopupState {\n  needsVerticalScrollBar?: boolean;\n}\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport class Popup extends React.Component<IPopupProps, IPopupState> {\n  public static defaultProps: IPopupProps = {\n    shouldRestoreFocus: true,\n  };\n\n  public _root = React.createRef<HTMLDivElement>();\n  private _disposables: (() => void)[] = [];\n  private _originalFocusedElement: HTMLElement;\n  private _containsFocus: boolean;\n  private _async: Async;\n\n  public constructor(props: IPopupProps) {\n    super(props);\n    this._async = new Async(this);\n    this.state = { needsVerticalScrollBar: false };\n  }\n\n  public UNSAFE_componentWillMount(): void {\n    this._originalFocusedElement = getDocument()!.activeElement as HTMLElement;\n  }\n\n  public componentDidMount(): void {\n    if (this._root.current) {\n      this._disposables.push(\n        on(this._root.current, 'focus', this._onFocus, true),\n        on(this._root.current, 'blur', this._onBlur, true),\n      );\n      const currentWindow = getWindow(this._root.current);\n      if (currentWindow) {\n        this._disposables.push(on(currentWindow, 'keydown', this._onKeyDown as any));\n      }\n      if (doesElementContainFocus(this._root.current)) {\n        this._containsFocus = true;\n      }\n    }\n\n    this._updateScrollBarAsync();\n  }\n\n  public componentDidUpdate() {\n    this._updateScrollBarAsync();\n    this._async.dispose();\n  }\n\n  public componentWillUnmount(): void {\n    this._disposables.forEach((dispose: () => void) => dispose());\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.shouldRestoreFocus) {\n      const { onRestoreFocus = defaultFocusRestorer } = this.props;\n      onRestoreFocus({\n        originalElement: this._originalFocusedElement,\n        containsFocus: this._containsFocus,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n    }\n    // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n    delete this._originalFocusedElement;\n  }\n\n  public render(): JSX.Element {\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style } = this.props;\n\n    return (\n      <div\n        ref={this._root}\n        {...getNativeProps(this.props, divProperties)}\n        className={className}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        onKeyDown={this._onKeyDown}\n        style={{ overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none', ...style }}\n      >\n        {this.props.children}\n      </div>\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    switch (ev.which) {\n      case KeyCodes.escape:\n        if (this.props.onDismiss) {\n          this.props.onDismiss(ev);\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        break;\n    }\n  };\n\n  private _updateScrollBarAsync(): void {\n    this._async.requestAnimationFrame(() => {\n      this._getScrollBar();\n    });\n  }\n\n  private _getScrollBar(): void {\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\n    if (this.props.style && this.props.style.overflowY) {\n      return;\n    }\n\n    let needsVerticalScrollBar = false;\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\n      // ClientHeight returns the client height of an element rounded to an\n      // integer. On some browsers at different zoom levels this rounding\n      // can generate different results for the root container and child even\n      // though they are the same height. This causes us to show a scroll bar\n      // when not needed. Ideally we would use BoundingClientRect().height\n      // instead however seems that the API is 90% slower than using ClientHeight.\n      // Therefore instead we will calculate the difference between heights and\n      // allow for a 1px difference to still be considered ok and not show the\n      // scroll bar.\n      const rootHeight = this._root.current.clientHeight;\n      const firstChildHeight = this._root.current.firstElementChild.clientHeight;\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\n        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n      }\n    }\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\n      this.setState({\n        needsVerticalScrollBar: needsVerticalScrollBar,\n      });\n    }\n  }\n\n  private _onFocus = (): void => {\n    this._containsFocus = true;\n  };\n\n  private _onBlur = (ev: FocusEvent): void => {\n    /** The popup should update this._containsFocus when:\n     * relatedTarget exists AND\n     * the relatedTarget is not contained within the popup.\n     * If the relatedTarget is within the popup, that means the popup still has focus\n     * and focused moved from one element to another within the popup.\n     * If relatedTarget is undefined or null that usually means that a\n     * keyboard event occured and focus didn't change\n     */\n    if (\n      this._root.current &&\n      ev.relatedTarget &&\n      !elementContains(this._root.current, ev.relatedTarget as HTMLElement)\n    ) {\n      this._containsFocus = false;\n    }\n  };\n}\n\nfunction defaultFocusRestorer(options: {\n  originalElement?: HTMLElement | Window;\n  containsFocus: boolean;\n  documentContainsFocus: boolean;\n}) {\n  const { originalElement, containsFocus } = options;\n\n  if (originalElement && containsFocus && originalElement !== window) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    if (originalElement.focus) {\n      originalElement.focus();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}