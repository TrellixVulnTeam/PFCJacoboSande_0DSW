{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, on, initializeComponentRef, KeyCodes, getId } from '../../../Utilities';\nimport { MAX_COLOR_SATURATION, MAX_COLOR_VALUE } from '../../../utilities/color/consts';\nimport { getFullColorString } from '../../../utilities/color/getFullColorString';\nimport { updateSV } from '../../../utilities/color/updateSV';\nimport { clamp } from '../../../utilities/color/clamp';\nvar getClassNames = classNamesFunction();\n/**\n * {@docCategory ColorPicker}\n */\n\nvar ColorRectangleBase =\n/** @class */\nfunction (_super) {\n  __extends(ColorRectangleBase, _super);\n\n  function ColorRectangleBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._disposables = [];\n    _this._root = React.createRef();\n    _this._isAdjustingSaturation = true;\n    _this._descriptionId = getId('ColorRectangle-description');\n\n    _this._onKeyDown = function (ev) {\n      var color = _this.state.color;\n      var s = color.s,\n          v = color.v;\n      var increment = ev.shiftKey ? 10 : 1; // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n      // and getting all the math and styles flipped correctly is tricky\n\n      switch (ev.which) {\n        case KeyCodes.up:\n          {\n            _this._isAdjustingSaturation = false;\n            v += increment; // V = 100 (lightest) is at the top\n\n            break;\n          }\n\n        case KeyCodes.down:\n          {\n            _this._isAdjustingSaturation = false;\n            v -= increment; // V = 0 (darkest) is at the bottom\n\n            break;\n          }\n\n        case KeyCodes.left:\n          {\n            _this._isAdjustingSaturation = true;\n            s -= increment;\n            break;\n          }\n\n        case KeyCodes.right:\n          {\n            _this._isAdjustingSaturation = true;\n            s += increment;\n            break;\n          }\n\n        default:\n          return;\n      }\n\n      _this._updateColor(ev, updateSV(color, clamp(s, MAX_COLOR_SATURATION), clamp(v, MAX_COLOR_VALUE)));\n    };\n\n    _this._onMouseDown = function (ev) {\n      _this._disposables.push(on(window, 'mousemove', _this._onMouseMove, true), on(window, 'mouseup', _this._disposeListeners, true));\n\n      _this._onMouseMove(ev);\n    };\n\n    _this._onMouseMove = function (ev) {\n      if (!_this._root.current) {\n        return;\n      } // Leaving the following commented code which is sometimes necessary for debugging:\n      // If the primary button (1) isn't pressed, the user is no longer dragging, so turn off\n      // the event handlers and exit.\n      // if (!(ev.buttons & 1)) {\n      //   this._disposeListeners();\n      //   return;\n      // }\n\n\n      var newColor = _getNewColor(ev, _this.state.color, _this._root.current);\n\n      if (newColor) {\n        _this._updateColor(ev, newColor);\n      }\n    };\n\n    _this._disposeListeners = function () {\n      _this._disposables.forEach(function (dispose) {\n        return dispose();\n      });\n\n      _this._disposables = [];\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      color: props.color\n    };\n    return _this;\n  }\n\n  Object.defineProperty(ColorRectangleBase.prototype, \"color\", {\n    get: function () {\n      return this.state.color;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ColorRectangleBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // if props changed (as opposed to a state update), set the value\n    // TODO: switch to strict controlled pattern instead\n    if (prevProps !== this.props && this.props.color) {\n      this.setState({\n        color: this.props.color\n      });\n    }\n  };\n\n  ColorRectangleBase.prototype.componentWillUnmount = function () {\n    this._disposeListeners();\n  };\n\n  ColorRectangleBase.prototype.render = function () {\n    var _a = this.props,\n        minSize = _a.minSize,\n        theme = _a.theme,\n        className = _a.className,\n        styles = _a.styles,\n        ariaValueFormat = _a.ariaValueFormat,\n        ariaLabel = _a.ariaLabel,\n        ariaDescription = _a.ariaDescription;\n    var color = this.state.color;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      minSize: minSize\n    });\n    var valueText = ariaValueFormat.replace('{0}', String(color.s)).replace('{1}', String(color.v));\n    return React.createElement(\"div\", {\n      ref: this._root,\n      tabIndex: 0,\n      className: classNames.root,\n      style: {\n        backgroundColor: getFullColorString(color)\n      },\n      onMouseDown: this._onMouseDown,\n      onKeyDown: this._onKeyDown,\n      role: \"slider\",\n      \"aria-valuetext\": valueText,\n      \"aria-valuenow\": this._isAdjustingSaturation ? color.s : color.v,\n      \"aria-valuemin\": 0,\n      \"aria-valuemax\": MAX_COLOR_VALUE,\n      \"aria-label\": ariaLabel,\n      \"aria-describedby\": this._descriptionId,\n      \"data-is-focusable\": true\n    }, React.createElement(\"div\", {\n      className: classNames.description,\n      id: this._descriptionId\n    }, ariaDescription), React.createElement(\"div\", {\n      className: classNames.light\n    }), React.createElement(\"div\", {\n      className: classNames.dark\n    }), React.createElement(\"div\", {\n      className: classNames.thumb,\n      style: {\n        left: color.s + '%',\n        top: MAX_COLOR_VALUE - color.v + '%',\n        backgroundColor: color.str\n      }\n    }));\n  };\n\n  ColorRectangleBase.prototype._updateColor = function (ev, color) {\n    var onChange = this.props.onChange;\n    var oldColor = this.state.color;\n\n    if (color.s === oldColor.s && color.v === oldColor.v) {\n      return; // no change\n    }\n\n    if (onChange) {\n      onChange(ev, color);\n    }\n\n    if (!ev.defaultPrevented) {\n      this.setState({\n        color: color\n      });\n      ev.preventDefault();\n    }\n  };\n\n  ColorRectangleBase.defaultProps = {\n    minSize: 220,\n    ariaLabel: 'Saturation and brightness',\n    ariaValueFormat: 'Saturation {0} brightness {1}',\n    ariaDescription: 'Use left and right arrow keys to set saturation. Use up and down arrow keys to set brightness.'\n  };\n  return ColorRectangleBase;\n}(React.Component);\n\nexport { ColorRectangleBase };\n/**\n * Exported for testing only.\n * @internal\n */\n\nexport function _getNewColor(ev, prevColor, root) {\n  var rectSize = root.getBoundingClientRect();\n  var sPercentage = (ev.clientX - rectSize.left) / rectSize.width;\n  var vPercentage = (ev.clientY - rectSize.top) / rectSize.height;\n  return updateSV(prevColor, clamp(Math.round(sPercentage * MAX_COLOR_SATURATION), MAX_COLOR_SATURATION), clamp(Math.round(MAX_COLOR_VALUE - vPercentage * MAX_COLOR_VALUE), MAX_COLOR_VALUE));\n}","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","on","initializeComponentRef","KeyCodes","getId","MAX_COLOR_SATURATION","MAX_COLOR_VALUE","getFullColorString","updateSV","clamp","getClassNames","__extends","props","_super","_this","createRef","ev","v","increment","shiftKey","which","up","_isAdjustingSaturation","down","left","s","right","_updateColor","color","_disposables","push","window","_onMouseMove","_disposeListeners","_root","current","newColor","_getNewColor","state","forEach","Object","ColorRectangleBase","prevProps","prevState","setState","minSize","theme","className","styles","ariaValueFormat","ariaLabel","ariaDescription","classNames","valueText","replace","String","ref","tabIndex","root","style","backgroundColor","onMouseDown","_onMouseDown","onKeyDown","_onKeyDown","role","_descriptionId","description","id","light","dark","thumb","top","str","oldColor","onChange","defaultPrevented","preventDefault","Component","prevColor","rectSize","getBoundingClientRect","sPercentage","clientX","width","vPercentage","clientY","height","Math","round"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\ColorPicker\\src\\components\\ColorPicker\\ColorRectangle\\ColorRectangle.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, on, initializeComponentRef, KeyCodes, getId } from '../../../Utilities';\nimport {\n  IColorRectangleProps,\n  IColorRectangleStyleProps,\n  IColorRectangleStyles,\n  IColorRectangle,\n} from './ColorRectangle.types';\n\n// These imports are separated to help with bundling\nimport { IColor } from '../../../utilities/color/interfaces';\nimport { MAX_COLOR_SATURATION, MAX_COLOR_VALUE } from '../../../utilities/color/consts';\nimport { getFullColorString } from '../../../utilities/color/getFullColorString';\nimport { updateSV } from '../../../utilities/color/updateSV';\nimport { clamp } from '../../../utilities/color/clamp';\n\nconst getClassNames = classNamesFunction<IColorRectangleStyleProps, IColorRectangleStyles>();\n\nexport interface IColorRectangleState {\n  color: IColor;\n}\n\n/**\n * {@docCategory ColorPicker}\n */\nexport class ColorRectangleBase extends React.Component<IColorRectangleProps, IColorRectangleState>\n  implements IColorRectangle {\n  public static defaultProps: Partial<IColorRectangleProps> = {\n    minSize: 220,\n    ariaLabel: 'Saturation and brightness',\n    ariaValueFormat: 'Saturation {0} brightness {1}',\n    ariaDescription: 'Use left and right arrow keys to set saturation. Use up and down arrow keys to set brightness.',\n  };\n\n  private _disposables: (() => void)[] = [];\n  private _root = React.createRef<HTMLDivElement>();\n  private _isAdjustingSaturation: boolean = true;\n  private _descriptionId = getId('ColorRectangle-description');\n\n  constructor(props: IColorRectangleProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = { color: props.color };\n  }\n\n  public get color(): IColor {\n    return this.state.color;\n  }\n\n  public componentDidUpdate(\n    prevProps: Readonly<IColorRectangleProps>,\n    prevState: Readonly<IColorRectangleState>,\n  ): void {\n    // if props changed (as opposed to a state update), set the value\n    // TODO: switch to strict controlled pattern instead\n    if (prevProps !== this.props && this.props.color) {\n      this.setState({ color: this.props.color });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._disposeListeners();\n  }\n\n  public render(): JSX.Element {\n    const { minSize, theme, className, styles, ariaValueFormat, ariaLabel, ariaDescription } = this.props;\n    const { color } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      minSize,\n    });\n\n    const valueText = ariaValueFormat!.replace('{0}', String(color.s)).replace('{1}', String(color.v));\n\n    return (\n      <div\n        ref={this._root}\n        tabIndex={0}\n        className={classNames.root}\n        style={{ backgroundColor: getFullColorString(color) }}\n        onMouseDown={this._onMouseDown}\n        onKeyDown={this._onKeyDown}\n        role=\"slider\"\n        // Proper description of the current hue *and* saturation\n        // (screen reader typically chooses this over aria-valuenow)\n        aria-valuetext={valueText}\n        // Narrator reads aria-valuetext first, but it also reads aria-valuenow after a pause, and\n        // per the aria spec this defaults to halfway between min/max (50) if we don't provide it.\n        // So provide the value of the most recently adjusted thing.\n        aria-valuenow={this._isAdjustingSaturation ? color.s : color.v}\n        aria-valuemin={0}\n        aria-valuemax={MAX_COLOR_VALUE}\n        aria-label={ariaLabel}\n        aria-describedby={this._descriptionId}\n        data-is-focusable={true}\n      >\n        <div className={classNames.description} id={this._descriptionId}>\n          {ariaDescription}\n        </div>\n        <div className={classNames.light} />\n        <div className={classNames.dark} />\n        <div\n          className={classNames.thumb}\n          style={{ left: color!.s + '%', top: MAX_COLOR_VALUE - color!.v + '%', backgroundColor: color!.str }}\n        />\n      </div>\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    const { color } = this.state;\n    let { s, v } = color;\n\n    const increment = ev.shiftKey ? 10 : 1;\n\n    // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n    // and getting all the math and styles flipped correctly is tricky\n    switch (ev.which) {\n      case KeyCodes.up: {\n        this._isAdjustingSaturation = false;\n        v += increment; // V = 100 (lightest) is at the top\n        break;\n      }\n      case KeyCodes.down: {\n        this._isAdjustingSaturation = false;\n        v -= increment; // V = 0 (darkest) is at the bottom\n        break;\n      }\n      case KeyCodes.left: {\n        this._isAdjustingSaturation = true;\n        s -= increment;\n        break;\n      }\n      case KeyCodes.right: {\n        this._isAdjustingSaturation = true;\n        s += increment;\n        break;\n      }\n      default:\n        return;\n    }\n\n    this._updateColor(ev, updateSV(color, clamp(s, MAX_COLOR_SATURATION), clamp(v, MAX_COLOR_VALUE)));\n  };\n\n  private _updateColor(ev: MouseEvent | KeyboardEvent | React.MouseEvent | React.KeyboardEvent, color: IColor): void {\n    const { onChange } = this.props;\n\n    const oldColor = this.state.color;\n    if (color.s === oldColor.s && color.v === oldColor.v) {\n      return; // no change\n    }\n\n    if (onChange) {\n      onChange(ev as React.MouseEvent | React.KeyboardEvent, color);\n    }\n\n    if (!ev.defaultPrevented) {\n      this.setState({ color });\n      ev.preventDefault();\n    }\n  }\n\n  private _onMouseDown = (ev: React.MouseEvent): void => {\n    this._disposables.push(\n      on(window, 'mousemove', this._onMouseMove as (ev: MouseEvent) => void, true),\n      on(window, 'mouseup', this._disposeListeners, true),\n    );\n\n    this._onMouseMove(ev);\n  };\n\n  private _onMouseMove = (ev: MouseEvent | React.MouseEvent): void => {\n    if (!this._root.current) {\n      return;\n    }\n\n    // Leaving the following commented code which is sometimes necessary for debugging:\n    // If the primary button (1) isn't pressed, the user is no longer dragging, so turn off\n    // the event handlers and exit.\n    // if (!(ev.buttons & 1)) {\n    //   this._disposeListeners();\n    //   return;\n    // }\n\n    const newColor = _getNewColor(ev, this.state.color, this._root.current);\n    if (newColor) {\n      this._updateColor(ev, newColor);\n    }\n  };\n\n  private _disposeListeners = (): void => {\n    this._disposables.forEach(dispose => dispose());\n    this._disposables = [];\n  };\n}\n\n/**\n * Exported for testing only.\n * @internal\n */\nexport function _getNewColor(\n  ev: MouseEvent | React.MouseEvent,\n  prevColor: IColor,\n  root: HTMLElement,\n): IColor | undefined {\n  const rectSize = root.getBoundingClientRect();\n\n  const sPercentage = (ev.clientX - rectSize.left) / rectSize.width;\n  const vPercentage = (ev.clientY - rectSize.top) / rectSize.height;\n\n  return updateSV(\n    prevColor,\n    clamp(Math.round(sPercentage * MAX_COLOR_SATURATION), MAX_COLOR_SATURATION),\n    clamp(Math.round(MAX_COLOR_VALUE - vPercentage * MAX_COLOR_VALUE), MAX_COLOR_VALUE),\n  );\n}\n"]},"metadata":{},"sourceType":"module"}