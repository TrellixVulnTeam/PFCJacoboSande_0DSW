{"ast":null,"code":"import { getDocument } from '@uifabric/utilities';\nimport * as React from 'react';\nimport { useWindow } from '@fluentui/react-window-provider';\n/**\n * Hook to calculate and cache the target element specified by the given target attribute,\n * as well as the target element's (or host element's) parent window\n * @param target- Target selector passed to the component as a property, describing the element that\n * the callout should target\n * @param hostElement- The callout's host element, used for determining the parent window.\n */\n\nexport function useTarget(target, hostElement) {\n  var _a;\n\n  var previousTargetProp = React.useRef();\n  var targetRef = React.useRef(null);\n  /**\n   * Stores an instance of Window, used to check\n   * for server side rendering and if focus was lost.\n   */\n\n  var targetWindow = useWindow(); // If the target element changed, find the new one. If we are tracking\n  // target with class name, always find element because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n\n  if (!target || target !== previousTargetProp.current || typeof target === 'string') {\n    var currentElement = (_a = hostElement) === null || _a === void 0 ? void 0 : _a.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;\n      } else if ('stopPropagation' in target) {\n        targetRef.current = target;\n      } else if ('getBoundingClientRect' in target) {\n        targetRef.current = target;\n      } else if ('current' in target) {\n        targetRef.current = target.current;\n      } else {\n        targetRef.current = target;\n      }\n    }\n\n    previousTargetProp.current = target;\n  }\n\n  return [targetRef, targetWindow];\n}","map":{"version":3,"mappings":"AAAA,SAASA,WAAT,QAA8C,qBAA9C;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,SAAT,QAA0B,iCAA1B;AAIA;;;;;;;;AAOA,OAAM,SAAUC,SAAV,CACJC,MADI,EAEJC,WAFI,EAE0C;;;AAE9C,MAAMC,kBAAkB,GAAGL,KAAK,CAACM,MAAN,EAA3B;AAIA,MAAMC,SAAS,GAAGP,KAAK,CAACM,MAAN,CAA8D,IAA9D,CAAlB;AACA;;;;;AAIA,MAAME,YAAY,GAAGP,SAAS,EAA9B,CAX8C,CAa9C;AACA;AACA;;AACA,MAAI,CAACE,MAAD,IAAWA,MAAM,KAAKE,kBAAkB,CAACI,OAAzC,IAAoD,OAAON,MAAP,KAAkB,QAA1E,EAAoF;AAClF,QAAMO,cAAc,SAAGN,WAAH,MAAc,IAAd,IAAcO,aAAd,GAAc,MAAd,GAAcA,GAAEF,OAApC;;AACA,QAAIN,MAAJ,EAAY;AACV,UAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,YAAMS,UAAU,GAAab,WAAW,CAACW,cAAD,CAAxC;AACAH,iBAAS,CAACE,OAAV,GAAoBG,UAAU,GAAGA,UAAU,CAACC,aAAX,CAAyBV,MAAzB,CAAH,GAAsC,IAApE;AACD,OAHD,MAGO,IAAI,qBAAqBA,MAAzB,EAAiC;AACtCI,iBAAS,CAACE,OAAV,GAAoBN,MAApB;AACD,OAFM,MAEA,IAAI,2BAA2BA,MAA/B,EAAuC;AAC5CI,iBAAS,CAACE,OAAV,GAAoBN,MAApB;AACD,OAFM,MAEA,IAAI,aAAaA,MAAjB,EAAyB;AAC9BI,iBAAS,CAACE,OAAV,GAAoBN,MAAM,CAACM,OAA3B;AACD,OAFM,MAEA;AACLF,iBAAS,CAACE,OAAV,GAAoBN,MAApB;AACD;AACF;;AACDE,sBAAkB,CAACI,OAAnB,GAA6BN,MAA7B;AACD;;AAED,SAAO,CAACI,SAAD,EAAYC,YAAZ,CAAP;AACD","names":["getDocument","React","useWindow","useTarget","target","hostElement","previousTargetProp","useRef","targetRef","targetWindow","current","currentElement","_a","currentDoc","querySelector"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\react-hooks\\src\\useTarget.ts"],"sourcesContent":["import { getDocument, Point, Rectangle } from '@uifabric/utilities';\nimport * as React from 'react';\nimport { useWindow } from '@fluentui/react-window-provider';\n\nexport type Target = Element | string | MouseEvent | Point | Rectangle | null | React.RefObject<Element>;\n\n/**\n * Hook to calculate and cache the target element specified by the given target attribute,\n * as well as the target element's (or host element's) parent window\n * @param target- Target selector passed to the component as a property, describing the element that\n * the callout should target\n * @param hostElement- The callout's host element, used for determining the parent window.\n */\nexport function useTarget<TElement extends HTMLElement = HTMLElement>(\n  target: Target | undefined,\n  hostElement?: React.RefObject<TElement | null>,\n): Readonly<[React.RefObject<Element | MouseEvent | Point | Rectangle | null>, Window | undefined]> {\n  const previousTargetProp = React.useRef<\n    Element | string | MouseEvent | Point | Rectangle | React.RefObject<Element> | null | undefined\n  >();\n\n  const targetRef = React.useRef<Element | MouseEvent | Point | Rectangle | null>(null);\n  /**\n   * Stores an instance of Window, used to check\n   * for server side rendering and if focus was lost.\n   */\n  const targetWindow = useWindow();\n\n  // If the target element changed, find the new one. If we are tracking\n  // target with class name, always find element because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n  if (!target || target !== previousTargetProp.current || typeof target === 'string') {\n    const currentElement = hostElement?.current;\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;\n      } else if ('stopPropagation' in target) {\n        targetRef.current = target;\n      } else if ('getBoundingClientRect' in target) {\n        targetRef.current = target;\n      } else if ('current' in target) {\n        targetRef.current = target.current;\n      } else {\n        targetRef.current = target;\n      }\n    }\n    previousTargetProp.current = target;\n  }\n\n  return [targetRef, targetWindow] as const;\n}\n"]},"metadata":{},"sourceType":"module"}