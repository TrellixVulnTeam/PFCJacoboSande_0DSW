{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nvar eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\nvar DraggableZone =\n/** @class */\nfunction (_super) {\n  __extends(DraggableZone, _super);\n\n  function DraggableZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._currentEventType = eventMapping.mouse;\n    _this._events = [];\n\n    _this._onMouseDown = function (event) {\n      var onMouseDown = React.Children.only(_this.props.children).props.onMouseDown;\n\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStart(event);\n    };\n\n    _this._onMouseUp = function (event) {\n      var onMouseUp = React.Children.only(_this.props.children).props.onMouseUp;\n\n      if (onMouseUp) {\n        onMouseUp(event);\n      }\n\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStop(event);\n    };\n\n    _this._onTouchStart = function (event) {\n      var onTouchStart = React.Children.only(_this.props.children).props.onTouchStart;\n\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n\n      _this._currentEventType = eventMapping.touch;\n      return _this._onDragStart(event);\n    };\n\n    _this._onTouchEnd = function (event) {\n      var onTouchEnd = React.Children.only(_this.props.children).props.onTouchEnd;\n\n      if (onTouchEnd) {\n        onTouchEnd(event);\n      }\n\n      _this._currentEventType = eventMapping.touch;\n\n      _this._onDragStop(event);\n    };\n\n    _this._onDragStart = function (event) {\n      // Only handle left click for dragging\n      if (typeof event.button === 'number' && event.button !== 0) {\n        return false;\n      } // If the target doesn't match the handleSelector OR\n      // if the target does match the preventDragSelector, bail out\n\n\n      if (_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector) || _this.props.preventDragSelector && _this._matchesSelector(event.target, _this.props.preventDragSelector)) {\n        return;\n      } // Remember the touch identifier if this is a touch event so we can\n      // distinguish between individual touches in multitouch scenarios\n      // by remembering which touch point we were given\n\n\n      _this._touchId = _this._getTouchId(event);\n\n      var position = _this._getControlPosition(event);\n\n      if (position === undefined) {\n        return;\n      }\n\n      var dragData = _this._createDragDataFromPosition(position);\n\n      _this.props.onStart && _this.props.onStart(event, dragData);\n\n      _this.setState({\n        isDragging: true,\n        lastPosition: position\n      }); // hook up the appropriate mouse/touch events to the body to ensure\n      // smooth dragging\n\n\n      _this._events = [on(document.body, _this._currentEventType.move, _this._onDrag, true\n      /* use capture phase */\n      ), on(document.body, _this._currentEventType.stop, _this._onDragStop, true\n      /* use capture phase */\n      )];\n    };\n\n    _this._onDrag = function (event) {\n      // Prevent scrolling on mobile devices\n      if (event.type === 'touchmove') {\n        event.preventDefault();\n      }\n\n      var position = _this._getControlPosition(event);\n\n      if (!position) {\n        return;\n      } // create the updated drag data from the position data\n\n\n      var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position));\n\n      var updatedPosition = updatedData.position;\n      _this.props.onDragChange && _this.props.onDragChange(event, updatedData);\n\n      _this.setState({\n        position: updatedPosition,\n        lastPosition: position\n      });\n    };\n\n    _this._onDragStop = function (event) {\n      if (!_this.state.isDragging) {\n        return;\n      }\n\n      var position = _this._getControlPosition(event);\n\n      if (!position) {\n        return;\n      }\n\n      var baseDragData = _this._createDragDataFromPosition(position); // Set dragging to false and reset the lastPosition\n\n\n      _this.setState({\n        isDragging: false,\n        lastPosition: undefined\n      });\n\n      _this.props.onStop && _this.props.onStop(event, baseDragData);\n\n      if (_this.props.position) {\n        _this.setState({\n          position: _this.props.position\n        });\n      } // Remove event handlers\n\n\n      _this._events.forEach(function (dispose) {\n        return dispose();\n      });\n    };\n\n    _this.state = {\n      isDragging: false,\n      position: _this.props.position || {\n        x: 0,\n        y: 0\n      },\n      lastPosition: undefined\n    };\n    return _this;\n  }\n\n  DraggableZone.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({\n        position: this.props.position\n      });\n    }\n  };\n\n  DraggableZone.prototype.componentWillUnmount = function () {\n    this._events.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n\n  DraggableZone.prototype.render = function () {\n    var child = React.Children.only(this.props.children);\n    var props = child.props;\n    var position = this.props.position;\n    var _a = this.state,\n        statePosition = _a.position,\n        isDragging = _a.isDragging;\n    var x = statePosition.x;\n    var y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: __assign(__assign({}, props.style), {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }),\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd\n    });\n  };\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n\n\n  DraggableZone.prototype._getControlPosition = function (event) {\n    var touchObj = this._getActiveTouch(event); // did we get the right touch?\n\n\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    var eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY\n    };\n  };\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n\n\n  DraggableZone.prototype._getActiveTouch = function (event) {\n    return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);\n  };\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n\n\n  DraggableZone.prototype._getTouchId = function (event) {\n    var touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];\n\n    if (touch) {\n      return touch.identifier;\n    }\n  };\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n\n\n  DraggableZone.prototype._matchesSelector = function (element, selector) {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    var matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector\n    /* for IE */\n    ;\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  };\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n\n\n  DraggableZone.prototype._findTouchInTouchList = function (touchList) {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (var i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n\n\n  DraggableZone.prototype._createDragDataFromPosition = function (position) {\n    var lastPosition = this.state.lastPosition; // If we have no lastPosition, use the given position\n    // for last position\n\n    if (lastPosition === undefined) {\n      return {\n        delta: {\n          x: 0,\n          y: 0\n        },\n        lastPosition: position,\n        position: position\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y\n      },\n      lastPosition: lastPosition,\n      position: position\n    };\n  };\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n\n\n  DraggableZone.prototype._createUpdatedDragData = function (baseDragData) {\n    var position = this.state.position;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y\n      },\n      delta: baseDragData.delta,\n      lastPosition: position\n    };\n  };\n\n  return DraggableZone;\n}(React.Component);\n\nexport { DraggableZone };","map":{"version":3,"mappings":"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","names":["React","getClassNames","on","eventMapping","touch","start","move","stop","mouse","__extends","props","_super","_this","event","onMouseDown","Children","only","children","_currentEventType","_onDragStart","onMouseUp","_onDragStop","onTouchStart","onTouchEnd","button","handleSelector","_matchesSelector","target","preventDragSelector","_touchId","_getTouchId","position","_getControlPosition","undefined","dragData","_createDragDataFromPosition","onStart","setState","isDragging","lastPosition","_events","document","body","_onDrag","type","preventDefault","updatedData","_createUpdatedDragData","updatedPosition","onDragChange","state","baseDragData","onStop","forEach","x","y","DraggableZone","prevProps","child","statePosition","cloneElement","style","transform","className","root","_onMouseDown","_onMouseUp","_onTouchStart","_onTouchEnd","touchObj","_getActiveTouch","eventToGetOffset","clientX","clientY","targetTouches","_findTouchInTouchList","changedTouches","identifier","element","selector","matchesSelectorFn","matches","webkitMatchesSelector","msMatchesSelector","call","parentElement","touchList","i","length","delta","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\utilities\\src\\utilities\\DraggableZone\\DraggableZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport { IDraggableZoneProps, ICoordinates, IDragData } from './DraggableZone.types';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\n\nexport interface IDraggableZoneState {\n  isDragging: boolean;\n  position: ICoordinates;\n  lastPosition?: ICoordinates;\n}\n\nconst eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend',\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup',\n  },\n};\n\n// These are needed so that we can generalize the events\n// and so we have access to clientX and clientY in the touch events\ntype MouseTouchEvent<T> = React.MouseEvent<T> & React.TouchEvent<T> & Event;\n\nexport class DraggableZone extends React.Component<IDraggableZoneProps, IDraggableZoneState> {\n  private _touchId?: number;\n  private _currentEventType = eventMapping.mouse;\n  private _events: (() => void)[] = [];\n\n  constructor(props: IDraggableZoneProps) {\n    super(props);\n\n    this.state = {\n      isDragging: false,\n      position: this.props.position || { x: 0, y: 0 },\n      lastPosition: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDraggableZoneProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({ position: this.props.position });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.forEach(dispose => dispose());\n  }\n\n  public render() {\n    const child: any = React.Children.only(this.props.children);\n    const { props } = child;\n    const { position } = this.props;\n    const { position: statePosition, isDragging } = this.state;\n    let x = statePosition.x;\n    let y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: {\n        ...props.style,\n        transform: `translate(${x}px, ${y}px)`,\n      },\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd,\n    });\n  }\n\n  private _onMouseDown = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseDown = (React.Children.only(this.props.children) as any).props.onMouseDown;\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStart(event);\n  };\n\n  private _onMouseUp = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseUp = (React.Children.only(this.props.children) as any).props.onMouseUp;\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStop(event);\n  };\n\n  private _onTouchStart = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchStart = (React.Children.only(this.props.children) as any).props.onTouchStart;\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    return this._onDragStart(event);\n  };\n\n  private _onTouchEnd = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchEnd = (React.Children.only(this.props.children) as any).props.onTouchEnd;\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    this._onDragStop(event);\n  };\n\n  private _onDragStart = (event: MouseTouchEvent<HTMLElement>) => {\n    // Only handle left click for dragging\n    if (typeof event.button === 'number' && event.button !== 0) {\n      return false;\n    }\n\n    // If the target doesn't match the handleSelector OR\n    // if the target does match the preventDragSelector, bail out\n    if (\n      (this.props.handleSelector && !this._matchesSelector(event.target as HTMLElement, this.props.handleSelector)) ||\n      (this.props.preventDragSelector &&\n        this._matchesSelector(event.target as HTMLElement, this.props.preventDragSelector))\n    ) {\n      return;\n    }\n\n    // Remember the touch identifier if this is a touch event so we can\n    // distinguish between individual touches in multitouch scenarios\n    // by remembering which touch point we were given\n    this._touchId = this._getTouchId(event);\n\n    const position = this._getControlPosition(event);\n    if (position === undefined) {\n      return;\n    }\n\n    const dragData = this._createDragDataFromPosition(position);\n    this.props.onStart && this.props.onStart(event, dragData);\n\n    this.setState({\n      isDragging: true,\n      lastPosition: position,\n    });\n\n    // hook up the appropriate mouse/touch events to the body to ensure\n    // smooth dragging\n    this._events = [\n      on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */),\n      on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */),\n    ];\n  };\n\n  private _onDrag = (event: MouseTouchEvent<HTMLElement>) => {\n    // Prevent scrolling on mobile devices\n    if (event.type === 'touchmove') {\n      event.preventDefault();\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    // create the updated drag data from the position data\n    const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));\n    const updatedPosition = updatedData.position;\n\n    this.props.onDragChange && this.props.onDragChange(event, updatedData);\n\n    this.setState({\n      position: updatedPosition,\n      lastPosition: position,\n    });\n  };\n\n  private _onDragStop = (event: MouseTouchEvent<HTMLElement>) => {\n    if (!this.state.isDragging) {\n      return;\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    const baseDragData = this._createDragDataFromPosition(position);\n\n    // Set dragging to false and reset the lastPosition\n    this.setState({\n      isDragging: false,\n      lastPosition: undefined,\n    });\n\n    this.props.onStop && this.props.onStop(event, baseDragData);\n\n    if (this.props.position) {\n      this.setState({\n        position: this.props.position,\n      });\n    }\n\n    // Remove event handlers\n    this._events.forEach(dispose => dispose());\n  };\n\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  private _getControlPosition(event: MouseTouchEvent<HTMLElement>): ICoordinates | undefined {\n    const touchObj = this._getActiveTouch(event);\n\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    const eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY,\n    };\n  }\n\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  private _getActiveTouch(event: MouseTouchEvent<HTMLElement>): React.Touch | undefined {\n    return (\n      (event.targetTouches && this._findTouchInTouchList(event.targetTouches)) ||\n      (event.changedTouches && this._findTouchInTouchList(event.changedTouches))\n    );\n  }\n\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  private _getTouchId(event: MouseTouchEvent<HTMLElement>): number | undefined {\n    const touch: React.Touch | undefined =\n      (event.targetTouches && event.targetTouches[0]) || (event.changedTouches && event.changedTouches[0]);\n\n    if (touch) {\n      return touch.identifier;\n    }\n  }\n\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  private _matchesSelector(element: HTMLElement | null, selector: string): boolean {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    const matchesSelectorFn: Function =\n        element.matches || element.webkitMatchesSelector || (element as any).msMatchesSelector /* for IE */;\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  }\n\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  private _findTouchInTouchList(touchList: React.TouchList): React.Touch | undefined {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  private _createDragDataFromPosition(position: ICoordinates): IDragData {\n    const { lastPosition } = this.state;\n\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: { x: 0, y: 0 },\n        lastPosition: position,\n        position,\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y,\n      },\n      lastPosition,\n      position,\n    };\n  }\n\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  private _createUpdatedDragData(baseDragData: IDragData): IDragData {\n    const { position } = this.state;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y,\n      },\n      delta: baseDragData.delta,\n      lastPosition: position,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}