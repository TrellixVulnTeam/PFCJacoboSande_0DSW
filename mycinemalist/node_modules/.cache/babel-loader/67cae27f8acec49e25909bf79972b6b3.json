{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, getDocument, focusAsync, initializeComponentRef, on } from '../../Utilities';\n\nvar FocusTrapZone =\n/** @class */\nfunction (_super) {\n  __extends(FocusTrapZone, _super);\n\n  function FocusTrapZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._firstBumper = React.createRef();\n    _this._lastBumper = React.createRef();\n    _this._hasFocus = false;\n\n    _this._onRootFocus = function (ev) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n\n      _this._hasFocus = true;\n    };\n\n    _this._onRootBlur = function (ev) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n\n      var relatedTarget = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = _this._getDocument().activeElement;\n      }\n\n      if (!elementContains(_this._root.current, relatedTarget)) {\n        _this._hasFocus = false;\n      }\n    };\n\n    _this._onFirstBumperFocus = function () {\n      _this._onBumperFocus(true);\n    };\n\n    _this._onLastBumperFocus = function () {\n      _this._onBumperFocus(false);\n    };\n\n    _this._onBumperFocus = function (isFirstBumper) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;\n\n      if (_this._root.current) {\n        var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (_this._isBumper(nextFocusable)) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            _this.focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    };\n\n    _this._onFocusCapture = function (ev) {\n      if (_this.props.onFocusCapture) {\n        _this.props.onFocusCapture(ev);\n      }\n\n      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n\n    _this._forceFocusInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var focusedElement = _this._getDocument().activeElement;\n\n        if (!elementContains(_this._root.current, focusedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    _this._forceClickInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var clickedElement = ev.target;\n\n        if (clickedElement && !elementContains(_this._root.current, clickedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    return _this;\n  }\n\n  FocusTrapZone.prototype.componentDidMount = function () {\n    this._bringFocusIntoZone();\n\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  };\n\n  FocusTrapZone.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;\n\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  };\n\n  FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    var newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  };\n\n  FocusTrapZone.prototype.componentWillUnmount = function () {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (!this.props.disabled || this.props.forceFocusInsideTrap || !elementContains(this._root.current, this._getDocument().activeElement)) {\n      this._returnFocusToInitiator();\n    } // Dispose of event handlers so their closures can be garbage-collected\n\n\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  };\n\n  FocusTrapZone.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        ariaLabelledBy = _a.ariaLabelledBy;\n    var divProps = getNativeProps(this.props, divProperties);\n    var bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed'\n      },\n      tabIndex: disabled ? -1 : 0,\n      'data-is-visible': true\n    };\n    return React.createElement(\"div\", __assign({}, divProps, {\n      className: className,\n      ref: this._root,\n      \"aria-labelledby\": ariaLabelledBy,\n      onFocusCapture: this._onFocusCapture,\n      onFocus: this._onRootFocus,\n      onBlur: this._onRootBlur\n    }), React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._firstBumper,\n      onFocus: this._onFirstBumperFocus\n    })), this.props.children, React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._lastBumper,\n      onFocus: this._onLastBumperFocus\n    })));\n  };\n\n  FocusTrapZone.prototype.focus = function () {\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n        focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement,\n        firstFocusableSelector = _a.firstFocusableSelector,\n        firstFocusableTarget = _a.firstFocusableTarget;\n\n    if (focusPreviouslyFocusedInnerElement && this._previouslyFocusedElementInTrapZone && elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var _firstFocusableChild = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  };\n\n  FocusTrapZone.prototype._focusAsync = function (element) {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  };\n\n  FocusTrapZone.prototype._bringFocusIntoZone = function () {\n    var _a = this.props,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        _c = _a.disableFirstFocus,\n        disableFirstFocus = _c === void 0 ? false : _c;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : this._getDocument().activeElement;\n\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  };\n\n  FocusTrapZone.prototype._returnFocusToInitiator = function () {\n    var _this = this;\n\n    var ignoreExternalFocusing = this.props.ignoreExternalFocusing;\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n      return _this !== value;\n    });\n\n    var doc = this._getDocument();\n\n    var activeElement = doc.activeElement;\n\n    if (!ignoreExternalFocusing && this._previouslyFocusedElementOutsideTrapZone && typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(this._root.current, activeElement) || activeElement === doc.body)) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  };\n\n  FocusTrapZone.prototype._updateEventHandlers = function (newProps) {\n    var _a = newProps.isClickableOutsideFocusTrap,\n        isClickableOutsideFocusTrap = _a === void 0 ? false : _a,\n        _b = newProps.forceFocusInsideTrap,\n        forceFocusInsideTrap = _b === void 0 ? true : _b;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n  };\n\n  FocusTrapZone.prototype._isBumper = function (element) {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  };\n\n  FocusTrapZone.prototype._getDocument = function () {\n    return getDocument(this._root.current);\n  };\n\n  FocusTrapZone._focusStack = [];\n  return FocusTrapZone;\n}(React.Component);\n\nexport { FocusTrapZone };","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SACEC,eADF,EAEEC,cAFF,EAGEC,aAHF,EAIEC,gBAJF,EAKEC,eALF,EAMEC,cANF,EAOEC,WAPF,EAQEC,UARF,EASEC,sBATF,EAUEC,EAVF,QAWO,iBAXP;;AAcA;AAAA;AAAA;EAAmCC;;EAcjC,uBAAmBC,KAAnB,EAA6C;IAA7C,YACEC,kBAAMD,KAAN,KAAY,IADd;;IAXQE,cAAQf,KAAK,CAACgB,SAAN,EAAR;IACAD,qBAAef,KAAK,CAACgB,SAAN,EAAf;IACAD,oBAAcf,KAAK,CAACgB,SAAN,EAAd;IACAD,kBAAqB,KAArB;;IA0KAA,qBAAe,UAACE,EAAD,EAAqC;MAC1D,IAAIF,KAAI,CAACF,KAAL,CAAWK,OAAf,EAAwB;QACtBH,KAAI,CAACF,KAAL,CAAWK,OAAX,CAAmBD,EAAnB;MACD;;MAEDF,KAAI,CAACI,SAAL,GAAiB,IAAjB;IACD,CANO;;IAQAJ,oBAAc,UAACE,EAAD,EAAqC;MACzD,IAAIF,KAAI,CAACF,KAAL,CAAWO,MAAf,EAAuB;QACrBL,KAAI,CAACF,KAAL,CAAWO,MAAX,CAAkBH,EAAlB;MACD;;MAED,IAAII,aAAa,GAAGJ,EAAE,CAACI,aAAvB;;MACA,IAAIJ,EAAE,CAACI,aAAH,KAAqB,IAAzB,EAA+B;QAC7B;QACA;QACA;QACA;QACA;QACAA,aAAa,GAAGN,KAAI,CAACO,YAAL,GAAoBC,aAApC;MACD;;MAED,IAAI,CAACrB,eAAe,CAACa,KAAI,CAACS,KAAL,CAAWC,OAAZ,EAAqBJ,aAArB,CAApB,EAAwE;QACtEN,KAAI,CAACI,SAAL,GAAiB,KAAjB;MACD;IACF,CAlBO;;IAoBAJ,4BAAsB;MAC5BA,KAAI,CAACW,cAAL,CAAoB,IAApB;IACD,CAFO;;IAIAX,2BAAqB;MAC3BA,KAAI,CAACW,cAAL,CAAoB,KAApB;IACD,CAFO;;IAIAX,uBAAiB,UAACY,aAAD,EAAuB;MAC9C,IAAIZ,KAAI,CAACF,KAAL,CAAWe,QAAf,EAAyB;QACvB;MACD;;MAED,IAAMC,aAAa,GAAIF,aAAa,KAAKZ,KAAI,CAACI,SAAvB,GACnBJ,KAAI,CAACe,WAAL,CAAiBL,OADE,GAEnBV,KAAI,CAACgB,YAAL,CAAkBN,OAFtB;;MAIA,IAAIV,KAAI,CAACS,KAAL,CAAWC,OAAf,EAAwB;QACtB,IAAMO,aAAa,GACjBL,aAAa,KAAKZ,KAAI,CAACI,SAAvB,GACIb,eAAe,CAACS,KAAI,CAACS,KAAL,CAAWC,OAAZ,EAAqBI,aAArB,EAAoC,IAApC,EAA0C,KAA1C,CADnB,GAEIxB,gBAAgB,CAACU,KAAI,CAACS,KAAL,CAAWC,OAAZ,EAAqBI,aAArB,EAAoC,IAApC,EAA0C,KAA1C,CAHtB;;QAKA,IAAIG,aAAJ,EAAmB;UACjB,IAAIjB,KAAI,CAACkB,SAAL,CAAeD,aAAf,CAAJ,EAAmC;YACjC;YACA;YACAjB,KAAI,CAACmB,KAAL;UACD,CAJD,MAIO;YACLF,aAAa,CAACE,KAAd;UACD;QACF;MACF;IACF,CAzBO;;IAiFAnB,wBAAkB,UAACE,EAAD,EAAqC;MAC7D,IAAIF,KAAI,CAACF,KAAL,CAAWsB,cAAf,EAA+B;QAC7BpB,KAAI,CAACF,KAAL,CAAWsB,cAAX,CAA0BlB,EAA1B;MACD;;MAED,IAAIA,EAAE,CAACmB,MAAH,KAAcnB,EAAE,CAACoB,aAAjB,IAAkC,CAACtB,KAAI,CAACkB,SAAL,CAAehB,EAAE,CAACmB,MAAlB,CAAvC,EAAkE;QAChE;QACA;QACArB,KAAI,CAACuB,mCAAL,GAA2CrB,EAAE,CAACmB,MAA9C;MACD;IACF,CAVO;;IAgBArB,0BAAoB,UAACE,EAAD,EAAe;MACzC,IAAIF,KAAI,CAACF,KAAL,CAAWe,QAAf,EAAyB;QACvB;MACD;;MAED,IAAIW,aAAa,CAACC,WAAd,CAA0BC,MAA1B,IAAoC1B,KAAI,KAAKwB,aAAa,CAACC,WAAd,CAA0BD,aAAa,CAACC,WAAd,CAA0BC,MAA1B,GAAmC,CAA7D,CAAjD,EAAkH;QAChH,IAAMC,cAAc,GAAG3B,KAAI,CAACO,YAAL,GAAoBC,aAA3C;;QAEA,IAAI,CAACrB,eAAe,CAACa,KAAI,CAACS,KAAL,CAAWC,OAAZ,EAAqBiB,cAArB,CAApB,EAA0D;UACxD3B,KAAI,CAACmB,KAAL;;UACAnB,KAAI,CAACI,SAAL,GAAiB,IAAjB,CAFwD,CAEjC;;UACvBF,EAAE,CAAC0B,cAAH;UACA1B,EAAE,CAAC2B,eAAH;QACD;MACF;IACF,CAfO;;IAiBA7B,0BAAoB,UAACE,EAAD,EAAe;MACzC,IAAIF,KAAI,CAACF,KAAL,CAAWe,QAAf,EAAyB;QACvB;MACD;;MAED,IAAIW,aAAa,CAACC,WAAd,CAA0BC,MAA1B,IAAoC1B,KAAI,KAAKwB,aAAa,CAACC,WAAd,CAA0BD,aAAa,CAACC,WAAd,CAA0BC,MAA1B,GAAmC,CAA7D,CAAjD,EAAkH;QAChH,IAAMI,cAAc,GAAG5B,EAAE,CAACmB,MAA1B;;QAEA,IAAIS,cAAc,IAAI,CAAC3C,eAAe,CAACa,KAAI,CAACS,KAAL,CAAWC,OAAZ,EAAqBoB,cAArB,CAAtC,EAA4E;UAC1E9B,KAAI,CAACmB,KAAL;;UACAnB,KAAI,CAACI,SAAL,GAAiB,IAAjB,CAF0E,CAEnD;;UACvBF,EAAE,CAAC0B,cAAH;UACA1B,EAAE,CAAC2B,eAAH;QACD;MACF;IACF,CAfO;;IAtTNlC,sBAAsB,CAACK,KAAD,CAAtB;;EACD;;EAEMwB,4CAAP;IACE,KAAKO,mBAAL;;IACA,KAAKC,oBAAL,CAA0B,KAAKlC,KAA/B;;IAEA,IAAI,CAAC,KAAKA,KAAL,CAAWe,QAAZ,IAAwB,KAAKJ,KAAL,CAAWC,OAAnC,IAA8C,KAAKZ,KAAL,CAAWmC,wBAA7D,EAAuF;MACrF,KAAKC,WAAL,GAAmBhD,QAAQ,CAAC,KAAKuB,KAAL,CAAWC,OAAZ,CAA3B;IACD;EACF,CAPM;;EASAc,2DAAP,UAAwCW,SAAxC,EAAsE;IAC5D;;IACR,IAAIC,uBAAuB,IAAI,KAAKC,wCAAL,KAAkDD,uBAAjF,EAA0G;MACxG,KAAKC,wCAAL,GAAgDD,uBAAhD;IACD;;IAED,KAAKJ,oBAAL,CAA0BG,SAA1B;EACD,CAPM;;EASAX,6CAAP,UAA0Bc,SAA1B,EAAwD;IACtD,IAAMC,wBAAwB,GAC5BD,SAAS,CAACE,oBAAV,KAAmCC,SAAnC,GAA+CH,SAAS,CAACE,oBAAzD,GAAgF,IADlF;IAEA,IAAME,uBAAuB,GAC3B,KAAK5C,KAAL,CAAW0C,oBAAX,KAAoCC,SAApC,GAAgD,KAAK3C,KAAL,CAAW0C,oBAA3D,GAAkF,IADpF;IAEA,IAAMG,YAAY,GAAGL,SAAS,CAACzB,QAAV,KAAuB4B,SAAvB,GAAmCH,SAAS,CAACzB,QAA7C,GAAwD,KAA7E;IACA,IAAM+B,WAAW,GAAG,KAAK9C,KAAL,CAAWe,QAAX,KAAwB4B,SAAxB,GAAoC,KAAK3C,KAAL,CAAWe,QAA/C,GAA0D,KAA9E;;IAEA,IAAK,CAAC0B,wBAAD,IAA6BG,uBAA9B,IAA2DC,YAAY,IAAI,CAACC,WAAhF,EAA8F;MAC5F;MACA;MACA,KAAKb,mBAAL;;MACA,IAAI,CAAC,KAAKG,WAAN,IAAqB,KAAKzB,KAAL,CAAWC,OAAhC,IAA2C,KAAKZ,KAAL,CAAWmC,wBAA1D,EAAoF;QAClF,KAAKC,WAAL,GAAmBhD,QAAQ,CAAC,KAAKuB,KAAL,CAAWC,OAAZ,CAA3B;MACD;IACF,CAPD,MAOO,IAAK6B,wBAAwB,IAAI,CAACG,uBAA9B,IAA2D,CAACC,YAAD,IAAiBC,WAAhF,EAA8F;MACnG;MACA;MACA,KAAKC,uBAAL;;MACA,IAAI,KAAKX,WAAT,EAAsB;QACpB,KAAKA,WAAL;MACD;IACF;EACF,CAvBM;;EAyBAV,+CAAP;IACE;IACA,IACE,CAAC,KAAK1B,KAAL,CAAWe,QAAZ,IACA,KAAKf,KAAL,CAAW0C,oBADX,IAEA,CAACrD,eAAe,CAAC,KAAKsB,KAAL,CAAWC,OAAZ,EAAqB,KAAKH,YAAL,GAAoBC,aAAzC,CAHlB,EAIE;MACA,KAAKqC,uBAAL;IACD,CARH,CAUE;;;IACA,IAAI,KAAKC,oBAAT,EAA+B;MAC7B,KAAKA,oBAAL;;MACA,KAAKA,oBAAL,GAA4BL,SAA5B;IACD;;IAED,IAAI,KAAKM,oBAAT,EAA+B;MAC7B,KAAKA,oBAAL;;MACA,KAAKA,oBAAL,GAA4BN,SAA5B;IACD;;IAED,IAAI,KAAKP,WAAT,EAAsB;MACpB,KAAKA,WAAL;IACD,CAvBH,CAyBE;;;IACA,OAAO,KAAKX,mCAAZ;IACA,OAAO,KAAKc,wCAAZ;EACD,CA5BM;;EA8BAb,iCAAP;IACQ;IAAA,IAAEwB,wBAAF;IAAA,IAAaC,gBAAb;IAAA,IAAapC,qCAAb;IAAA,IAA+BqC,kCAA/B;IACN,IAAMC,QAAQ,GAAG/D,cAAc,CAAuC,KAAKU,KAA5C,EAAmDT,aAAnD,CAA/B;IAEA,IAAM+D,WAAW,GAAG;MAClB,eAAe,IADG;MAElBC,KAAK,EAAE;QACLC,aAAa,EAAE,MADV;QAELC,QAAQ,EAAE;MAFL,CAFW;MAMlBC,QAAQ,EAAE3C,QAAQ,GAAG,CAAC,CAAJ,GAAQ,CANR;MAOlB,mBAAmB;IAPD,CAApB;IAUA,OACE5B,wCACMkE,QADN,EACc;MACZH,SAAS,EAAEA,SADC;MAEZS,GAAG,EAAE,KAAKhD,KAFE;MAEG,mBACEyC,cAHL;MAIZ9B,cAAc,EAAE,KAAKsC,eAJT;MAKZvD,OAAO,EAAE,KAAKwD,YALF;MAMZtD,MAAM,EAAE,KAAKuD;IAND,CADd,GASE3E,wCAASmE,WAAT,EAAoB;MAAEK,GAAG,EAAE,KAAKzC,YAAZ;MAA0Bb,OAAO,EAAE,KAAK0D;IAAxC,CAApB,EATF,EAUG,KAAK/D,KAAL,CAAWgE,QAVd,EAWE7E,wCAASmE,WAAT,EAAoB;MAAEK,GAAG,EAAE,KAAK1C,WAAZ;MAAyBZ,OAAO,EAAE,KAAK4D;IAAvC,CAApB,EAXF,CADF;EAeD,CA7BM;;EA+BAvC,gCAAP;IACE;IACM;IAAA,IAAEwC,0EAAF;IAAA,IAAsCC,kDAAtC;IAAA,IAA8DC,8CAA9D;;IAEN,IACEF,kCAAkC,IAClC,KAAKzC,mCADL,IAEApC,eAAe,CAAC,KAAKsB,KAAL,CAAWC,OAAZ,EAAqB,KAAKa,mCAA1B,CAHjB,EAIE;MACA;MACA,KAAK4C,WAAL,CAAiB,KAAK5C,mCAAtB;;MACA;IACD;;IAED,IAAM6C,aAAa,GACjB,OAAOH,sBAAP,KAAkC,QAAlC,GACIA,sBADJ,GAEIA,sBAAsB,IAAIA,sBAAsB,EAHtD;IAKA,IAAII,oBAAoB,GAAuB,IAA/C;;IAEA,IAAI,KAAK5D,KAAL,CAAWC,OAAf,EAAwB;MACtB,IAAI,OAAOwD,oBAAP,KAAgC,QAApC,EAA8C;QAC5CG,oBAAoB,GAAG,KAAK5D,KAAL,CAAWC,OAAX,CAAmB4D,aAAnB,CAAiCJ,oBAAjC,CAAvB;MACD,CAFD,MAEO,IAAIA,oBAAJ,EAA0B;QAC/BG,oBAAoB,GAAGH,oBAAoB,CAAC,KAAKzD,KAAL,CAAWC,OAAZ,CAA3C;MACD,CAFM,MAEA,IAAI0D,aAAJ,EAAmB;QACxBC,oBAAoB,GAAG,KAAK5D,KAAL,CAAWC,OAAX,CAAmB4D,aAAnB,CAAiC,MAAMF,aAAvC,CAAvB;MACD,CAPqB,CAStB;;;MACA,IAAI,CAACC,oBAAL,EAA2B;QACzBA,oBAAoB,GAAG7E,cAAc,CACnC,KAAKiB,KAAL,CAAWC,OADwB,EAEnC,KAAKD,KAAL,CAAWC,OAAX,CAAmB6D,UAFgB,EAGnC,KAHmC,EAInC,KAJmC,EAKnC,KALmC,EAMnC,IANmC,CAArC;MAQD;IACF;;IACD,IAAIF,oBAAJ,EAA0B;MACxB,KAAKF,WAAL,CAAiBE,oBAAjB;IACD;EACF,CA7CM;;EA+CC7C,sCAAR,UAAoBgD,OAApB,EAAwC;IACtC,IAAI,CAAC,KAAKtD,SAAL,CAAesD,OAAf,CAAL,EAA8B;MAC5B9E,UAAU,CAAC8E,OAAD,CAAV;IACD;EACF,CAJO;;EAqEAhD,8CAAR;IACQ;IAAA,IAAEY,oDAAF;IAAA,IAA2Ba,gBAA3B;IAAA,IAA2BpC,qCAA3B;IAAA,IAA6C4D,yBAA7C;IAAA,IAA6CC,8CAA7C;;IAEN,IAAI7D,QAAJ,EAAc;MACZ;IACD;;IAEDW,aAAa,CAACC,WAAd,CAA0BkD,IAA1B,CAA+B,IAA/B;;IAEA,KAAKtC,wCAAL,GAAgDD,uBAAuB,GACnEA,uBADmE,GAElE,KAAK7B,YAAL,GAAoBC,aAFzB;;IAGA,IAAI,CAACkE,iBAAD,IAAsB,CAACvF,eAAe,CAAC,KAAKsB,KAAL,CAAWC,OAAZ,EAAqB,KAAK2B,wCAA1B,CAA1C,EAA+G;MAC7G,KAAKlB,KAAL;IACD;EACF,CAfO;;EAiBAK,kDAAR;IAAA;;IACU;IAERA,aAAa,CAACC,WAAd,GAA4BD,aAAa,CAACC,WAAd,CAA0BmD,MAA1B,CAAiC,UAACC,KAAD,EAAqB;MAChF,OAAO7E,KAAI,KAAK6E,KAAhB;IACD,CAF2B,CAA5B;;IAIA,IAAMC,GAAG,GAAG,KAAKvE,YAAL,EAAZ;;IACA,IAAMC,aAAa,GAAGsE,GAAG,CAACtE,aAA1B;;IACA,IACE,CAACuE,sBAAD,IACA,KAAK1C,wCADL,IAEA,OAAO,KAAKA,wCAAL,CAA8ClB,KAArD,KAA+D,UAF/D,KAGChC,eAAe,CAAC,KAAKsB,KAAL,CAAWC,OAAZ,EAAqBF,aAArB,CAAf,IAAsDA,aAAa,KAAKsE,GAAG,CAACE,IAH7E,CADF,EAKE;MACA,KAAKb,WAAL,CAAiB,KAAK9B,wCAAtB;IACD;EACF,CAjBO;;EAmBAb,+CAAR,UAA6ByD,QAA7B,EAA0D;IAChD;IAAA;IAAA,IAAqChC,kCAArC;IAAA,IAAqCT,gDAArC;;IAER,IAAIA,oBAAoB,IAAI,CAAC,KAAKO,oBAAlC,EAAwD;MACtD,KAAKA,oBAAL,GAA4BnD,EAAE,CAACsF,MAAD,EAAS,OAAT,EAAkB,KAAKC,iBAAvB,EAA0C,IAA1C,CAA9B;IACD,CAFD,MAEO,IAAI,CAAC3C,oBAAD,IAAyB,KAAKO,oBAAlC,EAAwD;MAC7D,KAAKA,oBAAL;;MACA,KAAKA,oBAAL,GAA4BN,SAA5B;IACD;;IAED,IAAI,CAAC2C,2BAAD,IAAgC,CAAC,KAAKtC,oBAA1C,EAAgE;MAC9D,KAAKA,oBAAL,GAA4BlD,EAAE,CAACsF,MAAD,EAAS,OAAT,EAAkB,KAAKG,iBAAvB,EAA0C,IAA1C,CAA9B;IACD,CAFD,MAEO,IAAID,2BAA2B,IAAI,KAAKtC,oBAAxC,EAA8D;MACnE,KAAKA,oBAAL;;MACA,KAAKA,oBAAL,GAA4BL,SAA5B;IACD;EACF,CAhBO;;EA8BAjB,oCAAR,UAAkBgD,OAAlB,EAAsC;IACpC,OAAOA,OAAO,KAAK,KAAKxD,YAAL,CAAkBN,OAA9B,IAAyC8D,OAAO,KAAK,KAAKzD,WAAL,CAAiBL,OAA7E;EACD,CAFO;;EAsCAc,uCAAR;IACE,OAAO/B,WAAW,CAAC,KAAKgB,KAAL,CAAWC,OAAZ,CAAlB;EACD,CAFO;;EAtVOc,4BAA+B,EAA/B;EAyVjB;AAAC,CA1VD,CAAmCvC,KAAK,CAACqG,SAAzC;;SAAa9D","names":["React","modalize","elementContains","getNativeProps","divProperties","getFirstTabbable","getLastTabbable","getNextElement","getDocument","focusAsync","initializeComponentRef","on","__extends","props","_super","_this","createRef","ev","onFocus","_hasFocus","onBlur","relatedTarget","_getDocument","activeElement","_root","current","_onBumperFocus","isFirstBumper","disabled","currentBumper","_lastBumper","_firstBumper","nextFocusable","_isBumper","focus","onFocusCapture","target","currentTarget","_previouslyFocusedElementInTrapZone","FocusTrapZone","_focusStack","length","focusedElement","preventDefault","stopPropagation","clickedElement","_bringFocusIntoZone","_updateEventHandlers","enableAriaHiddenSiblings","_unmodalize","nextProps","elementToFocusOnDismiss","_previouslyFocusedElementOutsideTrapZone","prevProps","prevForceFocusInsideTrap","forceFocusInsideTrap","undefined","newForceFocusInsideTrap","prevDisabled","newDisabled","_returnFocusToInitiator","_disposeClickHandler","_disposeFocusHandler","className","_b","ariaLabelledBy","divProps","bumperProps","style","pointerEvents","position","tabIndex","ref","_onFocusCapture","_onRootFocus","_onRootBlur","_onFirstBumperFocus","children","_onLastBumperFocus","focusPreviouslyFocusedInnerElement","firstFocusableSelector","firstFocusableTarget","_focusAsync","focusSelector","_firstFocusableChild","querySelector","firstChild","element","_c","disableFirstFocus","push","filter","value","doc","ignoreExternalFocusing","body","newProps","window","_forceFocusInTrap","isClickableOutsideFocusTrap","_forceClickInTrap","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\FocusTrapZone\\FocusTrapZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  getDocument,\n  focusAsync,\n  initializeComponentRef,\n  on,\n} from '../../Utilities';\nimport { IFocusTrapZone, IFocusTrapZoneProps } from './FocusTrapZone.types';\n\nexport class FocusTrapZone extends React.Component<IFocusTrapZoneProps, {}> implements IFocusTrapZone {\n  private static _focusStack: FocusTrapZone[] = [];\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _firstBumper = React.createRef<HTMLDivElement>();\n  private _lastBumper = React.createRef<HTMLDivElement>();\n  private _hasFocus: boolean = false;\n  private _unmodalize?: () => void;\n\n  private _previouslyFocusedElementOutsideTrapZone: HTMLElement;\n  private _previouslyFocusedElementInTrapZone?: HTMLElement;\n  private _disposeFocusHandler: (() => void) | undefined;\n  private _disposeClickHandler: (() => void) | undefined;\n\n  public constructor(props: IFocusTrapZoneProps) {\n    super(props);\n    initializeComponentRef(this);\n  }\n\n  public componentDidMount(): void {\n    this._bringFocusIntoZone();\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IFocusTrapZoneProps): void {\n    const { elementToFocusOnDismiss } = nextProps;\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  }\n\n  public componentDidUpdate(prevProps: IFocusTrapZoneProps) {\n    const prevForceFocusInsideTrap =\n      prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    const newForceFocusInsideTrap =\n      this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    const prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    const newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (\n      !this.props.disabled ||\n      this.props.forceFocusInsideTrap ||\n      !elementContains(this._root.current, this._getDocument().activeElement as HTMLElement)\n    ) {\n      this._returnFocusToInitiator();\n    }\n\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    }\n\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  }\n\n  public render(): JSX.Element {\n    const { className, disabled = false, ariaLabelledBy } = this.props;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    const bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n      },\n      tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n      'data-is-visible': true,\n    } as React.HTMLAttributes<HTMLDivElement>;\n\n    return (\n      <div\n        {...divProps}\n        className={className}\n        ref={this._root}\n        aria-labelledby={ariaLabelledBy}\n        onFocusCapture={this._onFocusCapture}\n        onFocus={this._onRootFocus}\n        onBlur={this._onRootBlur}\n      >\n        <div {...bumperProps} ref={this._firstBumper} onFocus={this._onFirstBumperFocus} />\n        {this.props.children}\n        <div {...bumperProps} ref={this._lastBumper} onFocus={this._onLastBumperFocus} />\n      </div>\n    );\n  }\n\n  public focus() {\n    // eslint-disable-next-line deprecation/deprecation\n    const { focusPreviouslyFocusedInnerElement, firstFocusableSelector, firstFocusableTarget } = this.props;\n\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      this._previouslyFocusedElementInTrapZone &&\n      elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let _firstFocusableChild: HTMLElement | null = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(\n          this._root.current,\n          this._root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  }\n\n  private _focusAsync(element: HTMLElement): void {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  }\n\n  private _onRootFocus = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n\n    this._hasFocus = true;\n  };\n\n  private _onRootBlur = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = this._getDocument().activeElement as Element;\n    }\n\n    if (!elementContains(this._root.current, relatedTarget as HTMLElement)) {\n      this._hasFocus = false;\n    }\n  };\n\n  private _onFirstBumperFocus = () => {\n    this._onBumperFocus(true);\n  };\n\n  private _onLastBumperFocus = () => {\n    this._onBumperFocus(false);\n  };\n\n  private _onBumperFocus = (isFirstBumper: boolean) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const currentBumper = (isFirstBumper === this._hasFocus\n      ? this._lastBumper.current\n      : this._firstBumper.current) as HTMLElement;\n\n    if (this._root.current) {\n      const nextFocusable =\n        isFirstBumper === this._hasFocus\n          ? getLastTabbable(this._root.current, currentBumper, true, false)\n          : getFirstTabbable(this._root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (this._isBumper(nextFocusable)) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          this.focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  };\n\n  private _bringFocusIntoZone(): void {\n    const { elementToFocusOnDismiss, disabled = false, disableFirstFocus = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n      ? elementToFocusOnDismiss\n      : (this._getDocument().activeElement as HTMLElement);\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  }\n\n  private _returnFocusToInitiator(): void {\n    const { ignoreExternalFocusing } = this.props;\n\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value: FocusTrapZone) => {\n      return this !== value;\n    });\n\n    const doc = this._getDocument();\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !ignoreExternalFocusing &&\n      this._previouslyFocusedElementOutsideTrapZone &&\n      typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n      (elementContains(this._root.current, activeElement) || activeElement === doc.body)\n    ) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  }\n\n  private _updateEventHandlers(newProps: IFocusTrapZoneProps): void {\n    const { isClickableOutsideFocusTrap = false, forceFocusInsideTrap = true } = newProps;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n  }\n\n  private _onFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocusCapture) {\n      this.props.onFocusCapture(ev);\n    }\n\n    if (ev.target !== ev.currentTarget && !this._isBumper(ev.target)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      this._previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  private _isBumper(element: HTMLElement): boolean {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  }\n\n  private _forceFocusInTrap = (ev: FocusEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const focusedElement = this._getDocument().activeElement as HTMLElement;\n\n      if (!elementContains(this._root.current, focusedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _forceClickInTrap = (ev: MouseEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const clickedElement = ev.target as HTMLElement;\n\n      if (clickedElement && !elementContains(this._root.current, clickedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}