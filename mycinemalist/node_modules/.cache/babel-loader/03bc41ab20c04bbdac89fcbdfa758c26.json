{"ast":null,"code":"import { assign } from './object';\n/** An instance of EventGroup allows anything with a handle to it to trigger events on it.\n *  If the target is an HTMLElement, the event will be attached to the element and can be\n *  triggered as usual (like clicking for onClick).\n *  The event can be triggered by calling EventGroup.raise() here. If the target is an\n *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets\n *  handled here in EventGroup, and the handler is called in the context of the parent\n *  (which is passed in in the constructor).\n *\n * @public\n * {@docCategory EventGroup}\n */\n\nvar EventGroup =\n/** @class */\nfunction () {\n  /** parent: the context in which events attached to non-HTMLElements are called */\n  function EventGroup(parent) {\n    this._id = EventGroup._uniqueId++;\n    this._parent = parent;\n    this._eventRecords = [];\n  }\n  /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.\n   *  Events raised here by default have bubbling set to false and cancelable set to true.\n   *  This applies also to built-in events being raised manually here on HTMLElements,\n   *  which may lead to unexpected behavior if it differs from the defaults.\n   *\n   */\n\n\n  EventGroup.raise = function (target, eventName, eventArgs, bubbleEvent) {\n    var retVal;\n\n    if (EventGroup._isElement(target)) {\n      if (typeof document !== 'undefined' && document.createEvent) {\n        var ev = document.createEvent('HTMLEvents');\n        ev.initEvent(eventName, bubbleEvent || false, true);\n        assign(ev, eventArgs);\n        retVal = target.dispatchEvent(ev);\n      } else if (typeof document !== 'undefined' && document.createEventObject) {\n        // IE8\n        var evObj = document.createEventObject(eventArgs); // cannot set cancelBubble on evObj, fireEvent will overwrite it\n\n        target.fireEvent('on' + eventName, evObj);\n      }\n    } else {\n      while (target && retVal !== false) {\n        var events = target.__events__;\n        var eventRecords = events ? events[eventName] : null;\n\n        if (eventRecords) {\n          for (var id in eventRecords) {\n            if (eventRecords.hasOwnProperty(id)) {\n              var eventRecordList = eventRecords[id];\n\n              for (var listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {\n                var record = eventRecordList[listIndex];\n\n                if (record.objectCallback) {\n                  retVal = record.objectCallback.call(record.parent, eventArgs);\n                }\n              }\n            }\n          }\n        } // If the target has a parent, bubble the event up.\n\n\n        target = bubbleEvent ? target.parent : null;\n      }\n    }\n\n    return retVal;\n  };\n\n  EventGroup.isObserved = function (target, eventName) {\n    var events = target && target.__events__;\n    return !!events && !!events[eventName];\n  };\n  /** Check to see if the target has declared support of the given event. */\n\n\n  EventGroup.isDeclared = function (target, eventName) {\n    var declaredEvents = target && target.__declaredEvents;\n    return !!declaredEvents && !!declaredEvents[eventName];\n  };\n\n  EventGroup.stopPropagation = function (event) {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      // IE8\n      event.cancelBubble = true;\n    }\n  };\n\n  EventGroup._isElement = function (target) {\n    return !!target && (!!target.addEventListener || typeof HTMLElement !== 'undefined' && target instanceof HTMLElement);\n  };\n\n  EventGroup.prototype.dispose = function () {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n      this.off();\n      this._parent = null;\n    }\n  };\n  /** On the target, attach a set of events, where the events object is a name to function mapping. */\n\n\n  EventGroup.prototype.onAll = function (target, events, useCapture) {\n    for (var eventName in events) {\n      if (events.hasOwnProperty(eventName)) {\n        this.on(target, eventName, events[eventName], useCapture);\n      }\n    }\n  };\n  /**\n   * On the target, attach an event whose handler will be called in the context of the parent\n   * of this instance of EventGroup.\n   */\n\n\n  EventGroup.prototype.on = function (target, eventName, callback, options) {\n    var _this = this;\n\n    if (eventName.indexOf(',') > -1) {\n      var events = eventName.split(/[ ,]+/);\n\n      for (var i = 0; i < events.length; i++) {\n        this.on(target, events[i], callback, options);\n      }\n    } else {\n      var parent_1 = this._parent;\n      var eventRecord = {\n        target: target,\n        eventName: eventName,\n        parent: parent_1,\n        callback: callback,\n        options: options\n      }; // Initialize and wire up the record on the target, so that it can call the callback if the event fires.\n\n      var events = target.__events__ = target.__events__ || {};\n      events[eventName] = events[eventName] || {\n        count: 0\n      };\n      events[eventName][this._id] = events[eventName][this._id] || [];\n\n      events[eventName][this._id].push(eventRecord);\n\n      events[eventName].count++;\n\n      if (EventGroup._isElement(target)) {\n        var processElementEvent = function processElementEvent() {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          if (_this._isDisposed) {\n            return;\n          }\n\n          var result;\n\n          try {\n            result = callback.apply(parent_1, args);\n\n            if (result === false && args[0]) {\n              var e = args[0];\n\n              if (e.preventDefault) {\n                e.preventDefault();\n              }\n\n              if (e.stopPropagation) {\n                e.stopPropagation();\n              }\n\n              e.cancelBubble = true;\n            }\n          } catch (e) {// ignore\n          }\n\n          return result;\n        };\n\n        eventRecord.elementCallback = processElementEvent;\n\n        if (target.addEventListener) {\n          target.addEventListener(eventName, processElementEvent, options);\n        } else if (target.attachEvent) {\n          // IE8\n          target.attachEvent('on' + eventName, processElementEvent);\n        }\n      } else {\n        var processObjectEvent = function processObjectEvent() {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          if (_this._isDisposed) {\n            return;\n          }\n\n          return callback.apply(parent_1, args);\n        };\n\n        eventRecord.objectCallback = processObjectEvent;\n      } // Remember the record locally, so that it can be removed.\n\n\n      this._eventRecords.push(eventRecord);\n    }\n  };\n\n  EventGroup.prototype.off = function (target, eventName, callback, options) {\n    for (var i = 0; i < this._eventRecords.length; i++) {\n      var eventRecord = this._eventRecords[i];\n\n      if ((!target || target === eventRecord.target) && (!eventName || eventName === eventRecord.eventName) && (!callback || callback === eventRecord.callback) && (typeof options !== 'boolean' || options === eventRecord.options)) {\n        var events = eventRecord.target.__events__;\n        var targetArrayLookup = events[eventRecord.eventName];\n        var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null; // We may have already target's entries, so check for null.\n\n        if (targetArray) {\n          if (targetArray.length === 1 || !callback) {\n            targetArrayLookup.count -= targetArray.length;\n            delete events[eventRecord.eventName][this._id];\n          } else {\n            targetArrayLookup.count--;\n            targetArray.splice(targetArray.indexOf(eventRecord), 1);\n          }\n\n          if (!targetArrayLookup.count) {\n            delete events[eventRecord.eventName];\n          }\n        }\n\n        if (eventRecord.elementCallback) {\n          if (eventRecord.target.removeEventListener) {\n            eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.options);\n          } else if (eventRecord.target.detachEvent) {\n            // IE8\n            eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);\n          }\n        }\n\n        this._eventRecords.splice(i--, 1);\n      }\n    }\n  };\n  /** Trigger the given event in the context of this instance of EventGroup. */\n\n\n  EventGroup.prototype.raise = function (eventName, eventArgs, bubbleEvent) {\n    return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);\n  };\n  /** Declare an event as being supported by this instance of EventGroup. */\n\n\n  EventGroup.prototype.declare = function (event) {\n    var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};\n\n    if (typeof event === 'string') {\n      declaredEvents[event] = true;\n    } else {\n      for (var i = 0; i < event.length; i++) {\n        declaredEvents[event[i]] = true;\n      }\n    }\n  };\n\n  EventGroup._uniqueId = 0;\n  return EventGroup;\n}();\n\nexport { EventGroup };","map":{"version":3,"mappings":"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","names":["assign","parent","EventGroup","_uniqueId","_parent","_eventRecords","target","eventName","eventArgs","bubbleEvent","retVal","_isElement","document","createEvent","ev","initEvent","dispatchEvent","createEventObject","evObj","fireEvent","events","__events__","eventRecords","id","hasOwnProperty","eventRecordList","listIndex","length","record","objectCallback","call","declaredEvents","__declaredEvents","event","stopPropagation","cancelBubble","addEventListener","HTMLElement","_isDisposed","off","useCapture","on","callback","options","indexOf","split","i","parent_1","eventRecord","count","_id","push","processElementEvent","args","_this","result","apply","e","preventDefault","elementCallback","attachEvent","processObjectEvent","targetArrayLookup","targetArray","splice","removeEventListener","detachEvent","raise"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\src\\EventGroup.ts"],"sourcesContent":["import { assign } from './object';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * @internal\n */\nexport interface IEventRecord {\n  target: any;\n  eventName: string;\n  parent: any;\n  callback: (args?: any) => void;\n  elementCallback?: (...args: any[]) => void;\n  objectCallback?: (args?: any) => void;\n  options?: boolean | AddEventListenerOptions;\n}\n\n/**\n * @internal\n */\nexport interface IEventRecordsByName {\n  [eventName: string]: IEventRecordList;\n}\n\n/**\n * @internal\n */\nexport interface IEventRecordList {\n  [id: string]: IEventRecord[] | number;\n  count: number;\n}\n\n/**\n * @internal\n */\nexport interface IDeclaredEventsByName {\n  [eventName: string]: boolean;\n}\n\n/** An instance of EventGroup allows anything with a handle to it to trigger events on it.\n *  If the target is an HTMLElement, the event will be attached to the element and can be\n *  triggered as usual (like clicking for onClick).\n *  The event can be triggered by calling EventGroup.raise() here. If the target is an\n *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets\n *  handled here in EventGroup, and the handler is called in the context of the parent\n *  (which is passed in in the constructor).\n *\n * @public\n * {@docCategory EventGroup}\n */\nexport class EventGroup {\n  private static _uniqueId: number = 0;\n  private _parent: any;\n  private _eventRecords: IEventRecord[];\n  private _id: number = EventGroup._uniqueId++;\n  private _isDisposed: boolean;\n\n  /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.\n   *  Events raised here by default have bubbling set to false and cancelable set to true.\n   *  This applies also to built-in events being raised manually here on HTMLElements,\n   *  which may lead to unexpected behavior if it differs from the defaults.\n   *\n   */\n  public static raise(target: any, eventName: string, eventArgs?: any, bubbleEvent?: boolean): boolean | undefined {\n    let retVal;\n\n    if (EventGroup._isElement(target)) {\n      if (typeof document !== 'undefined' && document.createEvent) {\n        let ev = document.createEvent('HTMLEvents');\n\n        ev.initEvent(eventName, bubbleEvent || false, true);\n\n        assign(ev, eventArgs);\n\n        retVal = target.dispatchEvent(ev);\n      } else if (typeof document !== 'undefined' && (document as any).createEventObject) {\n        // IE8\n        let evObj = (document as any).createEventObject(eventArgs);\n        // cannot set cancelBubble on evObj, fireEvent will overwrite it\n        target.fireEvent('on' + eventName, evObj);\n      }\n    } else {\n      while (target && retVal !== false) {\n        let events = <IEventRecordsByName>target.__events__;\n        let eventRecords = events ? events[eventName] : null;\n\n        if (eventRecords) {\n          for (let id in eventRecords) {\n            if (eventRecords.hasOwnProperty(id)) {\n              let eventRecordList = <IEventRecord[]>eventRecords[id];\n\n              for (let listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {\n                let record = eventRecordList[listIndex];\n\n                if (record.objectCallback) {\n                  retVal = record.objectCallback.call(record.parent, eventArgs);\n                }\n              }\n            }\n          }\n        }\n\n        // If the target has a parent, bubble the event up.\n        target = bubbleEvent ? target.parent : null;\n      }\n    }\n\n    return retVal;\n  }\n\n  public static isObserved(target: any, eventName: string): boolean {\n    let events = target && <IEventRecordsByName>target.__events__;\n\n    return !!events && !!events[eventName];\n  }\n\n  /** Check to see if the target has declared support of the given event. */\n  public static isDeclared(target: any, eventName: string): boolean {\n    let declaredEvents = target && <IDeclaredEventsByName>target.__declaredEvents;\n\n    return !!declaredEvents && !!declaredEvents[eventName];\n  }\n\n  public static stopPropagation(event: any): void {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      // IE8\n      event.cancelBubble = true;\n    }\n  }\n\n  private static _isElement(target: HTMLElement): boolean {\n    return (\n      !!target && (!!target.addEventListener || (typeof HTMLElement !== 'undefined' && target instanceof HTMLElement))\n    );\n  }\n\n  /** parent: the context in which events attached to non-HTMLElements are called */\n  public constructor(parent: any) {\n    this._parent = parent;\n    this._eventRecords = [];\n  }\n\n  public dispose(): void {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n\n      this.off();\n      this._parent = null;\n    }\n  }\n\n  /** On the target, attach a set of events, where the events object is a name to function mapping. */\n  public onAll(target: any, events: { [key: string]: (args?: any) => void }, useCapture?: boolean): void {\n    for (let eventName in events) {\n      if (events.hasOwnProperty(eventName)) {\n        this.on(target, eventName, events[eventName], useCapture);\n      }\n    }\n  }\n\n  /**\n   * On the target, attach an event whose handler will be called in the context of the parent\n   * of this instance of EventGroup.\n   */\n  public on(\n    target: any,\n    eventName: string,\n    callback: (args?: any) => void,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    if (eventName.indexOf(',') > -1) {\n      let events = eventName.split(/[ ,]+/);\n\n      for (let i = 0; i < events.length; i++) {\n        this.on(target, events[i], callback, options);\n      }\n    } else {\n      let parent = this._parent;\n      let eventRecord: IEventRecord = {\n        target: target,\n        eventName: eventName,\n        parent: parent,\n        callback: callback,\n        options,\n      };\n\n      // Initialize and wire up the record on the target, so that it can call the callback if the event fires.\n      let events = <IEventRecordsByName>(target.__events__ = target.__events__ || {});\n      events[eventName] =\n        events[eventName] ||\n        <IEventRecordList>{\n          count: 0,\n        };\n      events[eventName][this._id] = events[eventName][this._id] || [];\n      (<IEventRecord[]>events[eventName][this._id]).push(eventRecord);\n      events[eventName].count++;\n\n      if (EventGroup._isElement(target)) {\n        let processElementEvent = (...args: any[]) => {\n          if (this._isDisposed) {\n            return;\n          }\n\n          let result;\n          try {\n            result = callback.apply(parent, args);\n            if (result === false && args[0]) {\n              let e = args[0];\n\n              if (e.preventDefault) {\n                e.preventDefault();\n              }\n\n              if (e.stopPropagation) {\n                e.stopPropagation();\n              }\n\n              e.cancelBubble = true;\n            }\n          } catch (e) {\n            // ignore\n          }\n\n          return result;\n        };\n\n        eventRecord.elementCallback = processElementEvent;\n\n        if (target.addEventListener) {\n          (<EventTarget>target).addEventListener(eventName, processElementEvent, options);\n        } else if (target.attachEvent) {\n          // IE8\n          target.attachEvent('on' + eventName, processElementEvent);\n        }\n      } else {\n        let processObjectEvent = (...args: any[]) => {\n          if (this._isDisposed) {\n            return;\n          }\n\n          return callback.apply(parent, args);\n        };\n\n        eventRecord.objectCallback = processObjectEvent;\n      }\n\n      // Remember the record locally, so that it can be removed.\n      this._eventRecords.push(eventRecord);\n    }\n  }\n\n  public off(\n    target?: any,\n    eventName?: string,\n    callback?: (args?: any) => void,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    for (let i = 0; i < this._eventRecords.length; i++) {\n      let eventRecord = this._eventRecords[i];\n      if (\n        (!target || target === eventRecord.target) &&\n        (!eventName || eventName === eventRecord.eventName) &&\n        (!callback || callback === eventRecord.callback) &&\n        (typeof options !== 'boolean' || options === eventRecord.options)\n      ) {\n        let events = <IEventRecordsByName>eventRecord.target.__events__;\n        let targetArrayLookup = events[eventRecord.eventName];\n        let targetArray = targetArrayLookup ? <IEventRecord[]>targetArrayLookup[this._id] : null;\n\n        // We may have already target's entries, so check for null.\n        if (targetArray) {\n          if (targetArray.length === 1 || !callback) {\n            targetArrayLookup.count -= targetArray.length;\n            delete events[eventRecord.eventName][this._id];\n          } else {\n            targetArrayLookup.count--;\n            targetArray.splice(targetArray.indexOf(eventRecord), 1);\n          }\n\n          if (!targetArrayLookup.count) {\n            delete events[eventRecord.eventName];\n          }\n        }\n\n        if (eventRecord.elementCallback) {\n          if (eventRecord.target.removeEventListener) {\n            eventRecord.target.removeEventListener(\n              eventRecord.eventName,\n              eventRecord.elementCallback,\n              eventRecord.options,\n            );\n          } else if (eventRecord.target.detachEvent) {\n            // IE8\n            eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);\n          }\n        }\n\n        this._eventRecords.splice(i--, 1);\n      }\n    }\n  }\n\n  /** Trigger the given event in the context of this instance of EventGroup. */\n  public raise(eventName: string, eventArgs?: any, bubbleEvent?: boolean): boolean | undefined {\n    return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);\n  }\n\n  /** Declare an event as being supported by this instance of EventGroup. */\n  public declare(event: string | string[]): void {\n    let declaredEvents = (this._parent.__declaredEvents = this._parent.__declaredEvents || {});\n\n    if (typeof event === 'string') {\n      declaredEvents[event] = true;\n    } else {\n      for (let i = 0; i < event.length; i++) {\n        declaredEvents[event[i]] = true;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}