{"ast":null,"code":"import { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { isValidShade, getShade, getBackgroundShade } from '../../utilities/color/shades';\nimport { format } from '../../Utilities';\n\nvar ThemeGenerator =\n/** @class */\nfunction () {\n  function ThemeGenerator() {}\n  /**\n   * Sets an IThemeSlotRule to the given color and cascades it to the rest of the theme, updating other IThemeSlotRules\n   * in the theme that inherit from that color.\n   * @param isInverted - whether it's a dark theme or not, which affects the algorithm used to generate shades\n   * @param isCustomization - should be true only if it's a user action, and indicates overwriting the slot's\n   * inheritance (if any)\n   * @param overwriteCustomColor - A slot could have a generated color based on its inheritance rules (isCustomized\n   * is false), or a custom color based on user input (isCustomized is true). This bool tells us whether to override\n   * existing customized colors.\n   */\n\n\n  ThemeGenerator.setSlot = function (rule, color, isInverted, isCustomization, overwriteCustomColor) {\n    if (isInverted === void 0) {\n      isInverted = false;\n    }\n\n    if (isCustomization === void 0) {\n      isCustomization = false;\n    }\n\n    if (overwriteCustomColor === void 0) {\n      overwriteCustomColor = true;\n    }\n\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor) {\n      var colorAsIColor = void 0;\n\n      if (typeof color === 'string') {\n        colorAsIColor = getColorFromString(color); // the ! is a lie here but we'll verify it in the next line\n\n        if (!colorAsIColor) {\n          throw new Error('color is invalid in setSlot(): ' + color);\n        }\n      } else {\n        colorAsIColor = color;\n      }\n\n      ThemeGenerator._setSlot(rule, colorAsIColor, isInverted, isCustomization, overwriteCustomColor);\n    } else if (rule.color) {\n      ThemeGenerator._setSlot(rule, rule.color, isInverted, isCustomization, overwriteCustomColor);\n    }\n  };\n  /**\n   * Sets the color of each slot based on its rule. Slots that don't inherit must have a color already.\n   * If this completes without error, then the theme is ready to use. (All slots will have a color.)\n   * setSlot() can be called before this, but this must be called before getThemeAs*().\n   * Does not override colors of rules where isCustomized is true (i.e. doesn't override existing customizations).\n   */\n\n\n  ThemeGenerator.insureSlots = function (slotRules, isInverted) {\n    // Get all the \"root\" rules, the ones which don't inherit. Then \"set\" them to trigger updating dependent slots.\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n\n        if (!rule.inherits && !rule.value) {\n          if (!rule.color) {\n            throw new Error('A color slot rule that does not inherit must provide its own color.');\n          }\n\n          ThemeGenerator._setSlot(rule, rule.color, isInverted, false, false);\n        }\n      }\n    }\n  };\n  /**\n   * Gets the JSON-formatted blob that describes the theme, usable with the REST request endpoints:\n   * ```\n   * { [theme slot name as string] : [color as string],\n   *  \"tokenName\": \"#f00f00\",\n   *  \"tokenName2\": \"#ba2ba2\",\n   *   ... }\n   * ```\n   */\n\n\n  ThemeGenerator.getThemeAsJson = function (slotRules) {\n    var theme = {};\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n        theme[rule.name] = rule.color ? rule.color.str : rule.value || '';\n      }\n    }\n\n    return theme;\n  };\n  /**\n   * Gets code-formatted load theme blob that can be copy and pasted.\n   * Only used for the old theme designer, where loadTheme usage is acceptable,\n   * unlike in the new theme designer.\n   */\n\n\n  ThemeGenerator.getThemeAsCode = function (slotRules) {\n    var output = 'loadTheme({\\n  palette: {\\n';\n    return ThemeGenerator._makeRemainingCode(output, slotRules);\n  };\n  /**\n   * Gets code-formatted load theme blob, specifically for the new theme designer,\n   * aka.ms/themedesigner. Shouldn't use loadTheme like the old theme designer since it's deprecated.\n   * We want to use the theme object from createTheme and use the Customizations.applySettings API instead.\n   */\n\n\n  ThemeGenerator.getThemeAsCodeWithCreateTheme = function (slotRules) {\n    var output = 'const myTheme = createTheme({\\n  palette: {\\n';\n    return ThemeGenerator._makeRemainingCode(output, slotRules);\n  };\n  /**\n   * Gets the theme as a list of SASS variables that can be used in code\n   * ```\n   * $tokenName: \"[theme:tokenName, default:#f00f00]\";\n   * $tokenName2: \"[theme:tokenName2, default:#ba2ba2]\";\n   * ...\n   * ```\n   */\n\n\n  ThemeGenerator.getThemeAsSass = function (slotRules) {\n    var sassVarTemplate = '${0}Color: \"[theme: {1}, default: {2}]\";\\n';\n    var output = '';\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n        var camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        output += format(sassVarTemplate, camelCasedName, camelCasedName, rule.color ? rule.color.str : rule.value || '');\n      }\n    }\n\n    return output;\n  };\n  /**\n   * Gets the theme formatted for PowerShell scripts\n   * ```\n   * @{\n   * \"tokenName\" = \"#f00f00\";\n   * \"tokenName2\" = \"#ba2ba2\";\n   * ...\n   * }\n   * ```\n   */\n\n\n  ThemeGenerator.getThemeForPowerShell = function (slotRules) {\n    var psVarTemplate = '\"{0}\" = \"{1}\";\\n';\n    var output = '';\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n\n        if (rule.value) {\n          // skip this one, it's not a color\n          continue;\n        }\n\n        var camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        var outputColor = rule.color ? '#' + rule.color.hex : rule.value || ''; // powershell endpoint uses the RGBA format\n\n        if (rule.color && rule.color.a && rule.color.a !== 100) {\n          outputColor += String(rule.color.a.toString(16));\n        }\n\n        output += format(psVarTemplate, camelCasedName, outputColor);\n      }\n    }\n\n    return '@{\\n' + output + '}';\n  };\n  /**\n   * Sets the given slot's color to the appropriate color, shading it if necessary.\n   * Then, iterates through all other rules (that are this rule's dependents) to update them accordingly.\n   * @param isCustomization - If true, it's a user-provided color, which should be to that raw color.\n   * If false, the rule it's inheriting from changed, so updated using asShade.\n   */\n\n\n  ThemeGenerator._setSlot = function (rule, color, isInverted, isCustomization, overwriteCustomColor) {\n    if (overwriteCustomColor === void 0) {\n      overwriteCustomColor = true;\n    }\n\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor || !rule.color || !rule.isCustomized || !rule.inherits) {\n      // set the rule's color under these conditions\n      if ((overwriteCustomColor || !rule.isCustomized) && !isCustomization && rule.inherits && isValidShade(rule.asShade)) {\n        // it's inheriting by shade\n        if (rule.isBackgroundShade) {\n          rule.color = getBackgroundShade(color, rule.asShade, isInverted);\n        } else {\n          rule.color = getShade(color, rule.asShade, isInverted);\n        }\n\n        rule.isCustomized = false;\n      } else {\n        rule.color = color;\n        rule.isCustomized = true;\n      } // then update dependent colors\n\n\n      for (var _i = 0, _a = rule.dependentRules; _i < _a.length; _i++) {\n        var ruleToUpdate = _a[_i];\n\n        ThemeGenerator._setSlot(ruleToUpdate, rule.color, isInverted, false, overwriteCustomColor);\n      }\n    }\n  };\n  /**\n   * Makes the rest of the code that's used for the load theme blob in the exported codepens of\n   * both the older sharepoint-specific theme designer and the new theme designer. Takes in\n   * theme rules and converts them to format fitting a list of palette colors and their values.\n   * Resulting output looks like:\n   * ```\n   * const _theme = createTheme({\n   *  palette: {\n   *    themePrimary: '#0078d4',\n   *    themeLighterAlt: '#f3f9fd',\n   *    ...\n   *  }});\n   * ```\n   * The first line is loadTheme instead of createTheme for the old sharepoint theme designer.\n   */\n\n\n  ThemeGenerator._makeRemainingCode = function (output, slotRules) {\n    var attributeTemplate = \"    {0}: '{1}',\\n\";\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n        var camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        var outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';\n        output += format(attributeTemplate, camelCasedName, outputColor);\n      }\n    }\n\n    output += '  }});';\n    return output;\n  };\n\n  return ThemeGenerator;\n}();\n\nexport { ThemeGenerator };","map":{"version":3,"mappings":"AACA,SAASA,kBAAT,QAAmC,0CAAnC;AACA,SAASC,YAAT,EAAuBC,QAAvB,EAAiCC,kBAAjC,QAA2D,8BAA3D;AACA,SAASC,MAAT,QAAuB,iBAAvB;;AAKA;AAAA;AAAA;EAAA,2BAyOC;EAxOC;;;;;;;;;;;;EAUcC,yBAAd,UACEC,IADF,EAEEC,KAFF,EAGEC,UAHF,EAIEC,eAJF,EAKEC,oBALF,EAK6B;IAF3B;MAAAF;IAAkB;;IAClB;MAAAC;IAAuB;;IACvB;MAAAC;IAA2B;;IAE3B,IAAI,CAACJ,IAAI,CAACC,KAAN,IAAeD,IAAI,CAACK,KAAxB,EAA+B;MAC7B;MACA;IACD;;IAED,IAAID,oBAAJ,EAA0B;MACxB,IAAIE,aAAa,SAAjB;;MACA,IAAI,OAAOL,KAAP,KAAiB,QAArB,EAA+B;QAC7BK,aAAa,GAAGZ,kBAAkB,CAACO,KAAD,CAAlC,CAD6B,CACe;;QAC5C,IAAI,CAACK,aAAL,EAAoB;UAClB,MAAM,IAAIC,KAAJ,CAAU,oCAAoCN,KAA9C,CAAN;QACD;MACF,CALD,MAKO;QACLK,aAAa,GAAGL,KAAhB;MACD;;MACDF,cAAc,CAACS,QAAf,CAAwBR,IAAxB,EAA8BM,aAA9B,EAA6CJ,UAA7C,EAAyDC,eAAzD,EAA0EC,oBAA1E;IACD,CAXD,MAWO,IAAIJ,IAAI,CAACC,KAAT,EAAgB;MACrBF,cAAc,CAACS,QAAf,CAAwBR,IAAxB,EAA8BA,IAAI,CAACC,KAAnC,EAA0CC,UAA1C,EAAsDC,eAAtD,EAAuEC,oBAAvE;IACD;EACF,CA1Ba;EA4Bd;;;;;;;;EAMcL,6BAAd,UAA0BU,SAA1B,EAAkDP,UAAlD,EAAqE;IACnE;IACA,KAAK,IAAMQ,QAAX,IAAuBD,SAAvB,EAAkC;MAChC,IAAIA,SAAS,CAACE,cAAV,CAAyBD,QAAzB,CAAJ,EAAwC;QACtC,IAAMV,IAAI,GAAmBS,SAAS,CAACC,QAAD,CAAtC;;QACA,IAAI,CAACV,IAAI,CAACY,QAAN,IAAkB,CAACZ,IAAI,CAACK,KAA5B,EAAmC;UACjC,IAAI,CAACL,IAAI,CAACC,KAAV,EAAiB;YACf,MAAM,IAAIM,KAAJ,CAAU,qEAAV,CAAN;UACD;;UACDR,cAAc,CAACS,QAAf,CAAwBR,IAAxB,EAA8BA,IAAI,CAACC,KAAnC,EAA0CC,UAA1C,EAAsD,KAAtD,EAA6D,KAA7D;QACD;MACF;IACF;EACF,CAba;EAed;;;;;;;;;;;EAScH,gCAAd,UAA6BU,SAA7B,EAAmD;IACjD,IAAMI,KAAK,GAAQ,EAAnB;;IACA,KAAK,IAAMH,QAAX,IAAuBD,SAAvB,EAAkC;MAChC,IAAIA,SAAS,CAACE,cAAV,CAAyBD,QAAzB,CAAJ,EAAwC;QACtC,IAAMV,IAAI,GAAmBS,SAAS,CAACC,QAAD,CAAtC;QACAG,KAAK,CAACb,IAAI,CAACc,IAAN,CAAL,GAAmBd,IAAI,CAACC,KAAL,GAAaD,IAAI,CAACC,KAAL,CAAWc,GAAxB,GAA8Bf,IAAI,CAACK,KAAL,IAAc,EAA/D;MACD;IACF;;IACD,OAAOQ,KAAP;EACD,CATa;EAWd;;;;;;;EAKcd,gCAAd,UAA6BU,SAA7B,EAAmD;IACjD,IAAMO,MAAM,GAAG,6BAAf;IACA,OAAOjB,cAAc,CAACkB,kBAAf,CAAkCD,MAAlC,EAA0CP,SAA1C,CAAP;EACD,CAHa;EAKd;;;;;;;EAKcV,+CAAd,UAA4CU,SAA5C,EAAkE;IAChE,IAAMO,MAAM,GAAG,+CAAf;IACA,OAAOjB,cAAc,CAACkB,kBAAf,CAAkCD,MAAlC,EAA0CP,SAA1C,CAAP;EACD,CAHa;EAKd;;;;;;;;;;EAQcV,gCAAd,UAA6BU,SAA7B,EAAmD;IACjD,IAAMS,eAAe,GAAG,4CAAxB;IACA,IAAIF,MAAM,GAAG,EAAb;;IAEA,KAAK,IAAMN,QAAX,IAAuBD,SAAvB,EAAkC;MAChC,IAAIA,SAAS,CAACE,cAAV,CAAyBD,QAAzB,CAAJ,EAAwC;QACtC,IAAMV,IAAI,GAAmBS,SAAS,CAACC,QAAD,CAAtC;QACA,IAAMS,cAAc,GAAGnB,IAAI,CAACc,IAAL,CAAUM,MAAV,CAAiB,CAAjB,EAAoBC,WAApB,KAAoCrB,IAAI,CAACc,IAAL,CAAUQ,KAAV,CAAgB,CAAhB,CAA3D;QACAN,MAAM,IAAIlB,MAAM,CACdoB,eADc,EAEdC,cAFc,EAGdA,cAHc,EAIdnB,IAAI,CAACC,KAAL,GAAaD,IAAI,CAACC,KAAL,CAAWc,GAAxB,GAA8Bf,IAAI,CAACK,KAAL,IAAc,EAJ9B,CAAhB;MAMD;IACF;;IACD,OAAOW,MAAP;EACD,CAjBa;EAmBd;;;;;;;;;;;;EAUcjB,uCAAd,UAAoCU,SAApC,EAA0D;IACxD,IAAMc,aAAa,GAAG,kBAAtB;IACA,IAAIP,MAAM,GAAG,EAAb;;IAEA,KAAK,IAAMN,QAAX,IAAuBD,SAAvB,EAAkC;MAChC,IAAIA,SAAS,CAACE,cAAV,CAAyBD,QAAzB,CAAJ,EAAwC;QACtC,IAAMV,IAAI,GAAmBS,SAAS,CAACC,QAAD,CAAtC;;QACA,IAAIV,IAAI,CAACK,KAAT,EAAgB;UACd;UACA;QACD;;QACD,IAAMc,cAAc,GAAGnB,IAAI,CAACc,IAAL,CAAUM,MAAV,CAAiB,CAAjB,EAAoBC,WAApB,KAAoCrB,IAAI,CAACc,IAAL,CAAUQ,KAAV,CAAgB,CAAhB,CAA3D;QACA,IAAIE,WAAW,GAAGxB,IAAI,CAACC,KAAL,GAAa,MAAMD,IAAI,CAACC,KAAL,CAAWwB,GAA9B,GAAoCzB,IAAI,CAACK,KAAL,IAAc,EAApE,CAPsC,CAQtC;;QACA,IAAIL,IAAI,CAACC,KAAL,IAAcD,IAAI,CAACC,KAAL,CAAWyB,CAAzB,IAA8B1B,IAAI,CAACC,KAAL,CAAWyB,CAAX,KAAiB,GAAnD,EAAwD;UACtDF,WAAW,IAAIG,MAAM,CAAC3B,IAAI,CAACC,KAAL,CAAWyB,CAAX,CAAaE,QAAb,CAAsB,EAAtB,CAAD,CAArB;QACD;;QACDZ,MAAM,IAAIlB,MAAM,CAACyB,aAAD,EAAgBJ,cAAhB,EAAgCK,WAAhC,CAAhB;MACD;IACF;;IACD,OAAO,SAASR,MAAT,GAAkB,GAAzB;EACD,CArBa;EAuBd;;;;;;;;EAMejB,0BAAf,UACEC,IADF,EAEEC,KAFF,EAGEC,UAHF,EAIEC,eAJF,EAKEC,oBALF,EAK6B;IAA3B;MAAAA;IAA2B;;IAE3B,IAAI,CAACJ,IAAI,CAACC,KAAN,IAAeD,IAAI,CAACK,KAAxB,EAA+B;MAC7B;MACA;IACD;;IAED,IAAID,oBAAoB,IAAI,CAACJ,IAAI,CAACC,KAA9B,IAAuC,CAACD,IAAI,CAAC6B,YAA7C,IAA6D,CAAC7B,IAAI,CAACY,QAAvE,EAAiF;MAC/E;MACA,IACE,CAACR,oBAAoB,IAAI,CAACJ,IAAI,CAAC6B,YAA/B,KACA,CAAC1B,eADD,IAEAH,IAAI,CAACY,QAFL,IAGAjB,YAAY,CAACK,IAAI,CAAC8B,OAAN,CAJd,EAKE;QACA;QACA,IAAI9B,IAAI,CAAC+B,iBAAT,EAA4B;UAC1B/B,IAAI,CAACC,KAAL,GAAaJ,kBAAkB,CAACI,KAAD,EAAQD,IAAI,CAAC8B,OAAb,EAAuB5B,UAAvB,CAA/B;QACD,CAFD,MAEO;UACLF,IAAI,CAACC,KAAL,GAAaL,QAAQ,CAACK,KAAD,EAAQD,IAAI,CAAC8B,OAAb,EAAuB5B,UAAvB,CAArB;QACD;;QACDF,IAAI,CAAC6B,YAAL,GAAoB,KAApB;MACD,CAbD,MAaO;QACL7B,IAAI,CAACC,KAAL,GAAaA,KAAb;QACAD,IAAI,CAAC6B,YAAL,GAAoB,IAApB;MACD,CAlB8E,CAoB/E;;;MACA,KAA2B,qBAAI,CAACG,cAAhC,EAA2BC,cAA3B,EAA2BA,IAA3B,EAAgD;QAA3C,IAAMC,YAAY,SAAlB;;QACHnC,cAAc,CAACS,QAAf,CAAwB0B,YAAxB,EAAsClC,IAAI,CAACC,KAA3C,EAAkDC,UAAlD,EAA8D,KAA9D,EAAqEE,oBAArE;MACD;IACF;EACF,CArCc;EAuCf;;;;;;;;;;;;;;;;;EAeeL,oCAAf,UAAkCiB,MAAlC,EAAkDP,SAAlD,EAAwE;IACtE,IAAM0B,iBAAiB,GAAG,mBAA1B;;IACA,KAAK,IAAMzB,QAAX,IAAuBD,SAAvB,EAAkC;MAChC,IAAIA,SAAS,CAACE,cAAV,CAAyBD,QAAzB,CAAJ,EAAwC;QACtC,IAAMV,IAAI,GAAmBS,SAAS,CAACC,QAAD,CAAtC;QACA,IAAMS,cAAc,GAAGnB,IAAI,CAACc,IAAL,CAAUM,MAAV,CAAiB,CAAjB,EAAoBC,WAApB,KAAoCrB,IAAI,CAACc,IAAL,CAAUQ,KAAV,CAAgB,CAAhB,CAA3D;QACA,IAAME,WAAW,GAAGxB,IAAI,CAACC,KAAL,GAAa,MAAMD,IAAI,CAACC,KAAL,CAAWwB,GAA9B,GAAoCzB,IAAI,CAACK,KAAL,IAAc,EAAtE;QACAW,MAAM,IAAIlB,MAAM,CAACqC,iBAAD,EAAoBhB,cAApB,EAAoCK,WAApC,CAAhB;MACD;IACF;;IACDR,MAAM,IAAI,QAAV;IACA,OAAOA,MAAP;EACD,CAZc;;EAajB;AAAC,CAzOD","names":["getColorFromString","isValidShade","getShade","getBackgroundShade","format","ThemeGenerator","rule","color","isInverted","isCustomization","overwriteCustomColor","value","colorAsIColor","Error","_setSlot","slotRules","ruleName","hasOwnProperty","inherits","theme","name","str","output","_makeRemainingCode","sassVarTemplate","camelCasedName","charAt","toLowerCase","slice","psVarTemplate","outputColor","hex","a","String","toString","isCustomized","asShade","isBackgroundShade","dependentRules","_i","ruleToUpdate","attributeTemplate"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\ThemeGenerator\\ThemeGenerator.ts"],"sourcesContent":["import { IColor } from '../../utilities/color/interfaces';\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { isValidShade, getShade, getBackgroundShade } from '../../utilities/color/shades';\nimport { format } from '../../Utilities';\n\nimport { IThemeSlotRule } from './IThemeSlotRule';\nimport { IThemeRules } from './IThemeRules';\n\nexport class ThemeGenerator {\n  /**\n   * Sets an IThemeSlotRule to the given color and cascades it to the rest of the theme, updating other IThemeSlotRules\n   * in the theme that inherit from that color.\n   * @param isInverted - whether it's a dark theme or not, which affects the algorithm used to generate shades\n   * @param isCustomization - should be true only if it's a user action, and indicates overwriting the slot's\n   * inheritance (if any)\n   * @param overwriteCustomColor - A slot could have a generated color based on its inheritance rules (isCustomized\n   * is false), or a custom color based on user input (isCustomized is true). This bool tells us whether to override\n   * existing customized colors.\n   */\n  public static setSlot(\n    rule: IThemeSlotRule,\n    color: string | IColor,\n    isInverted = false,\n    isCustomization = false,\n    overwriteCustomColor = true,\n  ) {\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor) {\n      let colorAsIColor: IColor;\n      if (typeof color === 'string') {\n        colorAsIColor = getColorFromString(color)!; // the ! is a lie here but we'll verify it in the next line\n        if (!colorAsIColor) {\n          throw new Error('color is invalid in setSlot(): ' + color);\n        }\n      } else {\n        colorAsIColor = color;\n      }\n      ThemeGenerator._setSlot(rule, colorAsIColor, isInverted, isCustomization, overwriteCustomColor);\n    } else if (rule.color) {\n      ThemeGenerator._setSlot(rule, rule.color, isInverted, isCustomization, overwriteCustomColor);\n    }\n  }\n\n  /**\n   * Sets the color of each slot based on its rule. Slots that don't inherit must have a color already.\n   * If this completes without error, then the theme is ready to use. (All slots will have a color.)\n   * setSlot() can be called before this, but this must be called before getThemeAs*().\n   * Does not override colors of rules where isCustomized is true (i.e. doesn't override existing customizations).\n   */\n  public static insureSlots(slotRules: IThemeRules, isInverted: boolean) {\n    // Get all the \"root\" rules, the ones which don't inherit. Then \"set\" them to trigger updating dependent slots.\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        if (!rule.inherits && !rule.value) {\n          if (!rule.color) {\n            throw new Error('A color slot rule that does not inherit must provide its own color.');\n          }\n          ThemeGenerator._setSlot(rule, rule.color, isInverted, false, false);\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the JSON-formatted blob that describes the theme, usable with the REST request endpoints:\n   * ```\n   * { [theme slot name as string] : [color as string],\n   *  \"tokenName\": \"#f00f00\",\n   *  \"tokenName2\": \"#ba2ba2\",\n   *   ... }\n   * ```\n   */\n  public static getThemeAsJson(slotRules: IThemeRules): any {\n    const theme: any = {};\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        theme[rule.name] = rule.color ? rule.color.str : rule.value || '';\n      }\n    }\n    return theme;\n  }\n\n  /**\n   * Gets code-formatted load theme blob that can be copy and pasted.\n   * Only used for the old theme designer, where loadTheme usage is acceptable,\n   * unlike in the new theme designer.\n   */\n  public static getThemeAsCode(slotRules: IThemeRules): any {\n    const output = 'loadTheme({\\n  palette: {\\n';\n    return ThemeGenerator._makeRemainingCode(output, slotRules);\n  }\n\n  /**\n   * Gets code-formatted load theme blob, specifically for the new theme designer,\n   * aka.ms/themedesigner. Shouldn't use loadTheme like the old theme designer since it's deprecated.\n   * We want to use the theme object from createTheme and use the Customizations.applySettings API instead.\n   */\n  public static getThemeAsCodeWithCreateTheme(slotRules: IThemeRules): any {\n    const output = 'const myTheme = createTheme({\\n  palette: {\\n';\n    return ThemeGenerator._makeRemainingCode(output, slotRules);\n  }\n\n  /**\n   * Gets the theme as a list of SASS variables that can be used in code\n   * ```\n   * $tokenName: \"[theme:tokenName, default:#f00f00]\";\n   * $tokenName2: \"[theme:tokenName2, default:#ba2ba2]\";\n   * ...\n   * ```\n   */\n  public static getThemeAsSass(slotRules: IThemeRules): any {\n    const sassVarTemplate = '${0}Color: \"[theme: {1}, default: {2}]\";\\n';\n    let output = '';\n\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        output += format(\n          sassVarTemplate,\n          camelCasedName,\n          camelCasedName,\n          rule.color ? rule.color.str : rule.value || '',\n        );\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Gets the theme formatted for PowerShell scripts\n   * ```\n   * @{\n   * \"tokenName\" = \"#f00f00\";\n   * \"tokenName2\" = \"#ba2ba2\";\n   * ...\n   * }\n   * ```\n   */\n  public static getThemeForPowerShell(slotRules: IThemeRules): any {\n    const psVarTemplate = '\"{0}\" = \"{1}\";\\n';\n    let output = '';\n\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        if (rule.value) {\n          // skip this one, it's not a color\n          continue;\n        }\n        const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        let outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';\n        // powershell endpoint uses the RGBA format\n        if (rule.color && rule.color.a && rule.color.a !== 100) {\n          outputColor += String(rule.color.a.toString(16));\n        }\n        output += format(psVarTemplate, camelCasedName, outputColor);\n      }\n    }\n    return '@{\\n' + output + '}';\n  }\n\n  /**\n   * Sets the given slot's color to the appropriate color, shading it if necessary.\n   * Then, iterates through all other rules (that are this rule's dependents) to update them accordingly.\n   * @param isCustomization - If true, it's a user-provided color, which should be to that raw color.\n   * If false, the rule it's inheriting from changed, so updated using asShade.\n   */\n  private static _setSlot(\n    rule: IThemeSlotRule,\n    color: IColor,\n    isInverted: boolean,\n    isCustomization: boolean,\n    overwriteCustomColor = true,\n  ) {\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor || !rule.color || !rule.isCustomized || !rule.inherits) {\n      // set the rule's color under these conditions\n      if (\n        (overwriteCustomColor || !rule.isCustomized) &&\n        !isCustomization &&\n        rule.inherits &&\n        isValidShade(rule.asShade)\n      ) {\n        // it's inheriting by shade\n        if (rule.isBackgroundShade) {\n          rule.color = getBackgroundShade(color, rule.asShade!, isInverted)!;\n        } else {\n          rule.color = getShade(color, rule.asShade!, isInverted)!;\n        }\n        rule.isCustomized = false;\n      } else {\n        rule.color = color;\n        rule.isCustomized = true;\n      }\n\n      // then update dependent colors\n      for (const ruleToUpdate of rule.dependentRules) {\n        ThemeGenerator._setSlot(ruleToUpdate, rule.color, isInverted, false, overwriteCustomColor);\n      }\n    }\n  }\n\n  /**\n   * Makes the rest of the code that's used for the load theme blob in the exported codepens of\n   * both the older sharepoint-specific theme designer and the new theme designer. Takes in\n   * theme rules and converts them to format fitting a list of palette colors and their values.\n   * Resulting output looks like:\n   * ```\n   * const _theme = createTheme({\n   *  palette: {\n   *    themePrimary: '#0078d4',\n   *    themeLighterAlt: '#f3f9fd',\n   *    ...\n   *  }});\n   * ```\n   * The first line is loadTheme instead of createTheme for the old sharepoint theme designer.\n   */\n  private static _makeRemainingCode(output: string, slotRules: IThemeRules) {\n    const attributeTemplate = \"    {0}: '{1}',\\n\";\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        const outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';\n        output += format(attributeTemplate, camelCasedName, outputColor);\n      }\n    }\n    output += '  }});';\n    return output;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}