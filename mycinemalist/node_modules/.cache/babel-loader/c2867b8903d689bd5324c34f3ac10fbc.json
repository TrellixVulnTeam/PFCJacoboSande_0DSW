{"ast":null,"code":"import { __assign, __extends } from \"tslib\"; // Utilities\n\nimport * as React from 'react';\nimport { classNamesFunction, elementContains, focusFirstChild, getDocument, KeyCodes, shallowCompare, getRTL, warnDeprecations, EventGroup, Async, initializeComponentRef } from '../../Utilities';\nimport { RectangleEdge, getOppositeEdge } from '../../utilities/positioning'; // Component Dependencies\n\nimport { PositioningContainer } from './PositioningContainer/index';\nimport { Beak, BEAK_HEIGHT, BEAK_WIDTH } from './Beak/Beak';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { COACHMARK_HEIGHT, COACHMARK_WIDTH } from './Coachmark.styles';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nvar getClassNames = classNamesFunction();\nexport var COACHMARK_ATTRIBUTE_NAME = 'data-coachmarkid';\nvar COMPONENT_NAME = 'Coachmark';\n\nvar CoachmarkBase =\n/** @class */\nfunction (_super) {\n  __extends(CoachmarkBase, _super);\n\n  function CoachmarkBase(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The cached HTMLElement reference to the Entity Inner Host\n     * element.\n     */\n\n\n    _this._entityHost = React.createRef();\n    _this._entityInnerHostElement = React.createRef();\n    _this._translateAnimationContainer = React.createRef();\n    _this._ariaAlertContainer = React.createRef();\n    _this._childrenContainer = React.createRef();\n    _this._positioningContainer = React.createRef();\n\n    _this.dismiss = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev);\n      }\n    };\n\n    _this._onKeyDown = function (e) {\n      // Open coachmark if user presses ALT + C (arbitrary keypress for now)\n      if (e.altKey && e.which === KeyCodes.c || e.which === KeyCodes.enter && _this._translateAnimationContainer.current && _this._translateAnimationContainer.current.contains(e.target)) {\n        _this._onFocusHandler();\n      }\n    };\n\n    _this._onFocusHandler = function () {\n      if (_this.state.isCollapsed) {\n        _this._openCoachmark();\n      }\n    };\n\n    _this._onPositioned = function (positionData) {\n      _this._async.requestAnimationFrame(function () {\n        _this.setState({\n          targetAlignment: positionData.alignmentEdge,\n          targetPosition: positionData.targetEdge\n        });\n      });\n    };\n\n    _this._setBeakPosition = function () {\n      var beakLeft;\n      var beakTop;\n      var beakRight;\n      var beakBottom;\n      var transformOriginX;\n      var transformOriginY;\n      var targetAlignment = _this.state.targetAlignment;\n      var distanceAdjustment = '3px'; // Adjustment distance for Beak to shift towards Coachmark bubble.\n\n      switch (_this._beakDirection) {\n        // If Beak is pointing Up or Down\n        case RectangleEdge.top:\n        case RectangleEdge.bottom:\n          // If there is no target alignment, then beak is X-axis centered in callout\n          if (!targetAlignment) {\n            beakLeft = \"calc(50% - \" + BEAK_WIDTH / 2 + \"px)\";\n            transformOriginX = 'center';\n          } else {\n            // Beak is aligned to the left of target\n            if (targetAlignment === RectangleEdge.left) {\n              beakLeft = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginX = 'left';\n            } else {\n              // Beak is aligned to the right of target\n              beakRight = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginX = 'right';\n            }\n          }\n\n          if (_this._beakDirection === RectangleEdge.top) {\n            beakTop = distanceAdjustment;\n            transformOriginY = 'top';\n          } else {\n            beakBottom = distanceAdjustment;\n            transformOriginY = 'bottom';\n          }\n\n          break;\n        // If Beak is pointing Left or Right\n\n        case RectangleEdge.left:\n        case RectangleEdge.right:\n          // If there is no target alignment, then beak is Y-axis centered in callout\n          if (!targetAlignment) {\n            beakTop = \"calc(50% - \" + BEAK_WIDTH / 2 + \"px)\";\n            transformOriginY = \"center\";\n          } else {\n            // Beak is aligned to the top of target\n            if (targetAlignment === RectangleEdge.top) {\n              beakTop = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginY = \"top\";\n            } else {\n              // Beak is aligned to the bottom of target\n              beakBottom = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginY = \"bottom\";\n            }\n          }\n\n          if (_this._beakDirection === RectangleEdge.left) {\n            if (getRTL(_this.props.theme)) {\n              beakRight = distanceAdjustment;\n            } else {\n              beakLeft = distanceAdjustment;\n            }\n\n            transformOriginX = 'left';\n          } else {\n            if (getRTL(_this.props.theme)) {\n              beakLeft = distanceAdjustment;\n            } else {\n              beakRight = distanceAdjustment;\n            }\n\n            transformOriginX = 'right';\n          }\n\n          break;\n      }\n\n      _this.setState({\n        beakLeft: beakLeft,\n        beakRight: beakRight,\n        beakBottom: beakBottom,\n        beakTop: beakTop,\n        transformOrigin: transformOriginX + \" \" + transformOriginY\n      });\n    };\n\n    _this._openCoachmark = function () {\n      _this.setState({\n        isCollapsed: false\n      });\n\n      if (_this.props.onAnimationOpenStart) {\n        _this.props.onAnimationOpenStart();\n      }\n\n      _this._entityInnerHostElement.current && _this._entityInnerHostElement.current.addEventListener('transitionend', function () {\n        // Need setTimeout to trigger narrator\n        _this._async.setTimeout(function () {\n          if (_this._entityInnerHostElement.current) {\n            focusFirstChild(_this._entityInnerHostElement.current);\n          }\n        }, 1000);\n\n        if (_this.props.onAnimationOpenEnd) {\n          _this.props.onAnimationOpenEnd();\n        }\n      });\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      teachingBubbleRef: undefined,\n      collapsed: 'isCollapsed',\n      beakWidth: undefined,\n      beakHeight: undefined,\n      width: undefined,\n      height: undefined\n    }); // Set defaults for state\n\n    _this.state = {\n      isCollapsed: props.isCollapsed,\n      isBeaconAnimating: true,\n      isMeasuring: true,\n      entityInnerHostRect: {\n        width: 0,\n        height: 0\n      },\n      isMouseInProximity: false,\n      isMeasured: false\n    };\n    return _this;\n  }\n\n  Object.defineProperty(CoachmarkBase.prototype, \"_beakDirection\", {\n    get: function get() {\n      var targetPosition = this.state.targetPosition;\n\n      if (targetPosition === undefined) {\n        return RectangleEdge.bottom;\n      }\n\n      return getOppositeEdge(targetPosition);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CoachmarkBase.prototype.render = function () {\n    var _a = this.props,\n        beaconColorOne = _a.beaconColorOne,\n        beaconColorTwo = _a.beaconColorTwo,\n        children = _a.children,\n        target = _a.target,\n        color = _a.color,\n        positioningContainerProps = _a.positioningContainerProps,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        ariaDescribedByText = _a.ariaDescribedByText,\n        ariaLabelledBy = _a.ariaLabelledBy,\n        ariaLabelledByText = _a.ariaLabelledByText,\n        ariaAlertText = _a.ariaAlertText,\n        delayBeforeCoachmarkAnimation = _a.delayBeforeCoachmarkAnimation,\n        styles = _a.styles,\n        theme = _a.theme,\n        className = _a.className,\n        persistentBeak = _a.persistentBeak;\n    var _b = this.state,\n        beakLeft = _b.beakLeft,\n        beakTop = _b.beakTop,\n        beakRight = _b.beakRight,\n        beakBottom = _b.beakBottom,\n        isCollapsed = _b.isCollapsed,\n        isBeaconAnimating = _b.isBeaconAnimating,\n        isMeasuring = _b.isMeasuring,\n        entityInnerHostRect = _b.entityInnerHostRect,\n        transformOrigin = _b.transformOrigin,\n        alertText = _b.alertText,\n        isMeasured = _b.isMeasured; // Defaulting the main background before passing it to the styles because it is used for `Beak` too.\n\n    var defaultColor = color;\n\n    if (!defaultColor && theme) {\n      defaultColor = theme.semanticColors.primaryButtonBackground;\n    }\n\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      beaconColorOne: beaconColorOne,\n      beaconColorTwo: beaconColorTwo,\n      className: className,\n      isCollapsed: isCollapsed,\n      isBeaconAnimating: isBeaconAnimating,\n      isMeasuring: isMeasuring,\n      color: defaultColor,\n      transformOrigin: transformOrigin,\n      isMeasured: isMeasured,\n      entityHostHeight: entityInnerHostRect.height + \"px\",\n      entityHostWidth: entityInnerHostRect.width + \"px\",\n      width: COACHMARK_WIDTH + \"px\",\n      height: COACHMARK_HEIGHT + \"px\",\n      delayBeforeCoachmarkAnimation: delayBeforeCoachmarkAnimation + \"ms\"\n    });\n    var finalHeight = isCollapsed ? COACHMARK_HEIGHT : entityInnerHostRect.height;\n    return React.createElement(PositioningContainer, __assign({\n      target: target,\n      offsetFromTarget: BEAK_HEIGHT,\n      componentRef: this._positioningContainer,\n      finalHeight: finalHeight,\n      onPositioned: this._onPositioned,\n      bounds: this._getBounds()\n    }, positioningContainerProps), React.createElement(\"div\", {\n      className: classNames.root\n    }, ariaAlertText && React.createElement(\"div\", {\n      className: classNames.ariaContainer,\n      role: \"alert\",\n      ref: this._ariaAlertContainer,\n      \"aria-hidden\": !isCollapsed\n    }, alertText), React.createElement(\"div\", {\n      className: classNames.pulsingBeacon\n    }), React.createElement(\"div\", {\n      className: classNames.translateAnimationContainer,\n      ref: this._translateAnimationContainer\n    }, React.createElement(\"div\", {\n      className: classNames.scaleAnimationLayer\n    }, React.createElement(\"div\", {\n      className: classNames.rotateAnimationLayer\n    }, this._positioningContainer.current && (isCollapsed || persistentBeak) && React.createElement(Beak, {\n      left: beakLeft,\n      top: beakTop,\n      right: beakRight,\n      bottom: beakBottom,\n      direction: this._beakDirection,\n      color: defaultColor\n    }), React.createElement(\"div\", {\n      className: classNames.entityHost,\n      ref: this._entityHost,\n      tabIndex: -1,\n      \"data-is-focusable\": true,\n      role: \"dialog\",\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy\n    }, isCollapsed && [ariaLabelledBy && React.createElement(\"p\", {\n      id: ariaLabelledBy,\n      key: 0,\n      className: classNames.ariaContainer\n    }, ariaLabelledByText), ariaDescribedBy && React.createElement(\"p\", {\n      id: ariaDescribedBy,\n      key: 1,\n      className: classNames.ariaContainer\n    }, ariaDescribedByText)], React.createElement(FocusTrapZone, {\n      isClickableOutsideFocusTrap: true,\n      forceFocusInsideTrap: false\n    }, React.createElement(\"div\", {\n      className: classNames.entityInnerHost,\n      ref: this._entityInnerHostElement\n    }, React.createElement(\"div\", {\n      className: classNames.childrenContainer,\n      ref: this._childrenContainer,\n      \"aria-hidden\": isCollapsed\n    }, children)))))))));\n  };\n\n  CoachmarkBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (this.props.isCollapsed && !newProps.isCollapsed) {\n      // The coachmark is about to open\n      this._openCoachmark();\n    }\n  };\n\n  CoachmarkBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    return !shallowCompare(newProps, this.props) || !shallowCompare(newState, this.state);\n  };\n\n  CoachmarkBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevState.targetAlignment !== this.state.targetAlignment || prevState.targetPosition !== this.state.targetPosition) {\n      this._setBeakPosition();\n    }\n\n    if (prevProps.preventDismissOnLostFocus !== this.props.preventDismissOnLostFocus) {\n      this._addListeners();\n    }\n  };\n\n  CoachmarkBase.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      if (_this._entityInnerHostElement.current && _this.state.entityInnerHostRect.width + _this.state.entityInnerHostRect.width === 0) {\n        _this.setState({\n          isMeasuring: false,\n          entityInnerHostRect: {\n            width: _this._entityInnerHostElement.current.offsetWidth,\n            height: _this._entityInnerHostElement.current.offsetHeight\n          },\n          isMeasured: true\n        });\n\n        _this._setBeakPosition();\n\n        _this.forceUpdate();\n      }\n\n      _this._addListeners(); // We don't want to the user to immediately trigger the Coachmark when it's opened\n\n\n      _this._async.setTimeout(function () {\n        _this._addProximityHandler(_this.props.mouseProximityOffset);\n      }, _this.props.delayBeforeMouseOpen); // Need to add setTimeout to have narrator read change in alert container\n\n\n      if (_this.props.ariaAlertText) {\n        _this._async.setTimeout(function () {\n          if (_this.props.ariaAlertText && _this._ariaAlertContainer.current) {\n            _this.setState({\n              alertText: _this.props.ariaAlertText\n            });\n          }\n        }, 0);\n      }\n\n      if (!_this.props.preventFocusOnMount) {\n        _this._async.setTimeout(function () {\n          if (_this._entityHost.current) {\n            _this._entityHost.current.focus();\n          }\n        }, 1000);\n      }\n    });\n  };\n\n  CoachmarkBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  CoachmarkBase.prototype._addListeners = function () {\n    var preventDismissOnLostFocus = this.props.preventDismissOnLostFocus;\n    var currentDoc = getDocument();\n\n    this._events.off();\n\n    if (currentDoc) {\n      this._events.on(currentDoc, 'keydown', this._onKeyDown, true);\n\n      if (!preventDismissOnLostFocus) {\n        this._events.on(currentDoc, 'click', this._dismissOnLostFocus, true);\n\n        this._events.on(currentDoc, 'focus', this._dismissOnLostFocus, true);\n      }\n    }\n  };\n\n  CoachmarkBase.prototype._dismissOnLostFocus = function (ev) {\n    var clickTarget = ev.target;\n    var clickedOutsideCallout = this._translateAnimationContainer.current && !elementContains(this._translateAnimationContainer.current, clickTarget);\n    var target = this.props.target;\n\n    if (clickedOutsideCallout && clickTarget !== target && !elementContains(target, clickTarget)) {\n      this.dismiss(ev);\n    }\n  };\n\n  CoachmarkBase.prototype._getBounds = function () {\n    var _a = this.props,\n        isPositionForced = _a.isPositionForced,\n        positioningContainerProps = _a.positioningContainerProps;\n\n    if (isPositionForced) {\n      // If directionalHint direction is the top or bottom auto edge, then we want to set the left/right bounds\n      // to the window x-axis to have auto positioning work correctly.\n      if (positioningContainerProps && (positioningContainerProps.directionalHint === DirectionalHint.topAutoEdge || positioningContainerProps.directionalHint === DirectionalHint.bottomAutoEdge)) {\n        return {\n          left: 0,\n          top: -Infinity,\n          bottom: Infinity,\n          right: window.innerWidth,\n          width: window.innerWidth,\n          height: Infinity\n        };\n      } else {\n        return {\n          left: -Infinity,\n          top: -Infinity,\n          bottom: Infinity,\n          right: Infinity,\n          width: Infinity,\n          height: Infinity\n        };\n      }\n    } else {\n      return undefined;\n    }\n  };\n\n  CoachmarkBase.prototype._addProximityHandler = function (mouseProximityOffset) {\n    var _this = this;\n\n    if (mouseProximityOffset === void 0) {\n      mouseProximityOffset = 0;\n    }\n    /**\n     * An array of cached ids returned when setTimeout runs during\n     * the window resize event trigger.\n     */\n\n\n    var timeoutIds = []; // Take the initial measure out of the initial render to prevent\n    // an unnecessary render.\n\n    this._async.setTimeout(function () {\n      _this._setTargetElementRect(); // When the window resizes we want to async\n      // get the bounding client rectangle.\n      // Every time the event is triggered we want to\n      // setTimeout and then clear any previous instances\n      // of setTimeout.\n\n\n      _this._events.on(window, 'resize', function () {\n        timeoutIds.forEach(function (value) {\n          clearInterval(value);\n        });\n        timeoutIds.push(_this._async.setTimeout(function () {\n          _this._setTargetElementRect();\n        }, 100));\n      });\n    }, 10); // Every time the document's mouse move is triggered\n    // we want to check if inside of an element and\n    // set the state with the result.\n\n\n    this._events.on(document, 'mousemove', function (e) {\n      if (_this.state.isCollapsed) {\n        var mouseY = e.clientY;\n        var mouseX = e.clientX;\n\n        _this._setTargetElementRect();\n\n        var isMouseInProximity = _this._isInsideElement(mouseX, mouseY, mouseProximityOffset);\n\n        if (isMouseInProximity !== _this.state.isMouseInProximity) {\n          _this._openCoachmark();\n        }\n      }\n\n      if (_this.props.onMouseMove) {\n        _this.props.onMouseMove(e);\n      }\n    });\n  };\n\n  CoachmarkBase.prototype._setTargetElementRect = function () {\n    if (this._translateAnimationContainer && this._translateAnimationContainer.current) {\n      this._targetElementRect = this._translateAnimationContainer.current.getBoundingClientRect();\n    }\n  };\n\n  CoachmarkBase.prototype._isInsideElement = function (mouseX, mouseY, mouseProximityOffset) {\n    if (mouseProximityOffset === void 0) {\n      mouseProximityOffset = 0;\n    }\n\n    return mouseX > this._targetElementRect.left - mouseProximityOffset && mouseX < this._targetElementRect.left + this._targetElementRect.width + mouseProximityOffset && mouseY > this._targetElementRect.top - mouseProximityOffset && mouseY < this._targetElementRect.top + this._targetElementRect.height + mouseProximityOffset;\n  };\n\n  CoachmarkBase.defaultProps = {\n    isCollapsed: true,\n    mouseProximityOffset: 10,\n    delayBeforeMouseOpen: 3600,\n    delayBeforeCoachmarkAnimation: 0,\n    isPositionForced: true,\n    positioningContainerProps: {\n      directionalHint: DirectionalHint.bottomAutoEdge\n    }\n  };\n  return CoachmarkBase;\n}(React.Component);\n\nexport { CoachmarkBase };","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","elementContains","focusFirstChild","getDocument","KeyCodes","shallowCompare","getRTL","warnDeprecations","EventGroup","Async","initializeComponentRef","RectangleEdge","getOppositeEdge","PositioningContainer","Beak","BEAK_HEIGHT","BEAK_WIDTH","DirectionalHint","COACHMARK_HEIGHT","COACHMARK_WIDTH","FocusTrapZone","getClassNames","COACHMARK_ATTRIBUTE_NAME","COMPONENT_NAME","__extends","props","_super","_this","createRef","ev","onDismiss","e","altKey","which","c","enter","_translateAnimationContainer","current","contains","target","_onFocusHandler","state","isCollapsed","_openCoachmark","positionData","_async","requestAnimationFrame","setState","targetAlignment","alignmentEdge","targetPosition","targetEdge","beakLeft","beakTop","beakRight","beakBottom","transformOriginX","transformOriginY","distanceAdjustment","_beakDirection","top","bottom","left","right","theme","transformOrigin","onAnimationOpenStart","_entityInnerHostElement","addEventListener","setTimeout","onAnimationOpenEnd","_events","teachingBubbleRef","undefined","collapsed","beakWidth","beakHeight","width","height","isBeaconAnimating","isMeasuring","entityInnerHostRect","isMouseInProximity","isMeasured","Object","CoachmarkBase","beaconColorOne","beaconColorTwo","children","color","positioningContainerProps","ariaDescribedBy","ariaDescribedByText","ariaLabelledBy","ariaLabelledByText","ariaAlertText","delayBeforeCoachmarkAnimation","styles","className","persistentBeak","alertText","defaultColor","semanticColors","primaryButtonBackground","classNames","entityHostHeight","entityHostWidth","finalHeight","__assign","offsetFromTarget","componentRef","_positioningContainer","onPositioned","_onPositioned","bounds","_getBounds","root","ariaContainer","role","ref","_ariaAlertContainer","pulsingBeacon","translateAnimationContainer","scaleAnimationLayer","rotateAnimationLayer","direction","entityHost","_entityHost","tabIndex","id","key","isClickableOutsideFocusTrap","forceFocusInsideTrap","entityInnerHost","childrenContainer","_childrenContainer","newProps","newState","prevProps","prevState","_setBeakPosition","preventDismissOnLostFocus","_addListeners","offsetWidth","offsetHeight","forceUpdate","_addProximityHandler","mouseProximityOffset","delayBeforeMouseOpen","preventFocusOnMount","focus","dispose","currentDoc","off","on","_onKeyDown","_dismissOnLostFocus","clickTarget","clickedOutsideCallout","dismiss","isPositionForced","directionalHint","topAutoEdge","bottomAutoEdge","Infinity","window","innerWidth","timeoutIds","_setTargetElementRect","forEach","value","clearInterval","push","document","mouseY","clientY","mouseX","clientX","_isInsideElement","onMouseMove","_targetElementRect","getBoundingClientRect","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\Coachmark\\Coachmark.base.tsx"],"sourcesContent":["// Utilities\nimport * as React from 'react';\nimport {\n  classNamesFunction,\n  elementContains,\n  focusFirstChild,\n  getDocument,\n  IRectangle,\n  KeyCodes,\n  shallowCompare,\n  getRTL,\n  warnDeprecations,\n  EventGroup,\n  Async,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { IPositionedData, RectangleEdge, getOppositeEdge } from '../../utilities/positioning';\n\n// Component Dependencies\nimport { PositioningContainer, IPositioningContainer } from './PositioningContainer/index';\nimport { Beak, BEAK_HEIGHT, BEAK_WIDTH } from './Beak/Beak';\nimport { DirectionalHint } from '../../common/DirectionalHint';\n\n// Coachmark\nimport { ICoachmark, ICoachmarkProps, ICoachmarkStyles, ICoachmarkStyleProps } from './Coachmark.types';\nimport { COACHMARK_HEIGHT, COACHMARK_WIDTH } from './Coachmark.styles';\nimport { FocusTrapZone } from '../../FocusTrapZone';\n\nconst getClassNames = classNamesFunction<ICoachmarkStyleProps, ICoachmarkStyles>();\n\nexport const COACHMARK_ATTRIBUTE_NAME = 'data-coachmarkid';\n\n/**\n * An interface for the cached dimensions of entity inner host.\n */\nexport interface IEntityRect {\n  width: number;\n  height: number;\n}\n\nexport interface ICoachmarkState {\n  /**\n   * Is the Coachmark currently collapsed into\n   * a tear drop shape\n   */\n  isCollapsed: boolean;\n\n  /**\n   * Enables/Disables the beacon that radiates\n   * from the center of the coachmark.\n   */\n  isBeaconAnimating: boolean;\n\n  /**\n   * Is the teaching bubble currently retreiving the\n   * original dimensions of the hosted entity.\n   */\n  isMeasuring: boolean;\n\n  /**\n   * Is the Coachmark done measuring the hosted entity\n   */\n  isMeasured: boolean;\n\n  /**\n   * Cached width and height of _entityInnerHostElement\n   */\n  entityInnerHostRect: IEntityRect;\n\n  /**\n   * Is the mouse in proximity of the default target element\n   */\n  isMouseInProximity: boolean;\n\n  /**\n   * The left position of the beak\n   */\n  beakLeft?: string;\n\n  /**\n   * The right position of the beak\n   */\n  beakTop?: string;\n\n  /**\n   * The right position of the beak\n   */\n  beakRight?: string;\n\n  /**\n   * The bottom position of the beak\n   */\n  beakBottom?: string;\n\n  /**\n   * Alignment edge of callout in relation to target\n   */\n  targetAlignment?: RectangleEdge;\n\n  /**\n   * Position of Coachmark/TeachingBubble in relation to target\n   */\n  targetPosition?: RectangleEdge;\n\n  /**\n   * Transform origin of teaching bubble callout\n   */\n  transformOrigin?: string;\n\n  /**\n   * ARIA alert text to read aloud with Narrator once the Coachmark is mounted\n   */\n  alertText?: string;\n}\n\nconst COMPONENT_NAME = 'Coachmark';\n\nexport class CoachmarkBase extends React.Component<ICoachmarkProps, ICoachmarkState> implements ICoachmark {\n  public static defaultProps: Partial<ICoachmarkProps> = {\n    isCollapsed: true,\n    mouseProximityOffset: 10,\n    delayBeforeMouseOpen: 3600, // The approximate time the coachmark shows up\n    delayBeforeCoachmarkAnimation: 0,\n    isPositionForced: true,\n    positioningContainerProps: {\n      directionalHint: DirectionalHint.bottomAutoEdge,\n    },\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  /**\n   * The cached HTMLElement reference to the Entity Inner Host\n   * element.\n   */\n  private _entityHost = React.createRef<HTMLDivElement>();\n  private _entityInnerHostElement = React.createRef<HTMLDivElement>();\n  private _translateAnimationContainer = React.createRef<HTMLDivElement>();\n  private _ariaAlertContainer = React.createRef<HTMLDivElement>();\n  private _childrenContainer = React.createRef<HTMLDivElement>();\n  private _positioningContainer = React.createRef<IPositioningContainer>();\n\n  /**\n   * The target element the mouse would be in\n   * proximity to\n   */\n  private _targetElementRect: ClientRect;\n\n  constructor(props: ICoachmarkProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      teachingBubbleRef: undefined,\n      collapsed: 'isCollapsed',\n      beakWidth: undefined,\n      beakHeight: undefined,\n      width: undefined,\n      height: undefined,\n    });\n\n    // Set defaults for state\n    this.state = {\n      isCollapsed: props.isCollapsed!,\n      isBeaconAnimating: true,\n      isMeasuring: true,\n      entityInnerHostRect: {\n        width: 0,\n        height: 0,\n      },\n      isMouseInProximity: false,\n      isMeasured: false,\n    };\n  }\n\n  private get _beakDirection(): RectangleEdge {\n    const { targetPosition } = this.state;\n    if (targetPosition === undefined) {\n      return RectangleEdge.bottom;\n    }\n\n    return getOppositeEdge(targetPosition);\n  }\n\n  public render(): JSX.Element {\n    const {\n      beaconColorOne,\n      beaconColorTwo,\n      children,\n      target,\n      color,\n      positioningContainerProps,\n      ariaDescribedBy,\n      ariaDescribedByText,\n      ariaLabelledBy,\n      ariaLabelledByText,\n      ariaAlertText,\n      delayBeforeCoachmarkAnimation,\n      styles,\n      theme,\n      className,\n      persistentBeak,\n    } = this.props;\n\n    const {\n      beakLeft,\n      beakTop,\n      beakRight,\n      beakBottom,\n      isCollapsed,\n      isBeaconAnimating,\n      isMeasuring,\n      entityInnerHostRect,\n      transformOrigin,\n      alertText,\n      isMeasured,\n    } = this.state;\n\n    // Defaulting the main background before passing it to the styles because it is used for `Beak` too.\n    let defaultColor = color;\n    if (!defaultColor && theme) {\n      defaultColor = theme.semanticColors.primaryButtonBackground;\n    }\n\n    const classNames = getClassNames(styles, {\n      theme,\n      beaconColorOne,\n      beaconColorTwo,\n      className,\n      isCollapsed,\n      isBeaconAnimating,\n      isMeasuring,\n      color: defaultColor,\n      transformOrigin,\n      isMeasured,\n      entityHostHeight: `${entityInnerHostRect.height}px`,\n      entityHostWidth: `${entityInnerHostRect.width}px`,\n      width: `${COACHMARK_WIDTH}px`,\n      height: `${COACHMARK_HEIGHT}px`,\n      delayBeforeCoachmarkAnimation: `${delayBeforeCoachmarkAnimation}ms`,\n    });\n\n    const finalHeight: number = isCollapsed ? COACHMARK_HEIGHT : entityInnerHostRect.height;\n\n    return (\n      <PositioningContainer\n        target={target}\n        offsetFromTarget={BEAK_HEIGHT}\n        componentRef={this._positioningContainer}\n        finalHeight={finalHeight}\n        onPositioned={this._onPositioned}\n        bounds={this._getBounds()}\n        {...positioningContainerProps}\n      >\n        <div className={classNames.root}>\n          {ariaAlertText && (\n            <div\n              className={classNames.ariaContainer}\n              role=\"alert\"\n              ref={this._ariaAlertContainer}\n              aria-hidden={!isCollapsed}\n            >\n              {alertText}\n            </div>\n          )}\n          <div className={classNames.pulsingBeacon} />\n          <div className={classNames.translateAnimationContainer} ref={this._translateAnimationContainer}>\n            <div className={classNames.scaleAnimationLayer}>\n              <div className={classNames.rotateAnimationLayer}>\n                {this._positioningContainer.current && (isCollapsed || persistentBeak) && (\n                  <Beak\n                    left={beakLeft}\n                    top={beakTop}\n                    right={beakRight}\n                    bottom={beakBottom}\n                    direction={this._beakDirection}\n                    color={defaultColor}\n                  />\n                )}\n                <div\n                  className={classNames.entityHost}\n                  ref={this._entityHost}\n                  tabIndex={-1}\n                  data-is-focusable={true}\n                  role=\"dialog\"\n                  aria-labelledby={ariaLabelledBy}\n                  aria-describedby={ariaDescribedBy}\n                >\n                  {isCollapsed && [\n                    ariaLabelledBy && (\n                      <p id={ariaLabelledBy} key={0} className={classNames.ariaContainer}>\n                        {ariaLabelledByText}\n                      </p>\n                    ),\n                    ariaDescribedBy && (\n                      <p id={ariaDescribedBy} key={1} className={classNames.ariaContainer}>\n                        {ariaDescribedByText}\n                      </p>\n                    ),\n                  ]}\n                  <FocusTrapZone isClickableOutsideFocusTrap={true} forceFocusInsideTrap={false}>\n                    <div className={classNames.entityInnerHost} ref={this._entityInnerHostElement}>\n                      <div\n                        className={classNames.childrenContainer}\n                        ref={this._childrenContainer}\n                        aria-hidden={isCollapsed}\n                      >\n                        {children}\n                      </div>\n                    </div>\n                  </FocusTrapZone>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </PositioningContainer>\n    );\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: ICoachmarkProps): void {\n    if (this.props.isCollapsed && !newProps.isCollapsed) {\n      // The coachmark is about to open\n      this._openCoachmark();\n    }\n  }\n\n  public shouldComponentUpdate(newProps: ICoachmarkProps, newState: ICoachmarkState): boolean {\n    return !shallowCompare(newProps, this.props) || !shallowCompare(newState, this.state);\n  }\n\n  public componentDidUpdate(prevProps: ICoachmarkProps, prevState: ICoachmarkState): void {\n    if (\n      prevState.targetAlignment !== this.state.targetAlignment ||\n      prevState.targetPosition !== this.state.targetPosition\n    ) {\n      this._setBeakPosition();\n    }\n    if (prevProps.preventDismissOnLostFocus !== this.props.preventDismissOnLostFocus) {\n      this._addListeners();\n    }\n  }\n\n  public componentDidMount(): void {\n    this._async.requestAnimationFrame((): void => {\n      if (\n        this._entityInnerHostElement.current &&\n        this.state.entityInnerHostRect.width + this.state.entityInnerHostRect.width === 0\n      ) {\n        this.setState({\n          isMeasuring: false,\n          entityInnerHostRect: {\n            width: this._entityInnerHostElement.current.offsetWidth,\n            height: this._entityInnerHostElement.current.offsetHeight,\n          },\n          isMeasured: true,\n        });\n        this._setBeakPosition();\n        this.forceUpdate();\n      }\n\n      this._addListeners();\n\n      // We don't want to the user to immediately trigger the Coachmark when it's opened\n      this._async.setTimeout(() => {\n        this._addProximityHandler(this.props.mouseProximityOffset);\n      }, this.props.delayBeforeMouseOpen!);\n\n      // Need to add setTimeout to have narrator read change in alert container\n      if (this.props.ariaAlertText) {\n        this._async.setTimeout(() => {\n          if (this.props.ariaAlertText && this._ariaAlertContainer.current) {\n            this.setState({\n              alertText: this.props.ariaAlertText,\n            });\n          }\n        }, 0);\n      }\n\n      if (!this.props.preventFocusOnMount) {\n        this._async.setTimeout(() => {\n          if (this._entityHost.current) {\n            this._entityHost.current.focus();\n          }\n        }, 1000);\n      }\n    });\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev);\n    }\n  };\n\n  private _addListeners(): void {\n    const { preventDismissOnLostFocus } = this.props;\n    const currentDoc: Document = getDocument()!;\n\n    this._events.off();\n\n    if (currentDoc) {\n      this._events.on(currentDoc, 'keydown', this._onKeyDown, true);\n\n      if (!preventDismissOnLostFocus) {\n        this._events.on(currentDoc, 'click', this._dismissOnLostFocus, true);\n        this._events.on(currentDoc, 'focus', this._dismissOnLostFocus, true);\n      }\n    }\n  }\n\n  private _dismissOnLostFocus(ev: Event) {\n    const clickTarget = ev.target as HTMLElement;\n    const clickedOutsideCallout =\n      this._translateAnimationContainer.current &&\n      !elementContains(this._translateAnimationContainer.current, clickTarget);\n    const { target } = this.props;\n\n    if (clickedOutsideCallout && clickTarget !== target && !elementContains(target as HTMLElement, clickTarget)) {\n      this.dismiss(ev);\n    }\n  }\n\n  private _onKeyDown = (e: any): void => {\n    // Open coachmark if user presses ALT + C (arbitrary keypress for now)\n    if (\n      (e.altKey && e.which === KeyCodes.c) ||\n      (e.which === KeyCodes.enter &&\n        this._translateAnimationContainer.current &&\n        this._translateAnimationContainer.current.contains(e.target))\n    ) {\n      this._onFocusHandler();\n    }\n  };\n\n  private _onFocusHandler = (): void => {\n    if (this.state.isCollapsed) {\n      this._openCoachmark();\n    }\n  };\n\n  private _onPositioned = (positionData: IPositionedData): void => {\n    this._async.requestAnimationFrame((): void => {\n      this.setState({\n        targetAlignment: positionData.alignmentEdge,\n        targetPosition: positionData.targetEdge,\n      });\n    });\n  };\n\n  private _getBounds(): IRectangle | undefined {\n    const { isPositionForced, positioningContainerProps } = this.props;\n    if (isPositionForced) {\n      // If directionalHint direction is the top or bottom auto edge, then we want to set the left/right bounds\n      // to the window x-axis to have auto positioning work correctly.\n      if (\n        positioningContainerProps &&\n        (positioningContainerProps.directionalHint === DirectionalHint.topAutoEdge ||\n          positioningContainerProps.directionalHint === DirectionalHint.bottomAutoEdge)\n      ) {\n        return {\n          left: 0,\n          top: -Infinity,\n          bottom: Infinity,\n          right: window.innerWidth,\n          width: window.innerWidth,\n          height: Infinity,\n        };\n      } else {\n        return {\n          left: -Infinity,\n          top: -Infinity,\n          bottom: Infinity,\n          right: Infinity,\n          width: Infinity,\n          height: Infinity,\n        };\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  private _setBeakPosition = (): void => {\n    let beakLeft;\n    let beakTop;\n    let beakRight;\n    let beakBottom;\n    let transformOriginX;\n    let transformOriginY;\n\n    const { targetAlignment } = this.state;\n    const distanceAdjustment = '3px'; // Adjustment distance for Beak to shift towards Coachmark bubble.\n\n    switch (this._beakDirection) {\n      // If Beak is pointing Up or Down\n      case RectangleEdge.top:\n      case RectangleEdge.bottom:\n        // If there is no target alignment, then beak is X-axis centered in callout\n        if (!targetAlignment) {\n          beakLeft = `calc(50% - ${BEAK_WIDTH / 2}px)`;\n          transformOriginX = 'center';\n        } else {\n          // Beak is aligned to the left of target\n          if (targetAlignment === RectangleEdge.left) {\n            beakLeft = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginX = 'left';\n          } else {\n            // Beak is aligned to the right of target\n            beakRight = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginX = 'right';\n          }\n        }\n\n        if (this._beakDirection === RectangleEdge.top) {\n          beakTop = distanceAdjustment;\n          transformOriginY = 'top';\n        } else {\n          beakBottom = distanceAdjustment;\n          transformOriginY = 'bottom';\n        }\n        break;\n      // If Beak is pointing Left or Right\n      case RectangleEdge.left:\n      case RectangleEdge.right:\n        // If there is no target alignment, then beak is Y-axis centered in callout\n        if (!targetAlignment) {\n          beakTop = `calc(50% - ${BEAK_WIDTH / 2}px)`;\n          transformOriginY = `center`;\n        } else {\n          // Beak is aligned to the top of target\n          if (targetAlignment === RectangleEdge.top) {\n            beakTop = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginY = `top`;\n          } else {\n            // Beak is aligned to the bottom of target\n            beakBottom = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginY = `bottom`;\n          }\n        }\n\n        if (this._beakDirection === RectangleEdge.left) {\n          if (getRTL(this.props.theme)) {\n            beakRight = distanceAdjustment;\n          } else {\n            beakLeft = distanceAdjustment;\n          }\n          transformOriginX = 'left';\n        } else {\n          if (getRTL(this.props.theme)) {\n            beakLeft = distanceAdjustment;\n          } else {\n            beakRight = distanceAdjustment;\n          }\n          transformOriginX = 'right';\n        }\n        break;\n    }\n\n    this.setState({\n      beakLeft: beakLeft,\n      beakRight: beakRight,\n      beakBottom: beakBottom,\n      beakTop: beakTop,\n      transformOrigin: `${transformOriginX} ${transformOriginY}`,\n    });\n  };\n\n  private _openCoachmark = (): void => {\n    this.setState({\n      isCollapsed: false,\n    });\n\n    if (this.props.onAnimationOpenStart) {\n      this.props.onAnimationOpenStart();\n    }\n\n    this._entityInnerHostElement.current &&\n      this._entityInnerHostElement.current.addEventListener('transitionend', (): void => {\n        // Need setTimeout to trigger narrator\n        this._async.setTimeout(() => {\n          if (this._entityInnerHostElement.current) {\n            focusFirstChild(this._entityInnerHostElement.current);\n          }\n        }, 1000);\n\n        if (this.props.onAnimationOpenEnd) {\n          this.props.onAnimationOpenEnd();\n        }\n      });\n  };\n\n  private _addProximityHandler(mouseProximityOffset: number = 0): void {\n    /**\n     * An array of cached ids returned when setTimeout runs during\n     * the window resize event trigger.\n     */\n    const timeoutIds: number[] = [];\n\n    // Take the initial measure out of the initial render to prevent\n    // an unnecessary render.\n    this._async.setTimeout(() => {\n      this._setTargetElementRect();\n\n      // When the window resizes we want to async\n      // get the bounding client rectangle.\n      // Every time the event is triggered we want to\n      // setTimeout and then clear any previous instances\n      // of setTimeout.\n      this._events.on(window, 'resize', (): void => {\n        timeoutIds.forEach((value: number): void => {\n          clearInterval(value);\n        });\n\n        timeoutIds.push(\n          this._async.setTimeout((): void => {\n            this._setTargetElementRect();\n          }, 100),\n        );\n      });\n    }, 10);\n\n    // Every time the document's mouse move is triggered\n    // we want to check if inside of an element and\n    // set the state with the result.\n    this._events.on(document, 'mousemove', (e: MouseEvent) => {\n      if (this.state.isCollapsed) {\n        const mouseY = e.clientY;\n        const mouseX = e.clientX;\n        this._setTargetElementRect();\n        const isMouseInProximity = this._isInsideElement(mouseX, mouseY, mouseProximityOffset);\n\n        if (isMouseInProximity !== this.state.isMouseInProximity) {\n          this._openCoachmark();\n        }\n      }\n\n      if (this.props.onMouseMove) {\n        this.props.onMouseMove(e);\n      }\n    });\n  }\n\n  private _setTargetElementRect(): void {\n    if (this._translateAnimationContainer && this._translateAnimationContainer.current) {\n      this._targetElementRect = this._translateAnimationContainer!.current!.getBoundingClientRect();\n    }\n  }\n\n  private _isInsideElement(mouseX: number, mouseY: number, mouseProximityOffset: number = 0): boolean {\n    return (\n      mouseX > this._targetElementRect.left - mouseProximityOffset &&\n      mouseX < this._targetElementRect.left + this._targetElementRect.width + mouseProximityOffset &&\n      mouseY > this._targetElementRect.top - mouseProximityOffset &&\n      mouseY < this._targetElementRect.top + this._targetElementRect.height + mouseProximityOffset\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}