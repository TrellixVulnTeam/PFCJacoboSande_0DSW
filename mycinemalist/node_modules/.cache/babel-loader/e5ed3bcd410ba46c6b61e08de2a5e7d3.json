{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { buttonProperties, getNativeProps, KeyCodes, mergeAriaAttributeValues, memoizeFunction, Async, EventGroup, getId } from '../../../Utilities';\nimport { ContextualMenuItem } from '../ContextualMenuItem';\nimport { getSplitButtonVerticalDividerClassNames } from '../ContextualMenu.classNames';\nimport { KeytipData } from '../../../KeytipData';\nimport { isItemDisabled, hasSubmenu, getMenuItemAriaRole } from '../../../utilities/contextualMenu/index';\nimport { VerticalDivider } from '../../../Divider';\nimport { ContextualMenuItemWrapper } from './ContextualMenuItemWrapper';\nvar TouchIdleDelay = 500;\n/* ms */\n\nvar ContextualMenuSplitButton =\n/** @class */\nfunction (_super) {\n  __extends(ContextualMenuSplitButton, _super);\n\n  function ContextualMenuSplitButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return __assign(__assign({}, keytipProps), {\n        hasMenu: true\n      });\n    });\n\n    _this._renderAriaDescription = function (ariaDescription, className) {\n      // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan\n      return ariaDescription ? React.createElement(\"span\", {\n        id: _this._ariaDescriptionId,\n        className: className\n      }, ariaDescription) : null;\n    };\n\n    _this._onItemKeyDown = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          onItemKeyDown = _a.onItemKeyDown;\n\n      if (ev.which === KeyCodes.enter) {\n        _this._executeItemClick(ev);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      } else if (onItemKeyDown) {\n        onItemKeyDown(item, ev);\n      }\n    };\n\n    _this._getSubmenuTarget = function () {\n      return _this._splitButton;\n    };\n\n    _this._onItemMouseEnterPrimary = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          onItemMouseEnter = _a.onItemMouseEnter;\n\n      if (onItemMouseEnter) {\n        onItemMouseEnter(__assign(__assign({}, item), {\n          subMenuProps: undefined,\n          items: undefined\n        }), ev, _this._splitButton);\n      }\n    };\n\n    _this._onItemMouseEnterIcon = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          onItemMouseEnter = _a.onItemMouseEnter;\n\n      if (onItemMouseEnter) {\n        onItemMouseEnter(item, ev, _this._splitButton);\n      }\n    };\n\n    _this._onItemMouseMovePrimary = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          onItemMouseMove = _a.onItemMouseMove;\n\n      if (onItemMouseMove) {\n        onItemMouseMove(__assign(__assign({}, item), {\n          subMenuProps: undefined,\n          items: undefined\n        }), ev, _this._splitButton);\n      }\n    };\n\n    _this._onItemMouseMoveIcon = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          onItemMouseMove = _a.onItemMouseMove;\n\n      if (onItemMouseMove) {\n        onItemMouseMove(item, ev, _this._splitButton);\n      }\n    };\n\n    _this._onIconItemClick = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          onItemClickBase = _a.onItemClickBase;\n\n      if (onItemClickBase) {\n        onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);\n      }\n    };\n\n    _this._executeItemClick = function (ev) {\n      var _a = _this.props,\n          item = _a.item,\n          executeItemClick = _a.executeItemClick,\n          onItemClick = _a.onItemClick;\n\n      if (item.disabled || item.isDisabled) {\n        return;\n      }\n\n      if (_this._processingTouch && onItemClick) {\n        return onItemClick(item, ev);\n      }\n\n      if (executeItemClick) {\n        executeItemClick(item, ev);\n      }\n    };\n\n    _this._onTouchStart = function (ev) {\n      if (_this._splitButton && !('onpointerdown' in _this._splitButton)) {\n        _this._handleTouchAndPointerEvent(ev);\n      }\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._handleTouchAndPointerEvent(ev);\n\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n      }\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    return _this;\n  }\n\n  ContextualMenuSplitButton.prototype.componentDidMount = function () {\n    if (this._splitButton && 'onpointerdown' in this._splitButton) {\n      this._events.on(this._splitButton, 'pointerdown', this._onPointerDown, true);\n    }\n  };\n\n  ContextualMenuSplitButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  ContextualMenuSplitButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        item = _a.item,\n        classNames = _a.classNames,\n        index = _a.index,\n        focusableElementIndex = _a.focusableElementIndex,\n        totalItemCount = _a.totalItemCount,\n        hasCheckmarks = _a.hasCheckmarks,\n        hasIcons = _a.hasIcons,\n        onItemMouseLeave = _a.onItemMouseLeave,\n        expandedMenuItemKey = _a.expandedMenuItemKey;\n    var itemHasSubmenu = hasSubmenu(item);\n    var keytipProps = item.keytipProps;\n\n    if (keytipProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    } // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with\n    // the description in it to be added to ariaDescribedBy\n\n\n    var ariaDescription = item.ariaDescription;\n\n    if (ariaDescription) {\n      this._ariaDescriptionId = getId();\n    }\n\n    return React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: isItemDisabled(item)\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", {\n        \"data-ktp-target\": keytipAttributes['data-ktp-target'],\n        ref: function (splitButton) {\n          return _this._splitButton = splitButton;\n        },\n        role: getMenuItemAriaRole(item),\n        \"aria-label\": item.ariaLabel,\n        className: classNames.splitContainer,\n        \"aria-disabled\": isItemDisabled(item),\n        \"aria-expanded\": itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,\n        \"aria-haspopup\": true,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescription ? _this._ariaDescriptionId : undefined, keytipAttributes['aria-describedby']),\n        \"aria-checked\": item.isChecked || item.checked,\n        \"aria-posinset\": focusableElementIndex + 1,\n        \"aria-setsize\": totalItemCount,\n        onMouseEnter: _this._onItemMouseEnterPrimary,\n        onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign(__assign({}, item), {\n          subMenuProps: null,\n          items: null\n        })) : undefined,\n        onMouseMove: _this._onItemMouseMovePrimary,\n        onKeyDown: _this._onItemKeyDown,\n        onClick: _this._executeItemClick,\n        onTouchStart: _this._onTouchStart,\n        tabIndex: 0,\n        \"data-is-focusable\": true,\n        \"aria-roledescription\": item['aria-roledescription']\n      }, _this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons), _this._renderSplitDivider(item), _this._renderSplitIconButton(item, classNames, index, keytipAttributes), _this._renderAriaDescription(ariaDescription, classNames.screenReaderText));\n    });\n  };\n\n  ContextualMenuSplitButton.prototype._renderSplitPrimaryButton = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, hasCheckmarks, hasIcons) {\n    var _a = this.props,\n        _b = _a.contextualMenuItemAs,\n        ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b,\n        onItemClick = _a.onItemClick;\n    var itemProps = {\n      key: item.key,\n      disabled: isItemDisabled(item) || item.primaryDisabled,\n\n      /* eslint-disable deprecation/deprecation */\n      name: item.name,\n      text: item.text || item.name,\n      secondaryText: item.secondaryText,\n\n      /* eslint-enable deprecation/deprecation */\n      className: classNames.splitPrimary,\n      canCheck: item.canCheck,\n      isChecked: item.isChecked,\n      checked: item.checked,\n      iconProps: item.iconProps,\n      onRenderIcon: item.onRenderIcon,\n      data: item.data,\n      'data-is-focusable': false\n    };\n    var itemComponentProps = item.itemProps;\n    return React.createElement(\"button\", __assign({}, getNativeProps(itemProps, buttonProperties)), React.createElement(ChildrenRenderer, __assign({\n      \"data-is-focusable\": false,\n      item: itemProps,\n      classNames: classNames,\n      index: index,\n      onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined,\n      hasIcons: hasIcons\n    }, itemComponentProps)));\n  };\n\n  ContextualMenuSplitButton.prototype._renderSplitDivider = function (item) {\n    var getDividerClassNames = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;\n    return React.createElement(VerticalDivider, {\n      getClassNames: getDividerClassNames\n    });\n  };\n\n  ContextualMenuSplitButton.prototype._renderSplitIconButton = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, keytipAttributes) {\n    var _a = this.props,\n        _b = _a.contextualMenuItemAs,\n        ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b,\n        onItemMouseLeave = _a.onItemMouseLeave,\n        onItemMouseDown = _a.onItemMouseDown,\n        openSubMenu = _a.openSubMenu,\n        dismissSubMenu = _a.dismissSubMenu,\n        dismissMenu = _a.dismissMenu;\n    var itemProps = {\n      onClick: this._onIconItemClick,\n      disabled: isItemDisabled(item),\n      className: classNames.splitMenu,\n      subMenuProps: item.subMenuProps,\n      submenuIconProps: item.submenuIconProps,\n      split: true,\n      key: item.key\n    };\n\n    var buttonProps = __assign(__assign({}, getNativeProps(itemProps, buttonProperties)), {\n      onMouseEnter: this._onItemMouseEnterIcon,\n      onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : undefined,\n      onMouseDown: function (ev) {\n        return onItemMouseDown ? onItemMouseDown(item, ev) : undefined;\n      },\n      onMouseMove: this._onItemMouseMoveIcon,\n      'data-is-focusable': false,\n      'data-ktp-execute-target': keytipAttributes['data-ktp-execute-target'],\n      'aria-hidden': true\n    });\n\n    var itemComponentProps = item.itemProps;\n    return React.createElement(\"button\", __assign({}, buttonProps), React.createElement(ChildrenRenderer, __assign({\n      componentRef: item.componentRef,\n      item: itemProps,\n      classNames: classNames,\n      index: index,\n      hasIcons: false,\n      openSubMenu: openSubMenu,\n      dismissSubMenu: dismissSubMenu,\n      dismissMenu: dismissMenu,\n      getSubmenuTarget: this._getSubmenuTarget\n    }, itemComponentProps)));\n  };\n\n  ContextualMenuSplitButton.prototype._handleTouchAndPointerEvent = function (ev) {\n    var _this = this;\n\n    var onTap = this.props.onTap;\n\n    if (onTap) {\n      onTap(ev);\n    } // If we already have an existing timeout from a previous touch/pointer event\n    // cancel that timeout so we can set a new one.\n\n\n    if (this._lastTouchTimeoutId) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  };\n\n  return ContextualMenuSplitButton;\n}(ContextualMenuItemWrapper);\n\nexport { ContextualMenuSplitButton };","map":{"version":3,"mappings":"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","names":["React","buttonProperties","getNativeProps","KeyCodes","mergeAriaAttributeValues","memoizeFunction","Async","EventGroup","getId","ContextualMenuItem","getSplitButtonVerticalDividerClassNames","KeytipData","isItemDisabled","hasSubmenu","getMenuItemAriaRole","VerticalDivider","ContextualMenuItemWrapper","TouchIdleDelay","__extends","props","_super","_this","keytipProps","hasMenu","ariaDescription","className","id","_ariaDescriptionId","ev","item","onItemKeyDown","which","enter","_executeItemClick","preventDefault","stopPropagation","_splitButton","onItemMouseEnter","subMenuProps","undefined","items","onItemMouseMove","onItemClickBase","currentTarget","executeItemClick","onItemClick","disabled","isDisabled","_processingTouch","_handleTouchAndPointerEvent","pointerType","stopImmediatePropagation","_async","_events","ContextualMenuSplitButton","on","_onPointerDown","dispose","classNames","index","focusableElementIndex","totalItemCount","hasCheckmarks","hasIcons","onItemMouseLeave","expandedMenuItemKey","itemHasSubmenu","_getMemoizedMenuButtonKeytipProps","keytipAttributes","ref","splitButton","role","ariaLabel","splitContainer","key","isChecked","checked","onMouseEnter","_onItemMouseEnterPrimary","onMouseLeave","bind","__assign","onMouseMove","_onItemMouseMovePrimary","onKeyDown","_onItemKeyDown","onClick","onTouchStart","_onTouchStart","tabIndex","_renderSplitPrimaryButton","_renderSplitDivider","_renderSplitIconButton","_renderAriaDescription","screenReaderText","_b","ChildrenRenderer","itemProps","primaryDisabled","name","text","secondaryText","splitPrimary","canCheck","iconProps","onRenderIcon","data","onCheckmarkClick","itemComponentProps","getDividerClassNames","getClassNames","onItemMouseDown","openSubMenu","dismissSubMenu","dismissMenu","_onIconItemClick","splitMenu","submenuIconProps","split","buttonProps","_onItemMouseEnterIcon","onMouseDown","_onItemMouseMoveIcon","componentRef","getSubmenuTarget","_getSubmenuTarget","onTap","_lastTouchTimeoutId","clearTimeout","setTimeout"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\ContextualMenu\\src\\components\\ContextualMenu\\ContextualMenuItemWrapper\\ContextualMenuSplitButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  buttonProperties,\n  getNativeProps,\n  KeyCodes,\n  mergeAriaAttributeValues,\n  memoizeFunction,\n  Async,\n  EventGroup,\n  getId,\n} from '../../../Utilities';\nimport { ContextualMenuItem } from '../ContextualMenuItem';\nimport { IContextualMenuItem } from '../ContextualMenu.types';\nimport { IMenuItemClassNames, getSplitButtonVerticalDividerClassNames } from '../ContextualMenu.classNames';\nimport { KeytipData } from '../../../KeytipData';\nimport { isItemDisabled, hasSubmenu, getMenuItemAriaRole } from '../../../utilities/contextualMenu/index';\nimport { VerticalDivider } from '../../../Divider';\nimport { ContextualMenuItemWrapper } from './ContextualMenuItemWrapper';\nimport { IKeytipProps } from '../../Keytip/Keytip.types';\nimport { IContextualMenuItemWrapperProps } from './ContextualMenuItemWrapper.types';\n\nexport interface IContextualMenuSplitButtonState {}\n\nconst TouchIdleDelay = 500; /* ms */\n\nexport class ContextualMenuSplitButton extends ContextualMenuItemWrapper {\n  private _splitButton: HTMLDivElement;\n  private _lastTouchTimeoutId: number | undefined;\n  private _processingTouch: boolean;\n  private _ariaDescriptionId: string;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true,\n    };\n  });\n\n  constructor(props: IContextualMenuItemWrapperProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n  }\n\n  public componentDidMount() {\n    if (this._splitButton && 'onpointerdown' in this._splitButton) {\n      this._events.on(this._splitButton, 'pointerdown', this._onPointerDown, true);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    const {\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n      onItemMouseLeave,\n      expandedMenuItemKey,\n    } = this.props;\n\n    const itemHasSubmenu = hasSubmenu(item);\n\n    let { keytipProps } = item;\n    if (keytipProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with\n    // the description in it to be added to ariaDescribedBy\n    const { ariaDescription } = item;\n    if (ariaDescription) {\n      this._ariaDescriptionId = getId();\n    }\n\n    return (\n      <KeytipData keytipProps={keytipProps} disabled={isItemDisabled(item)}>\n        {(keytipAttributes: any): JSX.Element => (\n          <div\n            data-ktp-target={keytipAttributes['data-ktp-target']}\n            ref={(splitButton: HTMLDivElement) => (this._splitButton = splitButton)}\n            role={getMenuItemAriaRole(item)}\n            aria-label={item.ariaLabel}\n            className={classNames.splitContainer}\n            aria-disabled={isItemDisabled(item)}\n            aria-expanded={itemHasSubmenu ? item.key === expandedMenuItemKey : undefined}\n            aria-haspopup={true}\n            aria-describedby={mergeAriaAttributeValues(\n              ariaDescription ? this._ariaDescriptionId : undefined,\n              keytipAttributes['aria-describedby'],\n            )}\n            aria-checked={item.isChecked || item.checked}\n            aria-posinset={focusableElementIndex + 1}\n            aria-setsize={totalItemCount}\n            onMouseEnter={this._onItemMouseEnterPrimary}\n            onMouseLeave={\n              onItemMouseLeave ? onItemMouseLeave.bind(this, { ...item, subMenuProps: null, items: null }) : undefined\n            }\n            onMouseMove={this._onItemMouseMovePrimary}\n            onKeyDown={this._onItemKeyDown}\n            onClick={this._executeItemClick}\n            onTouchStart={this._onTouchStart}\n            tabIndex={0}\n            data-is-focusable={true}\n            aria-roledescription={item['aria-roledescription']}\n          >\n            {this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks!, hasIcons!)}\n            {this._renderSplitDivider(item)}\n            {this._renderSplitIconButton(item, classNames, index, keytipAttributes)}\n            {this._renderAriaDescription(ariaDescription, classNames.screenReaderText)}\n          </div>\n        )}\n      </KeytipData>\n    );\n  }\n\n  protected _renderAriaDescription = (ariaDescription?: string, className?: string) => {\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan\n    return ariaDescription ? (\n      <span id={this._ariaDescriptionId} className={className}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  protected _onItemKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    const { item, onItemKeyDown } = this.props;\n    if (ev.which === KeyCodes.enter) {\n      this._executeItemClick(ev);\n      ev.preventDefault();\n      ev.stopPropagation();\n    } else if (onItemKeyDown) {\n      onItemKeyDown(item, ev);\n    }\n  };\n\n  protected _getSubmenuTarget = (): HTMLElement | undefined => {\n    return this._splitButton;\n  };\n\n  private _renderSplitPrimaryButton(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ) {\n    const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem, onItemClick } = this.props;\n\n    const itemProps: IContextualMenuItem = {\n      key: item.key,\n      disabled: isItemDisabled(item) || item.primaryDisabled,\n      /* eslint-disable deprecation/deprecation */\n      name: item.name,\n      text: item.text || item.name,\n      secondaryText: item.secondaryText,\n      /* eslint-enable deprecation/deprecation */\n      className: classNames.splitPrimary,\n      canCheck: item.canCheck,\n      isChecked: item.isChecked,\n      checked: item.checked,\n      iconProps: item.iconProps,\n      onRenderIcon: item.onRenderIcon,\n      data: item.data,\n      'data-is-focusable': false,\n    };\n\n    const { itemProps: itemComponentProps } = item;\n\n    return (\n      <button {...getNativeProps(itemProps, buttonProperties)}>\n        <ChildrenRenderer\n          data-is-focusable={false}\n          item={itemProps}\n          classNames={classNames}\n          index={index}\n          onCheckmarkClick={hasCheckmarks && onItemClick ? onItemClick : undefined}\n          hasIcons={hasIcons}\n          {...itemComponentProps}\n        />\n      </button>\n    );\n  }\n\n  private _renderSplitDivider(item: IContextualMenuItem) {\n    const getDividerClassNames =\n      item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;\n    return <VerticalDivider getClassNames={getDividerClassNames} />;\n  }\n\n  private _renderSplitIconButton(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    index: number,\n    keytipAttributes: any,\n  ) {\n    const {\n      contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem,\n      onItemMouseLeave,\n      onItemMouseDown,\n      openSubMenu,\n      dismissSubMenu,\n      dismissMenu,\n    } = this.props;\n\n    const itemProps: IContextualMenuItem = {\n      onClick: this._onIconItemClick,\n      disabled: isItemDisabled(item),\n      className: classNames.splitMenu,\n      subMenuProps: item.subMenuProps,\n      submenuIconProps: item.submenuIconProps,\n      split: true,\n      key: item.key,\n    };\n\n    const buttonProps = {\n      ...getNativeProps<React.ButtonHTMLAttributes<HTMLButtonElement>>(itemProps, buttonProperties),\n      ...{\n        onMouseEnter: this._onItemMouseEnterIcon,\n        onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : undefined,\n        onMouseDown: (ev: React.MouseEvent<HTMLButtonElement>) =>\n          onItemMouseDown ? onItemMouseDown(item, ev) : undefined,\n        onMouseMove: this._onItemMouseMoveIcon,\n        'data-is-focusable': false,\n        'data-ktp-execute-target': keytipAttributes['data-ktp-execute-target'],\n        'aria-hidden': true,\n      },\n    };\n\n    const { itemProps: itemComponentProps } = item;\n\n    return (\n      <button {...buttonProps}>\n        <ChildrenRenderer\n          componentRef={item.componentRef}\n          item={itemProps}\n          classNames={classNames}\n          index={index}\n          hasIcons={false}\n          openSubMenu={openSubMenu}\n          dismissSubMenu={dismissSubMenu}\n          dismissMenu={dismissMenu}\n          getSubmenuTarget={this._getSubmenuTarget}\n          {...itemComponentProps}\n        />\n      </button>\n    );\n  }\n\n  private _onItemMouseEnterPrimary = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { item, onItemMouseEnter } = this.props;\n    if (onItemMouseEnter) {\n      onItemMouseEnter({ ...item, subMenuProps: undefined, items: undefined }, ev, this._splitButton);\n    }\n  };\n\n  private _onItemMouseEnterIcon = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { item, onItemMouseEnter } = this.props;\n    if (onItemMouseEnter) {\n      onItemMouseEnter(item, ev, this._splitButton);\n    }\n  };\n\n  private _onItemMouseMovePrimary = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { item, onItemMouseMove } = this.props;\n    if (onItemMouseMove) {\n      onItemMouseMove({ ...item, subMenuProps: undefined, items: undefined }, ev, this._splitButton);\n    }\n  };\n\n  private _onItemMouseMoveIcon = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { item, onItemMouseMove } = this.props;\n    if (onItemMouseMove) {\n      onItemMouseMove(item, ev, this._splitButton);\n    }\n  };\n\n  private _onIconItemClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { item, onItemClickBase } = this.props;\n    if (onItemClickBase) {\n      onItemClickBase(item, ev, (this._splitButton ? this._splitButton : ev.currentTarget) as HTMLElement);\n    }\n  };\n\n  private _executeItemClick = (ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { item, executeItemClick, onItemClick } = this.props;\n\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (this._processingTouch && onItemClick) {\n      return onItemClick(item, ev);\n    }\n\n    if (executeItemClick) {\n      executeItemClick(item, ev);\n    }\n  };\n\n  private _onTouchStart = (ev: React.TouchEvent<HTMLElement>): void => {\n    if (this._splitButton && !('onpointerdown' in this._splitButton)) {\n      this._handleTouchAndPointerEvent(ev);\n    }\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent(ev);\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  private _handleTouchAndPointerEvent(ev: React.TouchEvent<HTMLElement> | PointerEvent) {\n    const { onTap } = this.props;\n\n    if (onTap) {\n      onTap(ev);\n    }\n    // If we already have an existing timeout from a previous touch/pointer event\n    // cancel that timeout so we can set a new one.\n    if (this._lastTouchTimeoutId) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}