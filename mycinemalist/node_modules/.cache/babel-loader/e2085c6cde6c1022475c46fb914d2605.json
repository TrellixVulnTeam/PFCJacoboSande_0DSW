{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { TextField } from '../TextField';\nimport { initializeComponentRef, KeyCodes } from '../../../Utilities';\nimport { clearNext, clearPrev, clearRange, DEFAULT_MASK_FORMAT_CHARS, getLeftFormatIndex, getMaskDisplay, getRightFormatIndex, insertString, parseMask } from './inputMask';\nexport var DEFAULT_MASK_CHAR = '_';\n\nvar MaskedTextField =\n/** @class */\nfunction (_super) {\n  __extends(MaskedTextField, _super);\n\n  function MaskedTextField(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._textField = React.createRef();\n\n    _this._onFocus = function (event) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(event);\n      }\n\n      _this._isFocused = true; // Move the cursor position to the leftmost unfilled position\n\n      for (var i = 0; i < _this._maskCharData.length; i++) {\n        if (!_this._maskCharData[i].value) {\n          _this.setState({\n            maskCursorPosition: _this._maskCharData[i].displayIndex\n          });\n\n          break;\n        }\n      }\n    };\n\n    _this._onBlur = function (event) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(event);\n      }\n\n      _this._isFocused = false;\n      _this._moveCursorOnMouseUp = true;\n    };\n\n    _this._onMouseDown = function (event) {\n      if (_this.props.onMouseDown) {\n        _this.props.onMouseDown(event);\n      }\n\n      if (!_this._isFocused) {\n        _this._moveCursorOnMouseUp = true;\n      }\n    };\n\n    _this._onMouseUp = function (event) {\n      if (_this.props.onMouseUp) {\n        _this.props.onMouseUp(event);\n      } // Move the cursor on mouseUp after focusing the textField\n\n\n      if (_this._moveCursorOnMouseUp) {\n        _this._moveCursorOnMouseUp = false; // Move the cursor position to the rightmost unfilled position\n\n        for (var i = 0; i < _this._maskCharData.length; i++) {\n          if (!_this._maskCharData[i].value) {\n            _this.setState({\n              maskCursorPosition: _this._maskCharData[i].displayIndex\n            });\n\n            break;\n          }\n        }\n      }\n    };\n\n    _this._onInputChange = function (ev, value) {\n      var textField = _this._textField.current;\n\n      if (_this._changeSelectionData === null && textField) {\n        _this._changeSelectionData = {\n          changeType: 'default',\n          selectionStart: textField.selectionStart !== null ? textField.selectionStart : -1,\n          selectionEnd: textField.selectionEnd !== null ? textField.selectionEnd : -1\n        };\n      }\n\n      if (!_this._changeSelectionData) {\n        return;\n      }\n\n      var displayValue = _this.state.displayValue; // The initial value of cursorPos does not matter\n\n      var cursorPos = 0;\n      var _a = _this._changeSelectionData,\n          changeType = _a.changeType,\n          selectionStart = _a.selectionStart,\n          selectionEnd = _a.selectionEnd;\n\n      if (changeType === 'textPasted') {\n        var charsSelected = selectionEnd - selectionStart;\n        var charCount = value.length + charsSelected - displayValue.length;\n        var startPos = selectionStart;\n        var pastedString = value.substr(startPos, charCount); // Clear any selected characters\n\n        if (charsSelected) {\n          _this._maskCharData = clearRange(_this._maskCharData, selectionStart, charsSelected);\n        }\n\n        cursorPos = insertString(_this._maskCharData, startPos, pastedString);\n      } else if (changeType === 'delete' || changeType === 'backspace') {\n        // isDel is true If the characters are removed LTR, otherwise RTL\n        var isDel = changeType === 'delete';\n        var charCount = selectionEnd - selectionStart;\n\n        if (charCount) {\n          // charCount is > 0 if range was deleted\n          _this._maskCharData = clearRange(_this._maskCharData, selectionStart, charCount);\n          cursorPos = getRightFormatIndex(_this._maskCharData, selectionStart);\n        } else {\n          // If charCount === 0, there was no selection and a single character was deleted\n          if (isDel) {\n            _this._maskCharData = clearNext(_this._maskCharData, selectionStart);\n            cursorPos = getRightFormatIndex(_this._maskCharData, selectionStart);\n          } else {\n            _this._maskCharData = clearPrev(_this._maskCharData, selectionStart);\n            cursorPos = getLeftFormatIndex(_this._maskCharData, selectionStart);\n          }\n        }\n      } else if (value.length > displayValue.length) {\n        // This case is if the user added characters\n        var charCount = value.length - displayValue.length;\n        var startPos = selectionEnd - charCount;\n        var enteredString = value.substr(startPos, charCount);\n        cursorPos = insertString(_this._maskCharData, startPos, enteredString);\n      } else if (value.length <= displayValue.length) {\n        /**\n         * This case is reached only if the user has selected a block of 1 or more\n         * characters and input a character replacing the characters they've selected.\n         */\n        var charCount = 1;\n        var selectCount = displayValue.length + charCount - value.length;\n        var startPos = selectionEnd - charCount;\n        var enteredString = value.substr(startPos, charCount); // Clear the selected range\n\n        _this._maskCharData = clearRange(_this._maskCharData, startPos, selectCount); // Insert the printed character\n\n        cursorPos = insertString(_this._maskCharData, startPos, enteredString);\n      }\n\n      _this._changeSelectionData = null;\n      var newValue = getMaskDisplay(_this.props.mask, _this._maskCharData, _this.props.maskChar);\n\n      _this.setState({\n        displayValue: newValue,\n        maskCursorPosition: cursorPos\n      }); // Perform onChange after input has been processed. Return value is expected to be the displayed text\n\n\n      if (_this.props.onChange) {\n        _this.props.onChange(ev, newValue);\n      }\n    };\n\n    _this._onKeyDown = function (event) {\n      var current = _this._textField.current;\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(event);\n      }\n\n      _this._changeSelectionData = null;\n\n      if (current && current.value) {\n        var keyCode = event.keyCode,\n            ctrlKey = event.ctrlKey,\n            metaKey = event.metaKey; // Ignore ctrl and meta keydown\n\n        if (ctrlKey || metaKey) {\n          return;\n        } // On backspace or delete, store the selection and the keyCode\n\n\n        if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {\n          var selectionStart = event.target.selectionStart;\n          var selectionEnd = event.target.selectionEnd; // Check if backspace or delete press is valid.\n\n          if (!(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) && !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < current.value.length)) {\n            return;\n          }\n\n          _this._changeSelectionData = {\n            changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',\n            selectionStart: selectionStart !== null ? selectionStart : -1,\n            selectionEnd: selectionEnd !== null ? selectionEnd : -1\n          };\n        }\n      }\n    };\n\n    _this._onPaste = function (event) {\n      if (_this.props.onPaste) {\n        _this.props.onPaste(event);\n      }\n\n      var selectionStart = event.target.selectionStart;\n      var selectionEnd = event.target.selectionEnd; // Store the paste selection range\n\n      _this._changeSelectionData = {\n        changeType: 'textPasted',\n        selectionStart: selectionStart !== null ? selectionStart : -1,\n        selectionEnd: selectionEnd !== null ? selectionEnd : -1\n      };\n    };\n\n    initializeComponentRef(_this); // Translate mask into charData\n\n    _this._maskCharData = parseMask(props.mask, props.maskFormat); // If an initial value is provided, use it to populate the format chars\n\n    props.value !== undefined && _this.setValue(props.value);\n    _this._isFocused = false;\n    _this._moveCursorOnMouseUp = false;\n    _this.state = {\n      displayValue: getMaskDisplay(props.mask, _this._maskCharData, props.maskChar)\n    };\n    return _this;\n  }\n\n  MaskedTextField.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.mask !== this.props.mask || newProps.value !== this.props.value) {\n      this._maskCharData = parseMask(newProps.mask, newProps.maskFormat);\n      newProps.value !== undefined && this.setValue(newProps.value);\n      this.setState({\n        displayValue: getMaskDisplay(newProps.mask, this._maskCharData, newProps.maskChar)\n      });\n    }\n  };\n\n  MaskedTextField.prototype.componentDidUpdate = function () {\n    // Move the cursor to the start of the mask format on update\n    if (this._isFocused && this.state.maskCursorPosition !== undefined && this._textField.current) {\n      this._textField.current.setSelectionRange(this.state.maskCursorPosition, this.state.maskCursorPosition);\n    }\n  };\n\n  MaskedTextField.prototype.render = function () {\n    return React.createElement(TextField, __assign({}, this.props, {\n      onFocus: this._onFocus,\n      onBlur: this._onBlur,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onChange: this._onInputChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      value: this.state.displayValue || '',\n      componentRef: this._textField\n    }));\n  };\n\n  Object.defineProperty(MaskedTextField.prototype, \"value\", {\n    /**\n     * @returns The value of all filled format characters or undefined if not all format characters are filled\n     */\n    get: function get() {\n      var value = '';\n\n      for (var i = 0; i < this._maskCharData.length; i++) {\n        if (!this._maskCharData[i].value) {\n          return undefined;\n        }\n\n        value += this._maskCharData[i].value;\n      }\n\n      return value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MaskedTextField.prototype.setValue = function (newValue) {\n    var valueIndex = 0;\n    var charDataIndex = 0;\n\n    while (valueIndex < newValue.length && charDataIndex < this._maskCharData.length) {\n      // Test if the next character in the new value fits the next format character\n      var testVal = newValue[valueIndex];\n\n      if (this._maskCharData[charDataIndex].format.test(testVal)) {\n        this._maskCharData[charDataIndex].value = testVal;\n        charDataIndex++;\n      }\n\n      valueIndex++;\n    }\n  };\n\n  MaskedTextField.prototype.focus = function () {\n    var current = this._textField.current;\n    current && current.focus();\n  };\n\n  MaskedTextField.prototype.blur = function () {\n    var current = this._textField.current;\n    current && current.blur();\n  };\n\n  MaskedTextField.prototype.select = function () {\n    var current = this._textField.current;\n    current && current.select();\n  };\n\n  MaskedTextField.prototype.setSelectionStart = function (value) {\n    var current = this._textField.current;\n    current && current.setSelectionStart(value);\n  };\n\n  MaskedTextField.prototype.setSelectionEnd = function (value) {\n    var current = this._textField.current;\n    current && current.setSelectionEnd(value);\n  };\n\n  MaskedTextField.prototype.setSelectionRange = function (start, end) {\n    var current = this._textField.current;\n    current && current.setSelectionRange(start, end);\n  };\n\n  Object.defineProperty(MaskedTextField.prototype, \"selectionStart\", {\n    get: function get() {\n      var current = this._textField.current;\n      return current && current.selectionStart !== null ? current.selectionStart : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MaskedTextField.prototype, \"selectionEnd\", {\n    get: function get() {\n      var current = this._textField.current;\n      return current && current.selectionEnd ? current.selectionEnd : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  MaskedTextField.defaultProps = {\n    maskChar: DEFAULT_MASK_CHAR,\n    maskFormat: DEFAULT_MASK_FORMAT_CHARS\n  };\n  return MaskedTextField;\n}(React.Component);\n\nexport { MaskedTextField };","map":{"version":3,"mappings":"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","names":["React","TextField","initializeComponentRef","KeyCodes","clearNext","clearPrev","clearRange","DEFAULT_MASK_FORMAT_CHARS","getLeftFormatIndex","getMaskDisplay","getRightFormatIndex","insertString","parseMask","DEFAULT_MASK_CHAR","__extends","props","_super","_this","createRef","event","onFocus","_isFocused","i","_maskCharData","length","value","setState","maskCursorPosition","displayIndex","onBlur","_moveCursorOnMouseUp","onMouseDown","onMouseUp","ev","textField","_textField","current","_changeSelectionData","changeType","selectionStart","selectionEnd","cursorPos","charsSelected","charCount","displayValue","startPos","pastedString","substr","isDel","enteredString","selectCount","newValue","mask","maskChar","onChange","onKeyDown","ctrlKey","metaKey","keyCode","backspace","del","target","onPaste","maskFormat","undefined","setValue","state","MaskedTextField","newProps","setSelectionRange","__assign","_onFocus","_onBlur","_onMouseDown","_onMouseUp","_onInputChange","_onKeyDown","_onPaste","componentRef","Object","valueIndex","charDataIndex","testVal","format","test","focus","blur","select","setSelectionStart","setSelectionEnd","start","end","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\TextField\\src\\components\\TextField\\MaskedTextField\\MaskedTextField.tsx"],"sourcesContent":["import * as React from 'react';\nimport { TextField } from '../TextField';\nimport { ITextField, IMaskedTextFieldProps } from '../TextField.types';\nimport { initializeComponentRef, KeyCodes } from '../../../Utilities';\n\nimport {\n  clearNext,\n  clearPrev,\n  clearRange,\n  DEFAULT_MASK_FORMAT_CHARS,\n  getLeftFormatIndex,\n  getMaskDisplay,\n  getRightFormatIndex,\n  IMaskValue,\n  insertString,\n  parseMask,\n} from './inputMask';\n\n/**\n * State for the MaskedTextField component.\n */\nexport interface IMaskedTextFieldState {\n  /**\n   * The mask string formatted with the input value.\n   * This is what is displayed inside the TextField\n   * @example\n   *  `Phone Number: 12_ - 4___`\n   */\n  displayValue: string;\n  /** The index into the rendered value of the first unfilled format character */\n  maskCursorPosition?: number;\n}\n\nexport const DEFAULT_MASK_CHAR = '_';\n\ntype InputChangeType = 'default' | 'backspace' | 'delete' | 'textPasted';\n\nexport class MaskedTextField extends React.Component<IMaskedTextFieldProps, IMaskedTextFieldState>\n  implements ITextField {\n  public static defaultProps: IMaskedTextFieldProps = {\n    maskChar: DEFAULT_MASK_CHAR,\n    maskFormat: DEFAULT_MASK_FORMAT_CHARS,\n  };\n\n  private _textField = React.createRef<ITextField>();\n\n  /**\n   *  An array of data containing information regarding the format characters,\n   *  their indices inside the display text, and their corresponding values.\n   * @example\n   * ```\n   *  [\n   *    { value: '1', displayIndex: 16, format: /[0-9]/ },\n   *    { value: '2', displayIndex: 17, format: /[0-9]/ },\n   *    { displayIndex: 18, format: /[0-9]/ },\n   *    { value: '4', displayIndex: 22, format: /[0-9]/ },\n   *    ...\n   *  ]\n   * ```\n   */\n  private _maskCharData: IMaskValue[];\n  /** True if the TextField is focused */\n  private _isFocused: boolean;\n  /** True if the TextField was not focused and it was clicked into */\n  private _moveCursorOnMouseUp: boolean;\n\n  /** The stored selection data prior to input change events. */\n  private _changeSelectionData: {\n    changeType: InputChangeType;\n    selectionStart: number;\n    selectionEnd: number;\n  } | null;\n\n  constructor(props: IMaskedTextFieldProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    // Translate mask into charData\n    this._maskCharData = parseMask(props.mask, props.maskFormat);\n    // If an initial value is provided, use it to populate the format chars\n    props.value !== undefined && this.setValue(props.value);\n\n    this._isFocused = false;\n    this._moveCursorOnMouseUp = false;\n\n    this.state = {\n      displayValue: getMaskDisplay(props.mask, this._maskCharData, props.maskChar),\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: IMaskedTextFieldProps) {\n    if (newProps.mask !== this.props.mask || newProps.value !== this.props.value) {\n      this._maskCharData = parseMask(newProps.mask, newProps.maskFormat);\n      newProps.value !== undefined && this.setValue(newProps.value);\n\n      this.setState({\n        displayValue: getMaskDisplay(newProps.mask, this._maskCharData, newProps.maskChar),\n      });\n    }\n  }\n\n  public componentDidUpdate() {\n    // Move the cursor to the start of the mask format on update\n    if (this._isFocused && this.state.maskCursorPosition !== undefined && this._textField.current) {\n      this._textField.current.setSelectionRange(this.state.maskCursorPosition, this.state.maskCursorPosition);\n    }\n  }\n\n  public render() {\n    return (\n      <TextField\n        {...this.props}\n        onFocus={this._onFocus}\n        onBlur={this._onBlur}\n        onMouseDown={this._onMouseDown}\n        onMouseUp={this._onMouseUp}\n        onChange={this._onInputChange}\n        onKeyDown={this._onKeyDown}\n        onPaste={this._onPaste}\n        value={this.state.displayValue || ''}\n        componentRef={this._textField}\n      />\n    );\n  }\n\n  /**\n   * @returns The value of all filled format characters or undefined if not all format characters are filled\n   */\n  public get value(): string | undefined {\n    let value = '';\n\n    for (let i = 0; i < this._maskCharData.length; i++) {\n      if (!this._maskCharData[i].value) {\n        return undefined;\n      }\n      value += this._maskCharData[i].value;\n    }\n    return value;\n  }\n\n  public setValue(newValue: string): void {\n    let valueIndex = 0;\n    let charDataIndex = 0;\n\n    while (valueIndex < newValue.length && charDataIndex < this._maskCharData.length) {\n      // Test if the next character in the new value fits the next format character\n      const testVal = newValue[valueIndex];\n      if (this._maskCharData[charDataIndex].format.test(testVal)) {\n        this._maskCharData[charDataIndex].value = testVal;\n        charDataIndex++;\n      }\n      valueIndex++;\n    }\n  }\n\n  public focus(): void {\n    const { current } = this._textField;\n\n    current && current.focus();\n  }\n\n  public blur(): void {\n    const { current } = this._textField;\n\n    current && current.blur();\n  }\n\n  public select(): void {\n    const { current } = this._textField;\n\n    current && current.select();\n  }\n\n  public setSelectionStart(value: number): void {\n    const { current } = this._textField;\n\n    current && current.setSelectionStart(value);\n  }\n\n  public setSelectionEnd(value: number): void {\n    const { current } = this._textField;\n\n    current && current.setSelectionEnd(value);\n  }\n\n  public setSelectionRange(start: number, end: number): void {\n    const { current } = this._textField;\n    current && current.setSelectionRange(start, end);\n  }\n\n  public get selectionStart(): number | null {\n    const { current } = this._textField;\n\n    return current && current.selectionStart !== null ? current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    const { current } = this._textField;\n\n    return current && current.selectionEnd ? current.selectionEnd : -1;\n  }\n\n  private _onFocus = (event: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(event);\n    }\n\n    this._isFocused = true;\n\n    // Move the cursor position to the leftmost unfilled position\n    for (let i = 0; i < this._maskCharData.length; i++) {\n      if (!this._maskCharData[i].value) {\n        this.setState({\n          maskCursorPosition: this._maskCharData[i].displayIndex,\n        });\n        break;\n      }\n    }\n  };\n\n  private _onBlur = (event: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(event);\n    }\n\n    this._isFocused = false;\n    this._moveCursorOnMouseUp = true;\n  };\n\n  private _onMouseDown = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (this.props.onMouseDown) {\n      this.props.onMouseDown(event);\n    }\n\n    if (!this._isFocused) {\n      this._moveCursorOnMouseUp = true;\n    }\n  };\n\n  private _onMouseUp = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (this.props.onMouseUp) {\n      this.props.onMouseUp(event);\n    }\n\n    // Move the cursor on mouseUp after focusing the textField\n    if (this._moveCursorOnMouseUp) {\n      this._moveCursorOnMouseUp = false;\n      // Move the cursor position to the rightmost unfilled position\n      for (let i = 0; i < this._maskCharData.length; i++) {\n        if (!this._maskCharData[i].value) {\n          this.setState({\n            maskCursorPosition: this._maskCharData[i].displayIndex,\n          });\n          break;\n        }\n      }\n    }\n  };\n\n  private _onInputChange = (ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, value: string) => {\n    const textField = this._textField.current;\n    if (this._changeSelectionData === null && textField) {\n      this._changeSelectionData = {\n        changeType: 'default',\n        selectionStart: textField.selectionStart !== null ? textField.selectionStart : -1,\n        selectionEnd: textField.selectionEnd !== null ? textField.selectionEnd : -1,\n      };\n    }\n    if (!this._changeSelectionData) {\n      return;\n    }\n\n    const { displayValue } = this.state;\n\n    // The initial value of cursorPos does not matter\n    let cursorPos = 0;\n    const { changeType, selectionStart, selectionEnd } = this._changeSelectionData;\n\n    if (changeType === 'textPasted') {\n      const charsSelected = selectionEnd - selectionStart;\n      const charCount = value.length + charsSelected - displayValue.length;\n      const startPos = selectionStart;\n      const pastedString = value.substr(startPos, charCount);\n\n      // Clear any selected characters\n      if (charsSelected) {\n        this._maskCharData = clearRange(this._maskCharData, selectionStart, charsSelected);\n      }\n      cursorPos = insertString(this._maskCharData, startPos, pastedString);\n    } else if (changeType === 'delete' || changeType === 'backspace') {\n      // isDel is true If the characters are removed LTR, otherwise RTL\n      const isDel = changeType === 'delete';\n      const charCount = selectionEnd - selectionStart;\n\n      if (charCount) {\n        // charCount is > 0 if range was deleted\n        this._maskCharData = clearRange(this._maskCharData, selectionStart, charCount);\n        cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);\n      } else {\n        // If charCount === 0, there was no selection and a single character was deleted\n        if (isDel) {\n          this._maskCharData = clearNext(this._maskCharData, selectionStart);\n          cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);\n        } else {\n          this._maskCharData = clearPrev(this._maskCharData, selectionStart);\n          cursorPos = getLeftFormatIndex(this._maskCharData, selectionStart);\n        }\n      }\n    } else if (value.length > displayValue.length) {\n      // This case is if the user added characters\n      const charCount = value.length - displayValue.length;\n      const startPos = selectionEnd - charCount;\n      const enteredString = value.substr(startPos, charCount);\n\n      cursorPos = insertString(this._maskCharData, startPos, enteredString);\n    } else if (value.length <= displayValue.length) {\n      /**\n       * This case is reached only if the user has selected a block of 1 or more\n       * characters and input a character replacing the characters they've selected.\n       */\n      const charCount = 1;\n      const selectCount = displayValue.length + charCount - value.length;\n      const startPos = selectionEnd - charCount;\n      const enteredString = value.substr(startPos, charCount);\n\n      // Clear the selected range\n      this._maskCharData = clearRange(this._maskCharData, startPos, selectCount);\n      // Insert the printed character\n      cursorPos = insertString(this._maskCharData, startPos, enteredString);\n    }\n\n    this._changeSelectionData = null;\n\n    const newValue = getMaskDisplay(this.props.mask, this._maskCharData, this.props.maskChar);\n\n    this.setState({\n      displayValue: newValue,\n      maskCursorPosition: cursorPos,\n    });\n\n    // Perform onChange after input has been processed. Return value is expected to be the displayed text\n    if (this.props.onChange) {\n      this.props.onChange(ev, newValue);\n    }\n  };\n\n  private _onKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    const { current } = this._textField;\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(event);\n    }\n\n    this._changeSelectionData = null;\n    if (current && current.value) {\n      const { keyCode, ctrlKey, metaKey } = event;\n\n      // Ignore ctrl and meta keydown\n      if (ctrlKey || metaKey) {\n        return;\n      }\n\n      // On backspace or delete, store the selection and the keyCode\n      if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {\n        const selectionStart = (event.target as HTMLInputElement).selectionStart;\n        const selectionEnd = (event.target as HTMLInputElement).selectionEnd;\n\n        // Check if backspace or delete press is valid.\n        if (\n          !(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) &&\n          !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < current.value.length)\n        ) {\n          return;\n        }\n\n        this._changeSelectionData = {\n          changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',\n          selectionStart: selectionStart !== null ? selectionStart : -1,\n          selectionEnd: selectionEnd !== null ? selectionEnd : -1,\n        };\n      }\n    }\n  };\n\n  private _onPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {\n    if (this.props.onPaste) {\n      this.props.onPaste(event);\n    }\n\n    const selectionStart = (event.target as HTMLInputElement).selectionStart;\n    const selectionEnd = (event.target as HTMLInputElement).selectionEnd;\n    // Store the paste selection range\n    this._changeSelectionData = {\n      changeType: 'textPasted',\n      selectionStart: selectionStart !== null ? selectionStart : -1,\n      selectionEnd: selectionEnd !== null ? selectionEnd : -1,\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}