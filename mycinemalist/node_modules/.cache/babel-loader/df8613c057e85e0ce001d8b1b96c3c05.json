{"ast":null,"code":"import { MAX_COLOR_RGB } from './consts';\nimport { assign } from '../../Utilities';\nimport { clamp } from './clamp';\nimport { getColorFromRGBA } from './getColorFromRGBA';\nimport { hsv2hsl } from './hsv2hsl';\nimport { hsv2rgb } from './hsv2rgb'; // Soften: to get closer to the background color's luminance\n// (softening with a white background would be lightening, with black it'd be darkening)\n// Strongen: opposite of soften\n// Luminance multiplier constants for generating shades of a given color\n\nvar WhiteShadeTableBG = [0.027, 0.043, 0.082, 0.145, 0.184, 0.216, 0.349, 0.537]; // white bg\n\nvar BlackTintTableBG = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black bg\n\nvar WhiteShadeTable = [0.537, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043, 0.027]; // white fg\n\nvar BlackTintTable = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black fg\n\nvar LumTintTable = [0.88, 0.77, 0.66, 0.55, 0.44, 0.33, 0.22, 0.11]; // light (strongen all)\n\nvar LumShadeTable = [0.11, 0.22, 0.33, 0.44, 0.55, 0.66, 0.77, 0.88]; // dark (soften all)\n\nvar ColorTintTable = [0.96, 0.84, 0.7, 0.4, 0.12]; // default soften\n\nvar ColorShadeTable = [0.1, 0.24, 0.44]; // default strongen\n// If the given shade's luminance is below/above these values, we'll swap to using the White/Black tables above\n\nvar LowLuminanceThreshold = 0.2;\nvar HighLuminanceThreshold = 0.8;\n/** Shades of a given color, from softest to strongest. */\n\nexport var Shade;\n\n(function (Shade) {\n  Shade[Shade[\"Unshaded\"] = 0] = \"Unshaded\";\n  Shade[Shade[\"Shade1\"] = 1] = \"Shade1\";\n  Shade[Shade[\"Shade2\"] = 2] = \"Shade2\";\n  Shade[Shade[\"Shade3\"] = 3] = \"Shade3\";\n  Shade[Shade[\"Shade4\"] = 4] = \"Shade4\";\n  Shade[Shade[\"Shade5\"] = 5] = \"Shade5\";\n  Shade[Shade[\"Shade6\"] = 6] = \"Shade6\";\n  Shade[Shade[\"Shade7\"] = 7] = \"Shade7\";\n  Shade[Shade[\"Shade8\"] = 8] = \"Shade8\"; // remember to update isValidShade()!\n})(Shade || (Shade = {}));\n/**\n * Returns true if the argument is a valid Shade value\n * @param shade - The Shade value to validate.\n */\n\n\nexport function isValidShade(shade) {\n  return typeof shade === 'number' && shade >= Shade.Unshaded && shade <= Shade.Shade8;\n}\n\nfunction _isBlack(color) {\n  return color.r === 0 && color.g === 0 && color.b === 0;\n}\n\nfunction _isWhite(color) {\n  return color.r === MAX_COLOR_RGB && color.g === MAX_COLOR_RGB && color.b === MAX_COLOR_RGB;\n}\n\nfunction _darken(hsv, factor) {\n  return {\n    h: hsv.h,\n    s: hsv.s,\n    v: clamp(hsv.v - hsv.v * factor, 100, 0)\n  };\n}\n\nfunction _lighten(hsv, factor) {\n  return {\n    h: hsv.h,\n    s: clamp(hsv.s - hsv.s * factor, 100, 0),\n    v: clamp(hsv.v + (100 - hsv.v) * factor, 100, 0)\n  };\n}\n\nexport function isDark(color) {\n  return hsv2hsl(color.h, color.s, color.v).l < 50;\n}\n/**\n * Given a color and a shade specification, generates the requested shade of the color.\n * Logic:\n * if white\n *  darken via tables defined above\n * if black\n *  lighten\n * if light\n *  strongen\n * if dark\n *  soften\n * else default\n *  soften or strongen depending on shade#\n * @param color - The base color whose shade is to be computed\n * @param shade - The shade of the base color to compute\n * @param isInverted - Default false. Whether the given theme is inverted (reverse strongen/soften logic)\n */\n\nexport function getShade(color, shade, isInverted) {\n  if (isInverted === void 0) {\n    isInverted = false;\n  }\n\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  var hsl = hsv2hsl(color.h, color.s, color.v);\n  var hsv = {\n    h: color.h,\n    s: color.s,\n    v: color.v\n  };\n  var tableIndex = shade - 1;\n  var _soften = _lighten;\n  var _strongen = _darken;\n\n  if (isInverted) {\n    _soften = _darken;\n    _strongen = _lighten;\n  }\n\n  if (_isWhite(color)) {\n    // white\n    hsv = _darken(hsv, WhiteShadeTable[tableIndex]);\n  } else if (_isBlack(color)) {\n    // black\n    hsv = _lighten(hsv, BlackTintTable[tableIndex]);\n  } else if (hsl.l / 100 > HighLuminanceThreshold) {\n    // light\n    hsv = _strongen(hsv, LumShadeTable[tableIndex]);\n  } else if (hsl.l / 100 < LowLuminanceThreshold) {\n    // dark\n    hsv = _soften(hsv, LumTintTable[tableIndex]);\n  } else {\n    // default\n    if (tableIndex < ColorTintTable.length) {\n      hsv = _soften(hsv, ColorTintTable[tableIndex]);\n    } else {\n      hsv = _strongen(hsv, ColorShadeTable[tableIndex - ColorTintTable.length]);\n    }\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), {\n    a: color.a\n  }));\n} // Background shades/tints are generated differently. The provided color will be guaranteed\n//   to be the darkest or lightest one. If it is <50% luminance, it will always be the darkest,\n//   otherwise it will always be the lightest.\n\nexport function getBackgroundShade(color, shade, isInverted) {\n  if (isInverted === void 0) {\n    isInverted = false;\n  }\n\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  var hsv = {\n    h: color.h,\n    s: color.s,\n    v: color.v\n  };\n  var tableIndex = shade - 1;\n\n  if (!isInverted) {\n    // lightish\n    hsv = _darken(hsv, WhiteShadeTableBG[tableIndex]);\n  } else {\n    // default: if (hsl.l / 100 < .5) { // darkish\n    hsv = _lighten(hsv, BlackTintTableBG[BlackTintTable.length - 1 - tableIndex]);\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), {\n    a: color.a\n  }));\n}\n/* Calculates the contrast ratio between two colors. Used for verifying\n * color pairs meet minimum accessibility requirements.\n * See: https://www.w3.org/TR/WCAG20/ section 1.4.3\n */\n\nexport function getContrastRatio(color1, color2) {\n  // Formula defined by: http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html#contrast-ratiodef\n  // relative luminance: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n\n  /* calculate the intermediate value needed to calculating relative luminance */\n  function _getThing(x) {\n    if (x <= 0.03928) {\n      return x / 12.92;\n    } else {\n      return Math.pow((x + 0.055) / 1.055, 2.4);\n    }\n  }\n\n  var r1 = _getThing(color1.r / MAX_COLOR_RGB);\n\n  var g1 = _getThing(color1.g / MAX_COLOR_RGB);\n\n  var b1 = _getThing(color1.b / MAX_COLOR_RGB);\n\n  var L1 = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1; // relative luminance of first color\n\n  L1 += 0.05;\n\n  var r2 = _getThing(color2.r / MAX_COLOR_RGB);\n\n  var g2 = _getThing(color2.g / MAX_COLOR_RGB);\n\n  var b2 = _getThing(color2.b / MAX_COLOR_RGB);\n\n  var L2 = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2; // relative luminance of second color\n\n  L2 += 0.05; // return the lighter color divided by darker\n\n  return L1 / L2 > 1 ? L1 / L2 : L2 / L1;\n}","map":{"version":3,"mappings":"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","names":["MAX_COLOR_RGB","assign","clamp","getColorFromRGBA","hsv2hsl","hsv2rgb","WhiteShadeTableBG","BlackTintTableBG","WhiteShadeTable","BlackTintTable","LumTintTable","LumShadeTable","ColorTintTable","ColorShadeTable","LowLuminanceThreshold","HighLuminanceThreshold","Shade","isValidShade","shade","Unshaded","Shade8","_isBlack","color","r","g","b","_isWhite","_darken","hsv","factor","h","s","v","_lighten","isDark","l","getShade","isInverted","hsl","tableIndex","_soften","_strongen","length","a","getBackgroundShade","getContrastRatio","color1","color2","_getThing","x","Math","pow","r1","g1","b1","L1","r2","g2","b2","L2"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\utilities\\src\\utilities\\color\\shades.ts"],"sourcesContent":["// Technically this should be shades and tints, but for simplicity we'll call everything a shade.\n/*\n * This utility module is used with theming. Given a color to shade, whether the theme is inverted\n * (i.e. is a dark color), and the desired shade enum, this will return an appropriate shade of that color.\n */\nimport { IHSV, IColor } from './interfaces';\nimport { MAX_COLOR_RGB } from './consts';\nimport { assign } from '../../Utilities';\nimport { clamp } from './clamp';\nimport { getColorFromRGBA } from './getColorFromRGBA';\nimport { hsv2hsl } from './hsv2hsl';\nimport { hsv2rgb } from './hsv2rgb';\n\n// Soften: to get closer to the background color's luminance\n// (softening with a white background would be lightening, with black it'd be darkening)\n// Strongen: opposite of soften\n\n// Luminance multiplier constants for generating shades of a given color\nconst WhiteShadeTableBG = [0.027, 0.043, 0.082, 0.145, 0.184, 0.216, 0.349, 0.537]; // white bg\nconst BlackTintTableBG = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black bg\nconst WhiteShadeTable = [0.537, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043, 0.027]; // white fg\nconst BlackTintTable = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black fg\nconst LumTintTable = [0.88, 0.77, 0.66, 0.55, 0.44, 0.33, 0.22, 0.11]; // light (strongen all)\nconst LumShadeTable = [0.11, 0.22, 0.33, 0.44, 0.55, 0.66, 0.77, 0.88]; // dark (soften all)\nconst ColorTintTable = [0.96, 0.84, 0.7, 0.4, 0.12]; // default soften\nconst ColorShadeTable = [0.1, 0.24, 0.44]; // default strongen\n\n// If the given shade's luminance is below/above these values, we'll swap to using the White/Black tables above\nconst LowLuminanceThreshold = 0.2;\nconst HighLuminanceThreshold = 0.8;\n\n/** Shades of a given color, from softest to strongest. */\nexport enum Shade {\n  Unshaded = 0,\n  Shade1 = 1,\n  Shade2 = 2,\n  Shade3 = 3,\n  Shade4 = 4,\n  Shade5 = 5,\n  Shade6 = 6,\n  Shade7 = 7,\n  Shade8 = 8,\n  // remember to update isValidShade()!\n}\n\n/**\n * Returns true if the argument is a valid Shade value\n * @param shade - The Shade value to validate.\n */\nexport function isValidShade(shade?: Shade): boolean {\n  return typeof shade === 'number' && shade >= Shade.Unshaded && shade <= Shade.Shade8;\n}\n\nfunction _isBlack(color: IColor): boolean {\n  return color.r === 0 && color.g === 0 && color.b === 0;\n}\n\nfunction _isWhite(color: IColor): boolean {\n  return color.r === MAX_COLOR_RGB && color.g === MAX_COLOR_RGB && color.b === MAX_COLOR_RGB;\n}\n\nfunction _darken(hsv: IHSV, factor: number): IHSV {\n  return {\n    h: hsv.h,\n    s: hsv.s,\n    v: clamp(hsv.v - hsv.v * factor, 100, 0),\n  };\n}\n\nfunction _lighten(hsv: IHSV, factor: number): IHSV {\n  return {\n    h: hsv.h,\n    s: clamp(hsv.s - hsv.s * factor, 100, 0),\n    v: clamp(hsv.v + (100 - hsv.v) * factor, 100, 0),\n  };\n}\n\nexport function isDark(color: IColor): boolean {\n  return hsv2hsl(color.h, color.s, color.v).l < 50;\n}\n\n/**\n * Given a color and a shade specification, generates the requested shade of the color.\n * Logic:\n * if white\n *  darken via tables defined above\n * if black\n *  lighten\n * if light\n *  strongen\n * if dark\n *  soften\n * else default\n *  soften or strongen depending on shade#\n * @param color - The base color whose shade is to be computed\n * @param shade - The shade of the base color to compute\n * @param isInverted - Default false. Whether the given theme is inverted (reverse strongen/soften logic)\n */\nexport function getShade(color: IColor, shade: Shade, isInverted: boolean = false): IColor | null {\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  const hsl = hsv2hsl(color.h, color.s, color.v);\n  let hsv = { h: color.h, s: color.s, v: color.v };\n  const tableIndex = shade - 1;\n  let _soften = _lighten;\n  let _strongen = _darken;\n  if (isInverted) {\n    _soften = _darken;\n    _strongen = _lighten;\n  }\n  if (_isWhite(color)) {\n    // white\n    hsv = _darken(hsv, WhiteShadeTable[tableIndex]);\n  } else if (_isBlack(color)) {\n    // black\n    hsv = _lighten(hsv, BlackTintTable[tableIndex]);\n  } else if (hsl.l / 100 > HighLuminanceThreshold) {\n    // light\n    hsv = _strongen(hsv, LumShadeTable[tableIndex]);\n  } else if (hsl.l / 100 < LowLuminanceThreshold) {\n    // dark\n    hsv = _soften(hsv, LumTintTable[tableIndex]);\n  } else {\n    // default\n    if (tableIndex < ColorTintTable.length) {\n      hsv = _soften(hsv, ColorTintTable[tableIndex]);\n    } else {\n      hsv = _strongen(hsv, ColorShadeTable[tableIndex - ColorTintTable.length]);\n    }\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), { a: color.a }));\n}\n\n// Background shades/tints are generated differently. The provided color will be guaranteed\n//   to be the darkest or lightest one. If it is <50% luminance, it will always be the darkest,\n//   otherwise it will always be the lightest.\nexport function getBackgroundShade(color: IColor, shade: Shade, isInverted: boolean = false): IColor | null {\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  let hsv = { h: color.h, s: color.s, v: color.v };\n  const tableIndex = shade - 1;\n  if (!isInverted) {\n    // lightish\n    hsv = _darken(hsv, WhiteShadeTableBG[tableIndex]);\n  } else {\n    // default: if (hsl.l / 100 < .5) { // darkish\n    hsv = _lighten(hsv, BlackTintTableBG[BlackTintTable.length - 1 - tableIndex]);\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), { a: color.a }));\n}\n\n/* Calculates the contrast ratio between two colors. Used for verifying\n * color pairs meet minimum accessibility requirements.\n * See: https://www.w3.org/TR/WCAG20/ section 1.4.3\n */\nexport function getContrastRatio(color1: IColor, color2: IColor): number {\n  // Formula defined by: http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html#contrast-ratiodef\n  // relative luminance: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n\n  /* calculate the intermediate value needed to calculating relative luminance */\n  function _getThing(x: number): number {\n    if (x <= 0.03928) {\n      return x / 12.92;\n    } else {\n      return Math.pow((x + 0.055) / 1.055, 2.4);\n    }\n  }\n\n  const r1 = _getThing(color1.r / MAX_COLOR_RGB);\n  const g1 = _getThing(color1.g / MAX_COLOR_RGB);\n  const b1 = _getThing(color1.b / MAX_COLOR_RGB);\n  let L1 = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1; // relative luminance of first color\n  L1 += 0.05;\n\n  const r2 = _getThing(color2.r / MAX_COLOR_RGB);\n  const g2 = _getThing(color2.g / MAX_COLOR_RGB);\n  const b2 = _getThing(color2.b / MAX_COLOR_RGB);\n  let L2 = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2; // relative luminance of second color\n  L2 += 0.05;\n\n  // return the lighter color divided by darker\n  return L1 / L2 > 1 ? L1 / L2 : L2 / L1;\n}\n"]},"metadata":{},"sourceType":"module"}