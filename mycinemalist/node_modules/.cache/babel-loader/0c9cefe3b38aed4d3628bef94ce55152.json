{"ast":null,"code":"import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n/**\n * Gets the first focusable element.\n *\n * @public\n */\n\nexport function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {\n  return getNextElement(rootElement, currentElement, true\n  /*checkNode*/\n  , false\n  /*suppressParentTraversal*/\n  , false\n  /*suppressChildTraversal*/\n  , includeElementsInFocusZones);\n}\n/**\n * Gets the last focusable element.\n *\n * @public\n */\n\nexport function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {\n  return getPreviousElement(rootElement, currentElement, true\n  /*checkNode*/\n  , false\n  /*suppressParentTraversal*/\n  , true\n  /*traverseChildren*/\n  , includeElementsInFocusZones);\n}\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\n\nexport function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {\n  if (checkNode === void 0) {\n    checkNode = true;\n  }\n\n  return getNextElement(rootElement, currentElement, checkNode, false\n  /*suppressParentTraversal*/\n  , false\n  /*suppressChildTraversal*/\n  , includeElementsInFocusZones, false\n  /*allowFocusRoot*/\n  , true\n  /*tabbable*/\n  );\n}\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\n\nexport function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {\n  if (checkNode === void 0) {\n    checkNode = true;\n  }\n\n  return getPreviousElement(rootElement, currentElement, checkNode, false\n  /*suppressParentTraversal*/\n  , true\n  /*traverseChildren*/\n  , includeElementsInFocusZones, false\n  /*allowFocusRoot*/\n  , true\n  /*tabbable*/\n  );\n}\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @returns True if focus was set, false if it was not.\n */\n\nexport function focusFirstChild(rootElement) {\n  var element = getNextElement(rootElement, rootElement, true, false, false, true);\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\n\nexport function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {\n  if (!currentElement || !allowFocusRoot && currentElement === rootElement) {\n    return null;\n  }\n\n  var isCurrentElementVisible = isElementVisible(currentElement); // Check its children.\n\n  if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n    if (childMatch) {\n      if (tabbable && isElementTabbable(childMatch, true) || !tabbable) {\n        return childMatch;\n      }\n\n      var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      var childMatchParent = childMatch.parentElement; // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n\n      while (childMatchParent && childMatchParent !== currentElement) {\n        var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  } // Check the current node, if it's not the first traversal.\n\n\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  } // Check its previous sibling.\n\n\n  var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  } // Check its parent.\n\n\n  if (!suppressParentTraversal) {\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);\n  }\n\n  return null;\n}\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\n\nexport function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable) {\n  if (!currentElement || currentElement === rootElement && suppressChildTraversal && !allowFocusRoot) {\n    return null;\n  }\n\n  var isCurrentElementVisible = isElementVisible(currentElement); // Check the current node, if it's not the first traversal.\n\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  } // Check its children.\n\n\n  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  } // Check its sibling.\n\n\n  var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n  }\n\n  return null;\n}\n/**\n * Determines if an element is visible.\n *\n * @public\n */\n\nexport function isElementVisible(element) {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE); // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  } // Fallback to other methods of determining actual visibility.\n\n\n  return element.offsetHeight !== 0 || element.offsetParent !== null || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  element.isVisible === true; // used as a workaround for testing.\n}\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\n\nexport function isElementTabbable(element, checkTabIndex) {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || element.disabled) {\n    return false;\n  }\n\n  var tabIndex = 0;\n  var tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n  var result = !!element && isFocusableAttribute !== 'false' && (element.tagName === 'A' || element.tagName === 'BUTTON' || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT' || isFocusableAttribute === 'true' || isTabIndexSet);\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\n\nexport function isElementFocusZone(element) {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\n\nexport function isElementFocusSubZone(element) {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\n\nexport function doesElementContainFocus(element) {\n  var document = getDocument(element);\n  var currentActiveElement = document && document.activeElement;\n\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\n\nexport function shouldWrapFocus(element, noWrapDataAttribute) {\n  return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;\n}\nvar targetToFocusOnNextRepaint = undefined;\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\n\nexport function focusAsync(element) {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n    var win = getWindow(element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(function () {\n        var focusableElement = targetToFocusOnNextRepaint; // We are done focusing for this frame, so reset the queued focus element\n\n        targetToFocusOnNextRepaint = undefined;\n\n        if (focusableElement) {\n          if (focusableElement.getAttribute && focusableElement.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n            // Normally, a FocusZone would be responsible for setting the tabindex values on all its descendants.\n            // However, even this animation frame callback can pre-empt the rendering of a FocusZone's child elements,\n            // so it may be necessary to set the tabindex directly here.\n            if (!focusableElement.getAttribute('tabindex')) {\n              focusableElement.setAttribute('tabindex', '0');\n            }\n          }\n\n          focusableElement.focus();\n        }\n      });\n    }\n  }\n}\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\n\nexport function getFocusableByIndexPath(parent, path) {\n  var element = parent;\n\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var index = path_1[_i];\n    var nextChild = element.children[Math.min(index, element.children.length - 1)];\n\n    if (!nextChild) {\n      break;\n    }\n\n    element = nextChild;\n  }\n\n  element = isElementTabbable(element) && isElementVisible(element) ? element : getNextElement(parent, element, true) || getPreviousElement(parent, element);\n  return element;\n}\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\n\nexport function getElementIndexPath(fromElement, toElement) {\n  var path = [];\n\n  while (toElement && fromElement && toElement !== fromElement) {\n    var parent_1 = getParent(toElement, true);\n\n    if (parent_1 === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));\n    toElement = parent_1;\n  }\n\n  return path;\n}","map":{"version":3,"mappings":"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","names":["elementContainsAttribute","elementContains","getParent","getWindow","getDocument","IS_FOCUSABLE_ATTRIBUTE","IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","getFirstFocusable","rootElement","currentElement","includeElementsInFocusZones","getNextElement","getLastFocusable","getPreviousElement","getFirstTabbable","checkNode","getLastTabbable","focusFirstChild","element","focusAsync","suppressParentTraversal","traverseChildren","allowFocusRoot","tabbable","isCurrentElementVisible","isElementVisible","isElementFocusZone","isElementFocusSubZone","childMatch","lastElementChild","isElementTabbable","childMatchSiblingMatch","previousElementSibling","childMatchParent","parentElement","childMatchParentMatch","siblingMatch","suppressChildTraversal","firstElementChild","nextElementSibling","getAttribute","visibilityAttribute","undefined","offsetHeight","offsetParent","isVisible","checkTabIndex","disabled","tabIndex","tabIndexAttributeValue","parseInt","isFocusableAttribute","isTabIndexSet","result","tagName","doesElementContainFocus","document","currentActiveElement","activeElement","shouldWrapFocus","noWrapDataAttribute","targetToFocusOnNextRepaint","win","requestAnimationFrame","focusableElement","setAttribute","focus","getFocusableByIndexPath","parent","path","_i","index","nextChild","children","Math","min","length","getElementIndexPath","fromElement","toElement","parent_1","unshift","Array","prototype","indexOf","call"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\src\\focus.ts"],"sourcesContent":["import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n  );\n}\n\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n  );\n}\n\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(rootElement: HTMLElement): boolean {\n  let element: HTMLElement | null = getNextElement(rootElement, rootElement, true, false, false, true);\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getPreviousElement(\n      rootElement,\n      currentElement.lastElementChild as HTMLElement,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        allowFocusRoot,\n        tabbable,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          allowFocusRoot,\n          tabbable,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getNextElement(\n      rootElement,\n      currentElement.firstElementChild as HTMLElement,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.tagName === 'SELECT' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet);\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element: HTMLElement): boolean {\n  let document = getDocument(element);\n  let currentActiveElement: HTMLElement | undefined = document && (document.activeElement as HTMLElement);\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(\n  element: HTMLElement,\n  noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n): boolean {\n  return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;\n}\n\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(() => {\n        const focusableElement = targetToFocusOnNextRepaint as HTMLElement | null;\n\n        // We are done focusing for this frame, so reset the queued focus element\n        targetToFocusOnNextRepaint = undefined;\n\n        if (focusableElement) {\n          if (focusableElement.getAttribute && focusableElement.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n            // Normally, a FocusZone would be responsible for setting the tabindex values on all its descendants.\n            // However, even this animation frame callback can pre-empt the rendering of a FocusZone's child elements,\n            // so it may be necessary to set the tabindex directly here.\n            if (!focusableElement.getAttribute('tabindex')) {\n              focusableElement.setAttribute('tabindex', '0');\n            }\n          }\n\n          focusableElement.focus();\n        }\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n\n  while (toElement && fromElement && toElement !== fromElement) {\n    const parent = getParent(toElement, true);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, toElement));\n    toElement = parent;\n  }\n\n  return path;\n}\n"]},"metadata":{},"sourceType":"module"}