{"ast":null,"code":"import { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, warnDeprecations, Async, EventGroup, assign, classNamesFunction, css, getDocument, getFirstFocusable, getId, getLastFocusable, getRTL, getWindow, KeyCodes, shouldWrapFocus, isIOS, isMac, initializeComponentRef, memoizeFunction } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction();\nexport function getSubmenuItems(item) {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250\n/* ms */\n;\nvar COMPONENT_NAME = 'ContextualMenu';\n\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArrays([styleProps, getItemStyles], styles));\n  };\n});\n\nvar ContextualMenuBase =\n/** @class */\nfunction (_super) {\n  __extends(ContextualMenuBase, _super);\n\n  function ContextualMenuBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._mounted = false;\n\n    _this.dismiss = function (ev, dismissAll) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev, dismissAll);\n      }\n    };\n\n    _this._tryFocusPreviousActiveElement = function (options) {\n      if (_this.props.onRestoreFocus) {\n        _this.props.onRestoreFocus(options);\n      } else {\n        if (options && options.containsFocus && _this._previousActiveElement) {\n          // Make sure that the focus method actually exists\n          // In some cases the object might exist but not be a real element.\n          // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n          if (_this._previousActiveElement.focus) {\n            _this._previousActiveElement.focus();\n          }\n        }\n      }\n    };\n\n    _this._onRenderMenuList = function (menuListProps, defaultRender) {\n      var indexCorrection = 0;\n      var items = menuListProps.items,\n          totalItemCount = menuListProps.totalItemCount,\n          hasCheckmarks = menuListProps.hasCheckmarks,\n          hasIcons = menuListProps.hasIcons,\n          role = menuListProps.role;\n      return React.createElement(\"ul\", {\n        className: _this._classNames.list,\n        onKeyDown: _this._onKeyDown,\n        onKeyUp: _this._onKeyUp,\n        role: role !== null && role !== void 0 ? role : 'menu'\n      }, items.map(function (item, index) {\n        var menuItem = _this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          indexCorrection += indexIncrease;\n        }\n\n        return menuItem;\n      }));\n    };\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n\n\n    _this._renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n      var _a;\n\n      var renderedItems = [];\n      var iconProps = item.iconProps || {\n        iconName: 'None'\n      };\n      var getItemClassNames = item.getItemClassNames,\n          // eslint-disable-line deprecation/deprecation\n      itemProps = item.itemProps;\n      var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n\n      var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : ''; // eslint-disable-next-line deprecation/deprecation\n\n      var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(_this.props.theme, isItemDisabled(item), _this.state.expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n      } else {\n        var itemStyleProps = {\n          theme: _this.props.theme,\n          disabled: isItemDisabled(item),\n          expanded: _this.state.expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName: dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled\n        }; // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n\n        itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = _this._classNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n          break;\n\n        case ContextualMenuItemType.Header:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n\n          var headerItem = _this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n\n          renderedItems.push(_this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n\n        case ContextualMenuItemType.Section:\n          renderedItems.push(_this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n          break;\n\n        default:\n          var menuItem = _this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n\n          renderedItems.push(_this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      } // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n\n\n      return React.createElement(React.Fragment, {\n        key: item.key\n      }, renderedItems);\n    };\n\n    _this._defaultMenuItemRenderer = function (item) {\n      var index = item.index,\n          focusableElementIndex = item.focusableElementIndex,\n          totalItemCount = item.totalItemCount,\n          hasCheckmarks = item.hasCheckmarks,\n          hasIcons = item.hasIcons;\n      return _this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    };\n\n    _this._onKeyDown = function (ev) {\n      // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n\n      var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n      return _this._keyHandler(ev, _this._shouldHandleKeyDown, dismissAllMenus);\n    };\n\n    _this._shouldHandleKeyDown = function (ev) {\n      return ev.which === KeyCodes.escape || _this._shouldCloseSubMenu(ev) || ev.which === KeyCodes.up && (ev.altKey || ev.metaKey);\n    };\n\n    _this._onMenuFocusCapture = function (ev) {\n      if (_this.props.delayUpdateFocusOnHover) {\n        _this._shouldUpdateFocusOnMouseEvent = true;\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      return _this._keyHandler(ev, _this._shouldHandleKeyUp, true\n      /* dismissAllMenus */\n      );\n    };\n    /**\n     * We close the menu on key up only if ALL of the following are true:\n     * - Most recent key down was alt or meta (command)\n     * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n     *   expand/collapse the menu)\n     * - We're not on a Mac (or iOS)\n     *\n     * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n     * closing any open context menus. There is not a similar behavior on Macs.\n     */\n\n\n    _this._shouldHandleKeyUp = function (ev) {\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n\n      _this._lastKeyDownWasAltOrMeta = false;\n      return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n    };\n    /**\n     * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n     * if so, stops event propagation and dismisses menu(s).\n     * @param ev - The keyboard event.\n     * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n     * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n     * Only does anything if `shouldHandleKey` returns true.\n     * @returns Whether the event was handled.\n     */\n\n\n    _this._keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n      var handled = false;\n\n      if (shouldHandleKey(ev)) {\n        _this._focusingPreviousElement = true;\n\n        _this.dismiss(ev, dismissAllMenus);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n        handled = true;\n      }\n\n      return handled;\n    };\n    /**\n     * Checks if the submenu should be closed\n     */\n\n\n    _this._shouldCloseSubMenu = function (ev) {\n      var submenuCloseKey = getRTL(_this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n      if (ev.which !== submenuCloseKey || !_this.props.isSubMenu) {\n        return false;\n      }\n\n      return _this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical || !!_this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap');\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      // Mark as handled if onKeyDown returns true (for handling collapse cases)\n      // or if we are attempting to expand a submenu\n      var handled = _this._onKeyDown(ev);\n\n      if (handled || !_this._host) {\n        return;\n      } // If we have a modifier key being pressed, we do not want to move focus.\n      // Otherwise, handle up and down keys.\n\n\n      var hasModifier = !!(ev.altKey || ev.metaKey);\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!hasModifier && (isUp || isDown)) {\n        var elementToFocus = isUp ? getLastFocusable(_this._host, _this._host.lastChild, true) : getFirstFocusable(_this._host, _this._host.firstChild, true);\n\n        if (elementToFocus) {\n          elementToFocus.focus();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, NavigationIdleDelay);\n    };\n\n    _this._onItemMouseEnterBase = function (item, ev, target) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onItemMouseMoveBase = function (item, ev, target) {\n      var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n      if (_this._shouldUpdateFocusOnMouseEvent) {\n        _this._gotMouseMove = true;\n      } else {\n        return;\n      }\n\n      if (!_this._isScrollIdle || _this._enterTimerId !== undefined || targetElement === _this._targetWindow.document.activeElement) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n\n      if (_this.state.expandedMenuItemKey !== undefined) {\n        return;\n      }\n      /**\n       * IE11 focus() method forces parents to scroll to top of element.\n       * Edge and IE expose a setActive() function for focusable divs that\n       * sets the page focus but does not scroll the parent element.\n       */\n\n\n      if (_this._host.setActive) {\n        try {\n          _this._host.setActive();\n        } catch (e) {\n          /* no-op */\n        }\n      } else {\n        _this._host.focus();\n      }\n    };\n\n    _this._onItemMouseDown = function (item, ev) {\n      if (item.onMouseDown) {\n        item.onMouseDown(item, ev);\n      }\n    };\n\n    _this._onItemClick = function (item, ev) {\n      _this._onItemClickBase(item, ev, ev.currentTarget);\n    };\n\n    _this._onItemClickBase = function (item, ev, target) {\n      var items = getSubmenuItems(item); // Cancel a async menu item hover timeout action from being taken and instead\n      // just trigger the click event instead.\n\n      _this._cancelSubMenuTimer();\n\n      if (!hasSubmenu(item) && (!items || !items.length)) {\n        // This is an item without a menu. Click it.\n        _this._executeItemClick(item, ev);\n      } else {\n        if (item.key !== _this.state.expandedMenuItemKey) {\n          // This has a collapsed sub menu. Expand it.\n          _this.setState({\n            // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n            // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n            // between a real click event and a keypress event (detail should be the number of mouse clicks).\n            // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n            // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n            // and \"\" for pressing \"Enter\" with Narrator on.\n            expandedByMouseClick: ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse'\n          });\n\n          _this._onItemSubMenuExpand(item, target);\n        }\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onAnchorClick = function (item, ev) {\n      _this._executeItemClick(item, ev);\n\n      ev.stopPropagation();\n    };\n\n    _this._executeItemClick = function (item, ev) {\n      if (item.disabled || item.isDisabled) {\n        return;\n      }\n\n      var dismiss = false;\n\n      if (item.onClick) {\n        dismiss = !!item.onClick(ev, item);\n      } else if (_this.props.onItemClick) {\n        dismiss = !!_this.props.onItemClick(ev, item);\n      }\n\n      if (dismiss || !ev.defaultPrevented) {\n        _this.dismiss(ev, true); // This should be removed whenever possible.\n        // This ensures that the hidden dismissal action maintains the same behavior.\n        // If the menu is being dismissed then the previously focused element should\n        // get focused since the dismiss was triggered by a user click on an item\n        // Rather than focus being lost.\n\n\n        _this._focusingPreviousElement = true;\n      }\n    };\n\n    _this._onItemKeyDown = function (item, ev) {\n      var openKey = getRTL(_this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n      if (!item.disabled && (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n        _this.setState({\n          expandedByMouseClick: false\n        });\n\n        _this._onItemSubMenuExpand(item, ev.currentTarget);\n\n        ev.preventDefault();\n      }\n    }; // Cancel a async menu item hover timeout action from being taken and instead\n    // do new upcoming behavior\n\n\n    _this._cancelSubMenuTimer = function () {\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n    };\n\n    _this._onItemSubMenuExpand = function (item, target) {\n      if (_this.state.expandedMenuItemKey !== item.key) {\n        if (_this.state.expandedMenuItemKey) {\n          _this._onSubMenuDismiss();\n        } // Focus the target to ensure when we close it, we're focusing on the correct element.\n\n\n        target.focus();\n\n        _this.setState({\n          expandedMenuItemKey: item.key,\n          submenuTarget: target\n        });\n      }\n    };\n    /**\n     * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n     * after the component is unmounted. The _mounted property is added to prevent\n     * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n     * code.\n     */\n\n\n    _this._onSubMenuDismiss = function (ev, dismissAll) {\n      if (dismissAll) {\n        _this.dismiss(ev, dismissAll);\n      } else if (_this._mounted) {\n        _this.setState({\n          dismissedMenuItemKey: _this.state.expandedMenuItemKey,\n          expandedMenuItemKey: undefined,\n          submenuTarget: undefined\n        });\n      }\n    };\n\n    _this._getSubMenuId = function (item) {\n      var subMenuId = _this.state.subMenuId;\n\n      if (item.subMenuProps && item.subMenuProps.id) {\n        subMenuId = item.subMenuProps.id;\n      }\n\n      return subMenuId;\n    };\n\n    _this._onPointerAndTouchEvent = function (ev) {\n      _this._cancelSubMenuTimer();\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles'\n    });\n    _this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu')\n    };\n    _this._id = props.id || getId('ContextualMenu');\n    _this._focusingPreviousElement = false;\n    _this._isScrollIdle = true;\n    _this._shouldUpdateFocusOnMouseEvent = !_this.props.delayUpdateFocusOnHover;\n    _this._gotMouseMove = false;\n    return _this;\n  }\n\n  ContextualMenuBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  };\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    if (newProps.target !== this.props.target) {\n      var newTarget = newProps.target;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n\n        this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n      }\n    }\n\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover; // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }; // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillMount = function () {\n    var target = this.props.target;\n\n    this._setTargetWindowAndElement(target);\n\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n    }\n  }; // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }; // Invoked immediately before a component is unmounted from the DOM.\n\n\n  ContextualMenuBase.prototype.componentWillUnmount = function () {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n\n    this._async.dispose();\n\n    this._mounted = false;\n  };\n\n  ContextualMenuBase.prototype.render = function () {\n    var _this = this;\n\n    var isBeakVisible = this.props.isBeakVisible;\n    var _a = this.props,\n        items = _a.items,\n        labelElementId = _a.labelElementId,\n        id = _a.id,\n        className = _a.className,\n        beakWidth = _a.beakWidth,\n        directionalHint = _a.directionalHint,\n        directionalHintForRTL = _a.directionalHintForRTL,\n        alignTargetEdge = _a.alignTargetEdge,\n        gapSpace = _a.gapSpace,\n        coverTarget = _a.coverTarget,\n        ariaLabel = _a.ariaLabel,\n        doNotLayer = _a.doNotLayer,\n        target = _a.target,\n        bounds = _a.bounds,\n        useTargetWidth = _a.useTargetWidth,\n        useTargetAsMinWidth = _a.useTargetAsMinWidth,\n        directionalHintFixed = _a.directionalHintFixed,\n        shouldFocusOnMount = _a.shouldFocusOnMount,\n        shouldFocusOnContainer = _a.shouldFocusOnContainer,\n        title = _a.title,\n        styles = _a.styles,\n        theme = _a.theme,\n        calloutProps = _a.calloutProps,\n        _b = _a.onRenderSubMenu,\n        onRenderSubMenu = _b === void 0 ? this._onRenderSubMenu : _b,\n        _c = _a.onRenderMenuList,\n        onRenderMenuList = _c === void 0 ? this._onRenderMenuList : _c,\n        focusZoneProps = _a.focusZoneProps,\n        // eslint-disable-next-line deprecation/deprecation\n    getMenuClassNames = _a.getMenuClassNames;\n    this._classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems) {\n      for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n        var item = contextualMenuItems_1[_i];\n\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = __assign(__assign({}, focusZoneProps), {\n      direction: this._getFocusZoneDirection()\n    });\n    var hasCheckmarks = canAnyMenuItemsCheck(items);\n    var submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n\n    var contextMenuStyle;\n    var targetAsHtmlElement = this._target;\n\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      var targetWidth = targetBoundingRect.width - 2\n      /* Accounts for 1px border */\n      ;\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth\n        };\n      }\n    } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n    if (items && items.length > 0) {\n      var totalItemCount = 0;\n\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      var calloutStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.callout : undefined;\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles,\n        onRestoreFocus: this._tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: this.props.onDismiss,\n        onScroll: this._onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: this.props.hidden\n      }), React.createElement(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        style: contextMenuStyle,\n        ref: function (host) {\n          return _this._host = host;\n        },\n        id: id,\n        className: this._classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: this._onMenuKeyDown,\n        onKeyUp: this._onKeyUp,\n        onFocusCapture: this._onMenuFocusCapture\n      }, title && React.createElement(\"div\", {\n        className: this._classNames.title\n      }, \" \", title, \" \"), items && items.length ? React.createElement(FocusZone, __assign({\n        className: this._classNames.root,\n        isCircularNavigation: true,\n        handleTabKey: FocusZoneTabbableElements.all\n      }, this._adjustedFocusZoneProps), onRenderMenuList({\n        items: items,\n        totalItemCount: totalItemCount,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: this._defaultMenuItemRenderer\n      }, this._onRenderMenuList)) : null, submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n\n\n  ContextualMenuBase.prototype._isHidden = function (props) {\n    return !!props.hidden;\n  };\n\n  ContextualMenuBase.prototype._onMenuOpened = function () {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  };\n\n  ContextualMenuBase.prototype._onMenuClosed = function () {\n    this._events.off(this._targetWindow, 'resize', this.dismiss); // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n\n\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover; // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined\n    });\n  };\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n\n\n  ContextualMenuBase.prototype._getFocusZoneDirection = function () {\n    var focusZoneProps = this.props.focusZoneProps;\n    return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;\n  };\n\n  ContextualMenuBase.prototype._onRenderSubMenu = function (subMenuProps, defaultRender) {\n    throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n  };\n\n  ContextualMenuBase.prototype._renderSectionItem = function (sectionItem, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _this = this;\n\n    var _a;\n\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n    var groupProps;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabellledby = '';\n\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + ((_a = sectionProps.title.text) === null || _a === void 0 ? void 0 : _a.replace(/\\s/g, ''));\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby\n        };\n        headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: this._classNames.list\n      }, sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true), headerItem && this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return _this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons);\n      }), sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true))));\n    }\n  };\n\n  ContextualMenuBase.prototype._renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  ContextualMenuBase.prototype._renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  ContextualMenuBase.prototype._renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), this.dismiss);\n    }\n\n    if (item.href) {\n      return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  ContextualMenuBase.prototype._renderHeaderMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, hasCheckmarks, hasIcons) {\n    var _a = this.props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n        id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (// eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: this._classNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: classNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? this._onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  };\n\n  ContextualMenuBase.prototype._renderAnchorMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuAnchor, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onAnchorClick,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderButtonItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderSplitButton = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuSplitButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss,\n      expandedMenuItemKey: expandedMenuItemKey,\n      onTap: this._onPointerAndTouchEvent\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n\n\n  ContextualMenuBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n\n  ContextualMenuBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  ContextualMenuBase.prototype._updateFocusOnMouseEvent = function (item, ev, target) {\n    var _this = this;\n\n    var targetElement = target ? target : ev.currentTarget;\n    var _a = this.props.subMenuHoverDelay,\n        timeoutDuration = _a === void 0 ? NavigationIdleDelay : _a;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n\n      this._enterTimerId = undefined;\n    } // If the menu is not expanded we can update focus without any delay\n\n\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(function () {\n        targetElement.focus();\n\n        _this.setState({\n          expandedByMouseClick: true\n        });\n\n        _this._onItemSubMenuExpand(item, targetElement);\n\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(function () {\n        _this._onSubMenuDismiss(ev);\n\n        targetElement.focus();\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  };\n\n  ContextualMenuBase.prototype._getSubmenuProps = function () {\n    var _a = this.state,\n        submenuTarget = _a.submenuTarget,\n        expandedMenuItemKey = _a.expandedMenuItemKey;\n\n    var item = this._findItemByKey(expandedMenuItemKey);\n\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item),\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  ContextualMenuBase.prototype._findItemByKey = function (key) {\n    var items = this.props.items;\n    return this._findItemByKeyFromItems(key, items);\n  };\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n\n\n  ContextualMenuBase.prototype._findItemByKeyFromItems = function (key, items) {\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        var match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  };\n\n  ContextualMenuBase.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement); // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if ( // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && ( // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target);\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  }; // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\n\n  ContextualMenuBase.defaultProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16\n  };\n  ContextualMenuBase = __decorate([withResponsiveMode], ContextualMenuBase);\n  return ContextualMenuBase;\n}(React.Component);\n\nexport { ContextualMenuBase };","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAGEC,sBAHF,QAQO,wBARP;AASA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SAASC,SAAT,EAAoBC,kBAApB,EAAyDC,yBAAzD,QAA0F,iBAA1F;AAEA,SACEC,aADF,EAEEC,cAFF,EAGEC,cAHF,EAIEC,gBAJF,EAKEC,KALF,EAMEC,UANF,EAOEC,MAPF,EAQEC,kBARF,EASEC,GATF,EAUEC,WAVF,EAWEC,iBAXF,EAYEC,KAZF,EAaEC,gBAbF,EAcEC,MAdF,EAeEC,SAfF,EAkBEC,QAlBF,EAmBEC,eAnBF,EAqBEC,KArBF,EAsBEC,KAtBF,EAuBEC,sBAvBF,EAwBEC,eAxBF,QAyBO,iBAzBP;AA0BA,SAASC,UAAT,EAAqBC,YAArB,EAAmCC,cAAnC,QAAyD,sCAAzD;AACA,SAASC,kBAAT,EAA6BC,cAA7B,QAAmD,+CAAnD;AACA,SAASC,OAAT,QAA0E,eAA1E;AACA,SAASC,kBAAT,QAAmC,sBAAnC;AACA,SACEC,yBADF,EAEEC,oBAFF,EAGEC,oBAHF,QAIO,mCAJP;AAKA,SAA6BC,wBAA7B,QAA6D,eAA7D;AAEA,SAASC,aAAT,QAA8B,6BAA9B;AAGA,IAAMC,aAAa,GAAG1B,kBAAkB,EAAxC;AACA,IAAM2B,+BAA+B,GAAG3B,kBAAkB,EAA1D;AAgBA,OAAM,SAAU4B,eAAV,CAA0BC,IAA1B,EAAmD;EACvD,OAAOA,IAAI,CAACC,YAAL,GAAoBD,IAAI,CAACC,YAAL,CAAkBC,KAAtC,GAA8CF,IAAI,CAACE,KAA1D;AACD;AAED;;;;AAGA,OAAM,SAAUC,oBAAV,CAA+BD,KAA/B,EAA2D;EAC/D,OAAOA,KAAK,CAACE,IAAN,CAAW,gBAAI;IACpB,IAAIJ,IAAI,CAACK,QAAT,EAAmB;MACjB,OAAO,IAAP;IACD,CAHmB,CAKpB;;;IACA,IAAIL,IAAI,CAACM,YAAL,IAAqBN,IAAI,CAACM,YAAL,CAAkBJ,KAAlB,CAAwBE,IAAxB,CAA6B,uBAAW;MAAI,kBAAW,CAACC,QAAZ,KAAyB,IAAzB;IAA6B,CAAzE,CAAzB,EAAqG;MACnG,OAAO,IAAP;IACD;;IAED,OAAO,KAAP;EACD,CAXM,CAAP;AAYD;AAED,IAAME,mBAAmB,GAAG;AAAI;AAAhC;AAEA,IAAMC,cAAc,GAAG,gBAAvB;;AAEA,IAAMC,0BAA0B,GAAGzB,eAAe,CAChD;EACE;;OAAA,yCAA2G;IAA3G0B;;;EAEA,OAAO,UAACC,UAAD,EAA0C;IAC/C,+BAAwB,MAAxB,CAAwB,MAAxB,EAAwBC,gBAACD,UAAD,EAAaf,aAAb,GAA+Bc,MAA/B,CAAxB;EAA8D,CADhE;AAED,CAN+C,CAAlD;;AAUA;AAAA;AAAA;EAAwCG;;EAgCtC,4BAAYC,KAAZ,EAAuC;IAAvC,YACEC,kBAAMD,KAAN,KAAY,IADd;;IARQE,iBAAW,KAAX;;IA+BDA,gBAAU,UAACC,EAAD,EAAWC,UAAX,EAA+B;MACtC;;MAER,IAAIC,SAAJ,EAAe;QACbA,SAAS,CAACF,EAAD,EAAKC,UAAL,CAAT;MACD;IACF,CANM;;IA+RCF,uCAAiC,UAACI,OAAD,EAIxC;MACC,IAAIJ,KAAI,CAACF,KAAL,CAAWO,cAAf,EAA+B;QAC7BL,KAAI,CAACF,KAAL,CAAWO,cAAX,CAA0BD,OAA1B;MACD,CAFD,MAEO;QACL,IAAIA,OAAO,IAAIA,OAAO,CAACE,aAAnB,IAAoCN,KAAI,CAACO,sBAA7C,EAAqE;UACnE;UACA;UACA;UACA,IAAIP,KAAI,CAACO,sBAAL,CAA4BC,KAAhC,EAAuC;YACrCR,KAAI,CAACO,sBAAL,CAA4BC,KAA5B;UACD;QACF;MACF;IACF,CAjBO;;IAwCAR,0BAAoB,UAC1BS,aAD0B,EAE1BC,aAF0B,EAE+B;MAEzD,IAAIC,eAAe,GAAG,CAAtB;MACQ;MAAA,IAAOC,6CAAP;MAAA,IAAuBC,2CAAvB;MAAA,IAAsCC,iCAAtC;MAAA,IAAgDC,yBAAhD;MACR,OACEzE;QAAI0E,SAAS,EAAEhB,KAAI,CAACiB,WAAL,CAAiBC,IAAhC;QAAsCC,SAAS,EAAEnB,KAAI,CAACoB,UAAtD;QAAkEC,OAAO,EAAErB,KAAI,CAACsB,QAAhF;QAA0FP,IAAI,EAAEA,IAAI,SAAJ,QAAI,WAAJ,UAAQ;MAAxG,GACG7B,KAAK,CAACqC,GAAN,CAAU,UAACvC,IAAD,EAAOwC,KAAP,EAAY;QACrB,IAAMC,QAAQ,GAAGzB,KAAI,CAAC0B,eAAL,CAAqB1C,IAArB,EAA2BwC,KAA3B,EAAkCb,eAAlC,EAAmDC,cAAnD,EAAmEC,aAAnE,EAAkFC,QAAlF,CAAjB;;QACA,IAAI9B,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAACqF,OAAzC,IAAoD5C,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAACsF,MAAjG,EAAyG;UACvG,IAAMC,aAAa,GAAG9C,IAAI,CAAC+C,wBAAL,GAAgC/C,IAAI,CAAC+C,wBAArC,GAAgE,CAAtF;UACApB,eAAe,IAAImB,aAAnB;QACD;;QACD,OAAOL,QAAP;MACD,CAPA,CADH,CADF;IAYD,CAlBO;IAoBR;;;;;;IAIQzB,wBAAkB,UACxBhB,IADwB,EAExBwC,KAFwB,EAGxBQ,qBAHwB,EAIxBpB,cAJwB,EAKxBC,aALwB,EAMxBC,QANwB,EAMP;;;MAEjB,IAAMmB,aAAa,GAAsB,EAAzC;MACA,IAAMC,SAAS,GAAGlD,IAAI,CAACkD,SAAL,IAAkB;QAAEC,QAAQ,EAAE;MAAZ,CAApC;MAEE;MAAA,IAAmB;MACnBC,0BADA;MAGF,IAAM1C,MAAM,GAAG0C,SAAS,GAAGA,SAAS,CAAC1C,MAAb,GAAsB2C,SAA9C,CARiB,CAUjB;MACA;;MACA,IAAMC,gBAAgB,GAAGtD,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAACqF,OAAzC,GAAmD5C,IAAI,CAACgC,SAAxD,GAAoEqB,SAA7F;MACA,IAAME,oBAAoB,GAAGvD,IAAI,CAACwD,gBAAL,GAAwBxD,IAAI,CAACwD,gBAAL,CAAsBxB,SAA9C,GAA0D,EAAvF,CAbiB,CAejB;;MACA,IAAIyB,cAAJ,CAhBiB,CAkBjB;MACA;;MACA,IAAIC,iBAAJ,EAAuB;QACrBD,cAAc,GAAGC,iBAAiB,CAChC1C,KAAI,CAACF,KAAL,CAAW6C,KADqB,EAEhCxE,cAAc,CAACa,IAAD,CAFkB,EAGhCgB,KAAI,CAAC4C,KAAL,CAAWC,mBAAX,KAAmC7D,IAAI,CAAC8D,GAHR,EAIhC,CAAC,CAAC5E,YAAY,CAACc,IAAD,CAJkB,EAKhC,CAAC,CAACA,IAAI,CAAC+D,IALyB,EAMhCb,SAAS,CAACC,QAAV,KAAuB,MANS,EAOhCnD,IAAI,CAACgC,SAP2B,EAQhCsB,gBARgC,EAShCJ,SAAS,CAAClB,SATsB,EAUhCuB,oBAVgC,EAWhCvD,IAAI,CAACgE,eAX2B,CAAlC;MAaD,CAdD,MAcO;QACL,IAAMC,cAAc,GAAkC;UACpDN,KAAK,EAAE3C,KAAI,CAACF,KAAL,CAAW6C,KADkC;UAEpDO,QAAQ,EAAE/E,cAAc,CAACa,IAAD,CAF4B;UAGpDmE,QAAQ,EAAEnD,KAAI,CAAC4C,KAAL,CAAWC,mBAAX,KAAmC7D,IAAI,CAAC8D,GAHE;UAIpDM,OAAO,EAAE,CAAC,CAAClF,YAAY,CAACc,IAAD,CAJ6B;UAKpDqE,YAAY,EAAE,CAAC,CAACrE,IAAI,CAAC+D,IAL+B;UAMpDO,SAAS,EAAEpB,SAAS,CAACC,QAAV,KAAuB,MANkB;UAOpDoB,aAAa,EAAEvE,IAAI,CAACgC,SAPgC;UAQpDsB,gBAAgB,kBARoC;UASpDkB,aAAa,EAAEtB,SAAS,CAAClB,SAT2B;UAUpDyC,gBAAgB,EAAElB,oBAVkC;UAWpDS,eAAe,EAAEhE,IAAI,CAACgE;QAX8B,CAAtD,CADK,CAeL;QACA;;QACAP,cAAc,GAAG3D,+BAA+B,CAC9CW,0BAA0B,OAACO,KAAI,CAACiB,WAAL,CAAiByC,kBAAlB,MAAoC,IAApC,IAAoCC,aAApC,GAAoC,MAApC,GAAoCA,GAAElC,QAAtC,EAAgD/B,MAAhD,CADoB,EAE9CuD,cAF8C,CAAhD;MAID,CAvDgB,CAyDjB;;;MACA,IAAIjE,IAAI,CAAC4E,IAAL,KAAc,GAAd,IAAqB5E,IAAI,CAAC6E,IAAL,KAAc,GAAvC,EAA4C;QAC1C7E,IAAI,CAAC2C,QAAL,GAAgBpF,sBAAsB,CAACqF,OAAvC;MACD;;MACD,QAAQ5C,IAAI,CAAC2C,QAAb;QACE,KAAKpF,sBAAsB,CAACqF,OAA5B;UACEK,aAAa,CAAC6B,IAAd,CAAmB9D,KAAI,CAAC+D,gBAAL,CAAsBvC,KAAtB,EAA6BiB,cAA7B,CAAnB;UACA;;QACF,KAAKlG,sBAAsB,CAACsF,MAA5B;UACEI,aAAa,CAAC6B,IAAd,CAAmB9D,KAAI,CAAC+D,gBAAL,CAAsBvC,KAAtB,EAA6BiB,cAA7B,CAAnB;;UACA,IAAMuB,UAAU,GAAGhE,KAAI,CAACiE,qBAAL,CAA2BjF,IAA3B,EAAiCyD,cAAjC,EAAiDjB,KAAjD,EAAwDX,aAAxD,EAAuEC,QAAvE,CAAnB;;UACAmB,aAAa,CAAC6B,IAAd,CAAmB9D,KAAI,CAACkE,eAAL,CAAqBF,UAArB,EAAiChF,IAAI,CAAC8D,GAAL,IAAYtB,KAA7C,EAAoDiB,cAApD,EAAoEzD,IAAI,CAACmF,KAAzE,CAAnB;UACA;;QACF,KAAK5H,sBAAsB,CAAC6H,OAA5B;UACEnC,aAAa,CAAC6B,IAAd,CAAmB9D,KAAI,CAACqE,kBAAL,CAAwBrF,IAAxB,EAA8ByD,cAA9B,EAA8CjB,KAA9C,EAAqDX,aAArD,EAAoEC,QAApE,CAAnB;UACA;;QACF;UACE,IAAMW,QAAQ,GAAGzB,KAAI,CAACsE,iBAAL,CACftF,IADe,EAEfyD,cAFe,EAGfjB,KAHe,EAIfQ,qBAJe,EAKfpB,cALe,EAMfC,aANe,EAOfC,QAPe,CAAjB;;UASAmB,aAAa,CAAC6B,IAAd,CAAmB9D,KAAI,CAACkE,eAAL,CAAqBzC,QAArB,EAA+BzC,IAAI,CAAC8D,GAAL,IAAYtB,KAA3C,EAAkDiB,cAAlD,EAAkEzD,IAAI,CAACmF,KAAvE,CAAnB;UACA;MAvBJ,CA7DiB,CAuFjB;MACA;;;MACA,OAAO7H,oBAACA,KAAK,CAACiI,QAAP,EAAe;QAACzB,GAAG,EAAE9D,IAAI,CAAC8D;MAAX,CAAf,EAAgCb,aAAhC,CAAP;IACD,CAhGO;;IAkGAjC,iCAA2B,UAAChB,IAAD,EAAqC;MAC9D;MAAA,IAAOgD,kDAAP;MAAA,IAA8BpB,oCAA9B;MAAA,IAA8CC,kCAA9C;MAAA,IAA6DC,wBAA7D;MACR,OAAOd,KAAI,CAAC0B,eAAL,CAAqB1C,IAArB,EAA2BwC,KAA3B,EAAkCQ,qBAAlC,EAAyDpB,cAAzD,EAAyEC,aAAzE,EAAwFC,QAAxF,CAAP;IACD,CAHO;;IAmTAd,mBAAa,UAACC,EAAD,EAAqC;MACxD;MACA;MACAD,KAAI,CAACwE,wBAAL,GAAgCxE,KAAI,CAACyE,YAAL,CAAkBxE,EAAlB,CAAhC,CAHwD,CAKxD;;MACA,IAAMyE,eAAe,GAAGzE,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAACiH,MAAtB,KAAiC9G,KAAK,MAAMD,KAAK,EAAjD,CAAxB;MAEA,OAAOmC,KAAI,CAAC6E,WAAL,CAAiB5E,EAAjB,EAAqBD,KAAI,CAAC8E,oBAA1B,EAAgDJ,eAAhD,CAAP;IACD,CATO;;IAWA1E,6BAAuB,UAACC,EAAD,EAAqC;MAClE,OACEA,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAACiH,MAAtB,IACA5E,KAAI,CAAC+E,mBAAL,CAAyB9E,EAAzB,CADA,IAECA,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAACqH,EAAtB,KAA6B/E,EAAE,CAACgF,MAAH,IAAahF,EAAE,CAACiF,OAA7C,CAHH;IAKD,CANO;;IAQAlF,4BAAsB,UAACC,EAAD,EAAkC;MAC9D,IAAID,KAAI,CAACF,KAAL,CAAWqF,uBAAf,EAAwC;QACtCnF,KAAI,CAACoF,8BAAL,GAAsC,IAAtC;MACD;IACF,CAJO;;IAMApF,iBAAW,UAACC,EAAD,EAAqC;MACtD,OAAOD,KAAI,CAAC6E,WAAL,CAAiB5E,EAAjB,EAAqBD,KAAI,CAACqF,kBAA1B,EAA8C;MAAK;MAAnD,CAAP;IACD,CAFO;IAIR;;;;;;;;;;;;IAUQrF,2BAAqB,UAACC,EAAD,EAAqC;MAChE,IAAMqF,wBAAwB,GAAGtF,KAAI,CAACwE,wBAAL,IAAiCxE,KAAI,CAACyE,YAAL,CAAkBxE,EAAlB,CAAlE;;MACAD,KAAI,CAACwE,wBAAL,GAAgC,KAAhC;MACA,OAAO,CAAC,CAACc,wBAAF,IAA8B,EAAEzH,KAAK,MAAMC,KAAK,EAAlB,CAArC;IACD,CAJO;IAaR;;;;;;;;;;;IASQkC,oBAAc,UACpBC,EADoB,EAEpBsF,eAFoB,EAGpBb,eAHoB,EAGK;MAEzB,IAAIc,OAAO,GAAG,KAAd;;MAEA,IAAID,eAAe,CAACtF,EAAD,CAAnB,EAAyB;QACvBD,KAAI,CAACyF,wBAAL,GAAgC,IAAhC;;QACAzF,KAAI,CAAC0F,OAAL,CAAazF,EAAb,EAAiByE,eAAjB;;QACAzE,EAAE,CAAC0F,cAAH;QACA1F,EAAE,CAAC2F,eAAH;QACAJ,OAAO,GAAG,IAAV;MACD;;MAED,OAAOA,OAAP;IACD,CAhBO;IAkBR;;;;;IAGQxF,4BAAsB,UAACC,EAAD,EAAqC;MACjE,IAAM4F,eAAe,GAAGpI,MAAM,CAACuC,KAAI,CAACF,KAAL,CAAW6C,KAAZ,CAAN,GAA2BhF,QAAQ,CAACmI,KAApC,GAA4CnI,QAAQ,CAACoI,IAA7E;;MAEA,IAAI9F,EAAE,CAAC0E,KAAH,KAAakB,eAAb,IAAgC,CAAC7F,KAAI,CAACF,KAAL,CAAWkG,SAAhD,EAA2D;QACzD,OAAO,KAAP;MACD;;MAED,OACEhG,KAAI,CAACiG,uBAAL,CAA6BC,SAA7B,KAA2CxJ,kBAAkB,CAACyJ,QAA9D,IACC,CAAC,CAACnG,KAAI,CAACiG,uBAAL,CAA6BG,cAA/B,IACC,CAACxI,eAAe,CAACqC,EAAE,CAACoG,MAAJ,EAA2B,yBAA3B,CAHpB;IAKD,CAZO;;IAcArG,uBAAiB,UAACC,EAAD,EAAqC;MAC5D;MACA;MACA,IAAMuF,OAAO,GAAGxF,KAAI,CAACoB,UAAL,CAAgBnB,EAAhB,CAAhB;;MAEA,IAAIuF,OAAO,IAAI,CAACxF,KAAI,CAACsG,KAArB,EAA4B;QAC1B;MACD,CAP2D,CAS5D;MACA;;;MACA,IAAMC,WAAW,GAAG,CAAC,EAAEtG,EAAE,CAACgF,MAAH,IAAahF,EAAE,CAACiF,OAAlB,CAArB;MACA,IAAMsB,IAAI,GAAGvG,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAACqH,EAAnC;MACA,IAAMyB,MAAM,GAAGxG,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAAC+I,IAArC;;MACA,IAAI,CAACH,WAAD,KAAiBC,IAAI,IAAIC,MAAzB,CAAJ,EAAsC;QACpC,IAAME,cAAc,GAAGH,IAAI,GACvBhJ,gBAAgB,CAACwC,KAAI,CAACsG,KAAN,EAAatG,KAAI,CAACsG,KAAL,CAAWM,SAAxB,EAAkD,IAAlD,CADO,GAEvBtJ,iBAAiB,CAAC0C,KAAI,CAACsG,KAAN,EAAatG,KAAI,CAACsG,KAAL,CAAWO,UAAxB,EAAmD,IAAnD,CAFrB;;QAIA,IAAIF,cAAJ,EAAoB;UAClBA,cAAc,CAACnG,KAAf;UACAP,EAAE,CAAC0F,cAAH;UACA1F,EAAE,CAAC2F,eAAH;QACD;MACF;IACF,CAzBO;IA2BR;;;;;;IAIQ5F,kBAAY;MAClB,IAAI,CAACA,KAAI,CAAC8G,aAAN,IAAuB9G,KAAI,CAAC+G,oBAAL,KAA8B1E,SAAzD,EAAoE;QAClErC,KAAI,CAACgH,MAAL,CAAYC,YAAZ,CAAyBjH,KAAI,CAAC+G,oBAA9B;;QACA/G,KAAI,CAAC+G,oBAAL,GAA4B1E,SAA5B;MACD,CAHD,MAGO;QACLrC,KAAI,CAAC8G,aAAL,GAAqB,KAArB;MACD;;MAED9G,KAAI,CAAC+G,oBAAL,GAA4B/G,KAAI,CAACgH,MAAL,CAAYE,UAAZ,CAAuB;QACjDlH,KAAI,CAAC8G,aAAL,GAAqB,IAArB;MACD,CAF2B,EAEzBvH,mBAFyB,CAA5B;IAGD,CAXO;;IAaAS,8BAAwB,UAAChB,IAAD,EAAYiB,EAAZ,EAA+CoG,MAA/C,EAAmE;MACjG,IAAIrG,KAAI,CAACmH,uBAAL,EAAJ,EAAoC;QAClC;MACD;;MAEDnH,KAAI,CAACoH,wBAAL,CAA8BpI,IAA9B,EAAoCiB,EAApC,EAAwCoG,MAAxC;IACD,CANO;;IAQArG,6BAAuB,UAAChB,IAAD,EAAYiB,EAAZ,EAA+CoG,MAA/C,EAAkE;MAC/F,IAAMgB,aAAa,GAAGpH,EAAE,CAACqH,aAAzB,CAD+F,CAG/F;;MACA,IAAItH,KAAI,CAACoF,8BAAT,EAAyC;QACvCpF,KAAI,CAACuH,aAAL,GAAqB,IAArB;MACD,CAFD,MAEO;QACL;MACD;;MAED,IACE,CAACvH,KAAI,CAAC8G,aAAN,IACA9G,KAAI,CAACwH,aAAL,KAAuBnF,SADvB,IAEAgF,aAAa,KAAMrH,KAAI,CAACyH,aAAL,CAAmBC,QAAnB,CAA4BC,aAHjD,EAIE;QACA;MACD;;MAED3H,KAAI,CAACoH,wBAAL,CAA8BpI,IAA9B,EAAoCiB,EAApC,EAAwCoG,MAAxC;IACD,CAnBO;;IAyBArG,0BAAoB,UAAChB,IAAD,EAAYiB,EAAZ,EAA6C;MACvE,IAAID,KAAI,CAACmH,uBAAL,EAAJ,EAAoC;QAClC;MACD;;MAED,IAAInH,KAAI,CAACwH,aAAL,KAAuBnF,SAA3B,EAAsC;QACpCrC,KAAI,CAACgH,MAAL,CAAYC,YAAZ,CAAyBjH,KAAI,CAACwH,aAA9B;;QACAxH,KAAI,CAACwH,aAAL,GAAqBnF,SAArB;MACD;;MAED,IAAIrC,KAAI,CAAC4C,KAAL,CAAWC,mBAAX,KAAmCR,SAAvC,EAAkD;QAChD;MACD;MAED;;;;;;;MAKA,IAAKrC,KAAI,CAACsG,KAAL,CAAmBsB,SAAxB,EAAmC;QACjC,IAAI;UACD5H,KAAI,CAACsG,KAAL,CAAmBsB,SAAnB;QACF,CAFD,CAEE,OAAOC,CAAP,EAAU;UACV;QACD;MACF,CAND,MAMO;QACL7H,KAAI,CAACsG,KAAL,CAAW9F,KAAX;MACD;IACF,CA5BO;;IA0EAR,yBAAmB,UAAChB,IAAD,EAA4BiB,EAA5B,EAA6D;MACtF,IAAIjB,IAAI,CAAC8I,WAAT,EAAsB;QACpB9I,IAAI,CAAC8I,WAAL,CAAiB9I,IAAjB,EAAuBiB,EAAvB;MACD;IACF,CAJO;;IAMAD,qBAAe,UACrBhB,IADqB,EAErBiB,EAFqB,EAE+C;MAEpED,KAAI,CAAC+H,gBAAL,CAAsB/I,IAAtB,EAA4BiB,EAA5B,EAAgCA,EAAE,CAACqH,aAAnC;IACD,CALO;;IAOAtH,yBAAmB,UACzBhB,IADyB,EAEzBiB,EAFyB,EAGzBoG,MAHyB,EAGN;MAEnB,IAAMnH,KAAK,GAAGH,eAAe,CAACC,IAAD,CAA7B,CAFmB,CAInB;MACA;;MACAgB,KAAI,CAACgI,mBAAL;;MAEA,IAAI,CAAC/J,UAAU,CAACe,IAAD,CAAX,KAAsB,CAACE,KAAD,IAAU,CAACA,KAAK,CAAC+I,MAAvC,CAAJ,EAAoD;QAClD;QACAjI,KAAI,CAACkI,iBAAL,CAAuBlJ,IAAvB,EAA6BiB,EAA7B;MACD,CAHD,MAGO;QACL,IAAIjB,IAAI,CAAC8D,GAAL,KAAa9C,KAAI,CAAC4C,KAAL,CAAWC,mBAA5B,EAAiD;UAC/C;UACA7C,KAAI,CAACmI,QAAL,CAAc;YACZ;YACA;YACA;YACA;YACA;YACA;YACAC,oBAAoB,EAAEnI,EAAE,CAACoI,WAAH,CAAeC,MAAf,KAA0B,CAA1B,IAAgCrI,EAAE,CAACoI,WAAH,CAAgCE,WAAhC,KAAgD;UAP1F,CAAd;;UASAvI,KAAI,CAACwI,oBAAL,CAA0BxJ,IAA1B,EAAgCqH,MAAhC;QACD;MACF;;MAEDpG,EAAE,CAAC2F,eAAH;MACA3F,EAAE,CAAC0F,cAAH;IACD,CAhCO;;IAkCA3F,uBAAiB,UAAChB,IAAD,EAA4BiB,EAA5B,EAA6D;MACpFD,KAAI,CAACkI,iBAAL,CAAuBlJ,IAAvB,EAA6BiB,EAA7B;;MACAA,EAAE,CAAC2F,eAAH;IACD,CAHO;;IAKA5F,0BAAoB,UAC1BhB,IAD0B,EAE1BiB,EAF0B,EAE0C;MAEpE,IAAIjB,IAAI,CAACkE,QAAL,IAAiBlE,IAAI,CAACyJ,UAA1B,EAAsC;QACpC;MACD;;MAED,IAAI/C,OAAO,GAAG,KAAd;;MACA,IAAI1G,IAAI,CAAC0J,OAAT,EAAkB;QAChBhD,OAAO,GAAG,CAAC,CAAC1G,IAAI,CAAC0J,OAAL,CAAazI,EAAb,EAAiBjB,IAAjB,CAAZ;MACD,CAFD,MAEO,IAAIgB,KAAI,CAACF,KAAL,CAAW6I,WAAf,EAA4B;QACjCjD,OAAO,GAAG,CAAC,CAAC1F,KAAI,CAACF,KAAL,CAAW6I,WAAX,CAAuB1I,EAAvB,EAA2BjB,IAA3B,CAAZ;MACD;;MAED,IAAI0G,OAAO,IAAI,CAACzF,EAAE,CAAC2I,gBAAnB,EAAqC;QACnC5I,KAAI,CAAC0F,OAAL,CAAazF,EAAb,EAAiB,IAAjB,EADmC,CAGnC;QACA;QACA;QACA;QACA;;;QACAD,KAAI,CAACyF,wBAAL,GAAgC,IAAhC;MACD;IACF,CAzBO;;IA2BAzF,uBAAiB,UAAChB,IAAD,EAAYiB,EAAZ,EAAgD;MACvE,IAAM4I,OAAO,GAAGpL,MAAM,CAACuC,KAAI,CAACF,KAAL,CAAW6C,KAAZ,CAAN,GAA2BhF,QAAQ,CAACoI,IAApC,GAA2CpI,QAAQ,CAACmI,KAApE;;MAEA,IACE,CAAC9G,IAAI,CAACkE,QAAN,KACCjD,EAAE,CAAC0E,KAAH,KAAakE,OAAb,IAAwB5I,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAACmL,KAA9C,IAAwD7I,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAAC+I,IAAtB,KAA+BzG,EAAE,CAACgF,MAAH,IAAahF,EAAE,CAACiF,OAA/C,CADzD,CADF,EAGE;QACAlF,KAAI,CAACmI,QAAL,CAAc;UACZC,oBAAoB,EAAE;QADV,CAAd;;QAGApI,KAAI,CAACwI,oBAAL,CAA0BxJ,IAA1B,EAAgCiB,EAAE,CAACqH,aAAnC;;QACArH,EAAE,CAAC0F,cAAH;MACD;IACF,CAbO,CAjlC+B,CAgmCvC;IACA;;;IACQ3F,4BAAsB;MAC5B,IAAIA,KAAI,CAACwH,aAAL,KAAuBnF,SAA3B,EAAsC;QACpCrC,KAAI,CAACgH,MAAL,CAAYC,YAAZ,CAAyBjH,KAAI,CAACwH,aAA9B;;QACAxH,KAAI,CAACwH,aAAL,GAAqBnF,SAArB;MACD;IACF,CALO;;IAOArC,6BAAuB,UAAChB,IAAD,EAA4BqH,MAA5B,EAA+C;MAC5E,IAAIrG,KAAI,CAAC4C,KAAL,CAAWC,mBAAX,KAAmC7D,IAAI,CAAC8D,GAA5C,EAAiD;QAC/C,IAAI9C,KAAI,CAAC4C,KAAL,CAAWC,mBAAf,EAAoC;UAClC7C,KAAI,CAAC+I,iBAAL;QACD,CAH8C,CAK/C;;;QACA1C,MAAM,CAAC7F,KAAP;;QACAR,KAAI,CAACmI,QAAL,CAAc;UACZtF,mBAAmB,EAAE7D,IAAI,CAAC8D,GADd;UAEZkG,aAAa,EAAE3C;QAFH,CAAd;MAID;IACF,CAbO;IAiER;;;;;;;;IAMQrG,0BAAoB,UAACC,EAAD,EAAWC,UAAX,EAA+B;MACzD,IAAIA,UAAJ,EAAgB;QACdF,KAAI,CAAC0F,OAAL,CAAazF,EAAb,EAAiBC,UAAjB;MACD,CAFD,MAEO,IAAIF,KAAI,CAACiJ,QAAT,EAAmB;QACxBjJ,KAAI,CAACmI,QAAL,CAAc;UACZe,oBAAoB,EAAElJ,KAAI,CAAC4C,KAAL,CAAWC,mBADrB;UAEZA,mBAAmB,EAAER,SAFT;UAGZ2G,aAAa,EAAE3G;QAHH,CAAd;MAKD;IACF,CAVO;;IA6CArC,sBAAgB,UAAChB,IAAD,EAA0B;MAC1C;;MAEN,IAAIA,IAAI,CAACC,YAAL,IAAqBD,IAAI,CAACC,YAAL,CAAkBkK,EAA3C,EAA+C;QAC7CC,SAAS,GAAGpK,IAAI,CAACC,YAAL,CAAkBkK,EAA9B;MACD;;MAED,OAAOC,SAAP;IACD,CARO;;IAUApJ,gCAA0B,UAACC,EAAD,EAAiD;MACjFD,KAAI,CAACgI,mBAAL;IACD,CAFO;;IApuCNhI,KAAI,CAACgH,MAAL,GAAc,IAAIhK,KAAJ,CAAUgD,KAAV,CAAd;IACAA,KAAI,CAACqJ,OAAL,GAAe,IAAIpM,UAAJ,CAAe+C,KAAf,CAAf;IACAjC,sBAAsB,CAACiC,KAAD,CAAtB;IAEAjD,gBAAgB,CAACyC,cAAD,EAAiBM,KAAjB,EAAwB;MACtCwJ,iBAAiB,EAAE;IADmB,CAAxB,CAAhB;IAIAtJ,KAAI,CAAC4C,KAAL,GAAa;MACX2G,mBAAmB,EAAElH,SADV;MAEX+G,SAAS,EAAE7L,KAAK,CAAC,gBAAD;IAFL,CAAb;IAKAyC,KAAI,CAACwJ,GAAL,GAAW1J,KAAK,CAACqJ,EAAN,IAAY5L,KAAK,CAAC,gBAAD,CAA5B;IACAyC,KAAI,CAACyF,wBAAL,GAAgC,KAAhC;IACAzF,KAAI,CAAC8G,aAAL,GAAqB,IAArB;IACA9G,KAAI,CAACoF,8BAAL,GAAsC,CAACpF,KAAI,CAACF,KAAL,CAAWqF,uBAAlD;IACAnF,KAAI,CAACuH,aAAL,GAAqB,KAArB;;EACD;;EAUMkC,qDAAP,UAA6BC,QAA7B,EAA6DC,QAA7D,EAA2F;IACzF,IAAI,CAACD,QAAQ,CAACE,sBAAV,IAAoC,KAAK9J,KAAL,CAAW+J,MAA/C,IAAyDH,QAAQ,CAACG,MAAtE,EAA8E;MAC5E;MACA,OAAO,KAAP;IACD;;IAED,OAAO,CAAC/M,cAAc,CAAC,KAAKgD,KAAN,EAAa4J,QAAb,CAAf,IAAyC,CAAC5M,cAAc,CAAC,KAAK8F,KAAN,EAAa+G,QAAb,CAA/D;EACD,CAPM;;EASAF,0DAAP,UAAkCC,QAAlC,EAAgE;IAC9D,IAAIA,QAAQ,CAACrD,MAAT,KAAoB,KAAKvG,KAAL,CAAWuG,MAAnC,EAA2C;MACzC,IAAMyD,SAAS,GAAGJ,QAAQ,CAACrD,MAA3B;;MACA,KAAK0D,0BAAL,CAAgCD,SAAhC;IACD;;IAED,IAAI,KAAKE,SAAL,CAAeN,QAAf,MAA6B,KAAKM,SAAL,CAAe,KAAKlK,KAApB,CAAjC,EAA6D;MAC3D,IAAI,KAAKkK,SAAL,CAAeN,QAAf,CAAJ,EAA8B;QAC5B,KAAKO,aAAL;MACD,CAFD,MAEO;QACL,KAAKC,aAAL;;QACA,KAAK3J,sBAAL,GAA8B,KAAKkH,aAAL,GACzB,KAAKA,aAAL,CAAmBC,QAAnB,CAA4BC,aADH,GAE1BtF,SAFJ;MAGD;IACF;;IACD,IAAIqH,QAAQ,CAACvE,uBAAT,KAAqC,KAAKrF,KAAL,CAAWqF,uBAApD,EAA6E;MAC3E;MACA,KAAKC,8BAAL,GAAsC,CAACsE,QAAQ,CAACvE,uBAAhD,CAF2E,CAI3E;;MACA,KAAKoC,aAAL,GAAqB,KAAKnC,8BAAL,IAAuC,KAAKmC,aAAjE;IACD;EACF,CAvBM,CAxET,CAiGE;;;EACOkC,yDAAP;IACE,IAAMpD,MAAM,GAAG,KAAKvG,KAAL,CAAWuG,MAA1B;;IACA,KAAK0D,0BAAL,CAAgC1D,MAAhC;;IACA,IAAI,CAAC,KAAKvG,KAAL,CAAW+J,MAAhB,EAAwB;MACtB,KAAKtJ,sBAAL,GAA8B,KAAKkH,aAAL,GACzB,KAAKA,aAAL,CAAmBC,QAAnB,CAA4BC,aADH,GAE1BtF,SAFJ;IAGD;EACF,CARM,CAlGT,CA4GE;;;EACOoH,iDAAP;IACE,IAAI,CAAC,KAAK3J,KAAL,CAAW+J,MAAhB,EAAwB;MACtB,KAAKK,aAAL;IACD;;IAED,KAAKjB,QAAL,GAAgB,IAAhB;EACD,CANM,CA7GT,CAqHE;;;EACOQ,oDAAP;IACE,IAAI,KAAK3J,KAAL,CAAWqK,eAAf,EAAgC;MAC9B,KAAKrK,KAAL,CAAWqK,eAAX,CAA2B,KAAKrK,KAAhC;IACD;;IAED,KAAKuJ,OAAL,CAAae,OAAb;;IACA,KAAKpD,MAAL,CAAYoD,OAAZ;;IACA,KAAKnB,QAAL,GAAgB,KAAhB;EACD,CARM;;EAUAQ,sCAAP;IAAA;;IACQ;IAEA;IAAA,IACJvK,gBADI;IAAA,IAEJmL,kCAFI;IAAA,IAGJlB,UAHI;IAAA,IAIJnI,wBAJI;IAAA,IAKJsJ,wBALI;IAAA,IAMJC,oCANI;IAAA,IAOJC,gDAPI;IAAA,IAQJC,oCARI;IAAA,IASJC,sBATI;IAAA,IAUJC,4BAVI;IAAA,IAWJC,wBAXI;IAAA,IAYJC,0BAZI;IAAA,IAaJxE,kBAbI;IAAA,IAcJyE,kBAdI;IAAA,IAeJC,kCAfI;IAAA,IAgBJC,4CAhBI;IAAA,IAiBJC,8CAjBI;IAAA,IAkBJC,0CAlBI;IAAA,IAmBJC,kDAnBI;IAAA,IAoBJhH,gBApBI;IAAA,IAqBJzE,kBArBI;IAAA,IAsBJiD,gBAtBI;IAAA,IAuBJyI,8BAvBI;IAAA,IAwBJC,uBAxBI;IAAA,IAwBJC,4DAxBI;IAAA,IAyBJC,wBAzBI;IAAA,IAyBJC,8DAzBI;IAAA,IA0BJC,kCA1BI;IAAA,IA2BJ;IACAnC,wCA5BI;IA+BN,KAAKrI,WAAL,GAAmBqI,iBAAiB,GAChCA,iBAAiB,CAAC3G,KAAD,EAAS3B,SAAT,CADe,GAEhCnC,aAAa,CAACa,MAAD,EAAS;MACpBiD,KAAK,EAAEA,KADa;MAEpB3B,SAAS,EAAEA;IAFS,CAAT,CAFjB;IAOA,IAAMF,QAAQ,GAAG4K,cAAc,CAACxM,KAAD,CAA/B;;IAEA,SAASwM,cAAT,CAAwBnC,mBAAxB,EAAkE;MAChE,KAAmB,uDAAnB,EAAmBoC,iCAAnB,EAAmBA,IAAnB,EAAwC;QAAnC,IAAM3M,IAAI,4BAAV;;QACH,IAAIA,IAAI,CAACkD,SAAT,EAAoB;UAClB,OAAO,IAAP;QACD;;QAED,IACElD,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAAC6H,OAAzC,IACApF,IAAI,CAACM,YADL,IAEAoM,cAAc,CAAC1M,IAAI,CAACM,YAAL,CAAkBJ,KAAnB,CAHhB,EAIE;UACA,OAAO,IAAP;QACD;MACF;;MAED,OAAO,KAAP;IACD;;IAED,KAAK+G,uBAAL,GAA4B2F,sBAAQH,cAAR,GAAsB;MAAEvF,SAAS,EAAE,KAAK2F,sBAAL;IAAb,CAAtB,CAA5B;IAEA,IAAMhL,aAAa,GAAG1B,oBAAoB,CAACD,KAAD,CAA1C;IACA,IAAM4M,YAAY,GAAG,KAAKlJ,KAAL,CAAWC,mBAAX,IAAkC,KAAK/C,KAAL,CAAW+J,MAAX,KAAsB,IAAxD,GAA+D,KAAKkC,gBAAL,EAA/D,GAAyF,IAA9G;IAEAC,aAAa,GAAGA,aAAa,KAAK3J,SAAlB,GAA8B,KAAKvC,KAAL,CAAWmM,cAAX,IAA8B5N,cAAc,CAAC6N,MAA3E,GAAoFF,aAApG;IACA;;;;IAGA,IAAIG,gBAAJ;IACA,IAAMC,mBAAmB,GAAG,KAAKC,OAAjC;;IACA,IAAI,CAACtB,cAAc,IAAIC,mBAAnB,KAA2CoB,mBAA3C,IAAkEA,mBAAmB,CAACE,WAA1F,EAAuG;MACrG,IAAMC,kBAAkB,GAAGH,mBAAmB,CAACI,qBAApB,EAA3B;MACA,IAAMC,WAAW,GAAGF,kBAAkB,CAACG,KAAnB,GAA2B;MAAE;MAAjD;;MAEA,IAAI3B,cAAJ,EAAoB;QAClBoB,gBAAgB,GAAG;UACjBO,KAAK,EAAED;QADU,CAAnB;MAGD,CAJD,MAIO,IAAIzB,mBAAJ,EAAyB;QAC9BmB,gBAAgB,GAAG;UACjBQ,QAAQ,EAAEF;QADO,CAAnB;MAGD;IACF,CArFH,CAuFE;;;IACA,IAAIvN,KAAK,IAAIA,KAAK,CAAC+I,MAAN,GAAe,CAA5B,EAA+B;MAC7B,IAAIrH,cAAc,GAAG,CAArB;;MACA,KAAmB,2BAAnB,EAAmB+K,mBAAnB,EAAmBA,IAAnB,EAA0B;QAArB,IAAM3M,IAAI,cAAV;;QACH,IAAIA,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAACqF,OAAzC,IAAoD5C,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAACsF,MAAjG,EAAyG;UACvG,IAAM+K,SAAS,GAAG5N,IAAI,CAAC+C,wBAAL,GAAgC/C,IAAI,CAAC+C,wBAArC,GAAgE,CAAlF;UACAnB,cAAc,IAAIgM,SAAlB;QACD;MACF;;MAED,IAAMC,aAAa,GAAG,KAAK5L,WAAL,CAAiByC,kBAAjB,GACjB,KAAKzC,WAAL,CAAiByC,kBAAjB,CAAoCoJ,OADnB,GAKlBzK,SALJ;MAOA,OACE/F,oBAACgC,OAAD,EAAQsN;QACNlM,MAAM,EAAEmN,aADF;QAENxM,cAAc,EAAE,KAAK0M;MAFf,GAGF3B,YAHE,EAGU;QAChB/E,MAAM,EAAEA,MADQ;QAEhB2F,aAAa,EAAEA,aAFC;QAGhB1B,SAAS,EAAEA,SAHK;QAIhBC,eAAe,EAAEA,eAJD;QAKhBC,qBAAqB,EAAEA,qBALP;QAMhBE,QAAQ,EAAEA,QANM;QAOhBC,WAAW,EAAEA,WAPG;QAQhBE,UAAU,EAAEA,UARI;QAShB7J,SAAS,EAAE5D,GAAG,CAAC,2BAAD,EAA8BgO,YAAY,IAAIA,YAAY,CAACpK,SAA3D,CATE;QAUhBgM,eAAe,EAAE9B,kBAVD;QAWhB/K,SAAS,EAAE,KAAKL,KAAL,CAAWK,SAXN;QAYhB8M,QAAQ,EAAE,KAAKC,SAZC;QAahBpC,MAAM,EAAEA,MAbQ;QAchBG,oBAAoB,EAAEA,oBAdN;QAehBR,eAAe,EAAEA,eAfD;QAgBhBZ,MAAM,EAAE,KAAK/J,KAAL,CAAW+J;MAhBH,CAHV,CAAR,EAqBEvN;QAAA,cACcsO,SADd;QACuB,mBACJP,cAFnB;QAGE8C,KAAK,EAAEhB,gBAHT;QAIEiB,GAAG,EAAE,UAACC,IAAD,EAAqB;UAAK,OAACrN,KAAI,CAACsG,KAAL,GAAa+G,IAAd;QAAmB,CAJpD;QAKElE,EAAE,EAAEA,EALN;QAMEnI,SAAS,EAAE,KAAKC,WAAL,CAAiBqM,SAN9B;QAOEC,QAAQ,EAAEpC,sBAAsB,GAAG,CAAH,GAAO,CAAC,CAP1C;QAQEhK,SAAS,EAAE,KAAKqM,cARlB;QASEnM,OAAO,EAAE,KAAKC,QAThB;QAUEmM,cAAc,EAAE,KAAKC;MAVvB,GAYGvJ,KAAK,IAAI7H;QAAK0E,SAAS,EAAE,KAAKC,WAAL,CAAiBkD;MAAjC,QAA0CA,KAA1C,MAZZ,EAaGjF,KAAK,IAAIA,KAAK,CAAC+I,MAAf,GACC3L,oBAACG,SAAD,EAAUmP;QACR5K,SAAS,EAAE,KAAKC,WAAL,CAAiB0M,IADpB;QAERC,oBAAoB,EAAE,IAFd;QAGRC,YAAY,EAAElR,yBAAyB,CAACmR;MAHhC,GAIJ,KAAK7H,uBAJD,CAAV,EAMGuF,gBAAgB,CACf;QACEtM,KAAK,OADP;QAEE0B,cAAc,gBAFhB;QAGEC,aAAa,eAHf;QAIEC,QAAQ,UAJV;QAKEiN,uBAAuB,EAAE,KAAKC;MALhC,CADe,EAQf,KAAKC,iBARU,CANnB,CADD,GAkBG,IA/BN,EAgCGnC,YAAY,IAAIR,eAAe,CAACQ,YAAD,EAAe,KAAKoC,gBAApB,CAhClC,CArBF,CADF;IA0DD,CA1ED,MA0EO;MACL,OAAO,IAAP;IACD;EACF,CArKM;EAuKP;;;;;;;EAKQzE,yCAAR,UAAkB3J,KAAlB,EAA6C;IAC3C,OAAO,CAAC,CAACA,KAAK,CAAC+J,MAAf;EACD,CAFO;;EAIAJ,6CAAR;IACE,KAAKJ,OAAL,CAAa8E,EAAb,CAAgB,KAAK1G,aAArB,EAAoC,QAApC,EAA8C,KAAK/B,OAAnD;;IACA,KAAKN,8BAAL,GAAsC,CAAC,KAAKtF,KAAL,CAAWqF,uBAAlD;IACA,KAAKoC,aAAL,GAAqB,KAArB;IACA,KAAKzH,KAAL,CAAWsO,YAAX,IAA2B,KAAKtO,KAAL,CAAWsO,YAAX,CAAwB,KAAKtO,KAA7B,CAA3B;EACD,CALO;;EAOA2J,6CAAR;IACE,KAAKJ,OAAL,CAAagF,GAAb,CAAiB,KAAK5G,aAAtB,EAAqC,QAArC,EAA+C,KAAK/B,OAApD,EADF,CAGE;IACA;IACA;IACA;;;IACA,KAAKqH,8BAAL,CAAoC;MAClCzM,aAAa,EAAE,KAAKmF,wBADc;MAElC6I,qBAAqB,EAAE,KAAK7G,aAAL,CAAmBC,QAAnB,CAA4B6G,QAA5B,EAFW;MAGlCC,eAAe,EAAE,KAAKjO;IAHY,CAApC;;IAMA,KAAKkF,wBAAL,GAAgC,KAAhC;;IAEA,IAAI,KAAK3F,KAAL,CAAWqK,eAAf,EAAgC;MAC9B,KAAKrK,KAAL,CAAWqK,eAAX,CAA2B,KAAKrK,KAAhC;IACD;;IAED,KAAKsF,8BAAL,GAAsC,CAAC,KAAKtF,KAAL,CAAWqF,uBAAlD,CAnBF,CAqBE;IACA;;IACA,KAAKgD,QAAL,CAAc;MACZC,oBAAoB,EAAE/F,SADV;MAEZ6G,oBAAoB,EAAE7G,SAFV;MAGZQ,mBAAmB,EAAER,SAHT;MAIZ2G,aAAa,EAAE3G;IAJH,CAAd;EAMD,CA7BO;EAkDR;;;;;;EAIQoH,sDAAR;IACU;IACR,OAAOgC,cAAc,IAAIA,cAAc,CAACvF,SAAf,KAA6B7D,SAA/C,GACHoJ,cAAc,CAACvF,SADZ,GAEHxJ,kBAAkB,CAACyJ,QAFvB;EAGD,CALO;;EAOAsD,gDAAR,UACExK,YADF,EAEEyB,aAFF,EAEuD;IAErD,MAAM+N,KAAK,CACT,wEACE,0FAFO,CAAX;EAID,CARO;;EAyIAhF,kDAAR,UACEiF,WADF,EAEE;EACAC,cAHF,EAIEnN,KAJF,EAKEX,aALF,EAMEC,QANF,EAMmB;IANnB;;;;IAQE,IAAMxB,YAAY,GAAGoP,WAAW,CAACpP,YAAjC;;IACA,IAAI,CAACA,YAAL,EAAmB;MACjB;IACD;;IAED,IAAI0E,UAAJ;IACA,IAAI4K,UAAJ;;IACA,IAAItP,YAAY,CAAC6E,KAAjB,EAAwB;MACtB,IAAI0K,wBAAwB,GAAoCxM,SAAhE;MACA,IAAIyM,eAAe,GAAG,EAAtB;;MACA,IAAI,OAAOxP,YAAY,CAAC6E,KAApB,KAA8B,QAAlC,EAA4C;QAC1C;QACA;QACA,IAAMgF,EAAE,GAAG,KAAKK,GAAL,GAAWlK,YAAY,CAAC6E,KAAb,CAAmB4K,OAAnB,CAA2B,KAA3B,EAAkC,EAAlC,CAAtB;QACAF,wBAAwB,GAAG;UACzB/L,GAAG,EAAE,aAAWxD,YAAY,CAAC6E,KAAxB,GAA6B,QADT;UAEzBxC,QAAQ,EAAEpF,sBAAsB,CAACsF,MAFR;UAGzB+B,IAAI,EAAEtE,YAAY,CAAC6E,KAHM;UAIzBgF,EAAE,EAAEA;QAJqB,CAA3B;QAMA2F,eAAe,GAAG3F,EAAlB;MACD,CAXD,MAWO;QACL0F,wBAAwB,GAAGvP,YAAY,CAAC6E,KAAxC;QACA2K,eAAe,GAAG,KAAKtF,GAAL,IAAQ,MAAGlK,YAAY,CAAC6E,KAAb,CAAmBP,IAAtB,MAA0B,IAA1B,IAA0BD,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEoL,OAAF,CAAU,KAAV,EAAiB,EAAjB,CAAlC,CAAlB;MACD;;MAED,IAAIF,wBAAJ,EAA8B;QAC5BD,UAAU,GAAG;UACX7N,IAAI,EAAE,OADK;UAEX,mBAAmB+N;QAFR,CAAb;QAIA9K,UAAU,GAAG,KAAKC,qBAAL,CACX4K,wBADW,EAEXF,cAFW,EAGXnN,KAHW,EAIXX,aAJW,EAKXC,QALW,CAAb;MAOD;IACF;;IAED,IAAIxB,YAAY,CAACJ,KAAb,IAAsBI,YAAY,CAACJ,KAAb,CAAmB+I,MAAnB,GAA4B,CAAtD,EAAyD;MACvD,OACE3L;QAAIyE,IAAI,EAAC,cAAT;QAAwB+B,GAAG,EAAExD,YAAY,CAACwD,GAAb,IAAoB4L,WAAW,CAAC5L,GAAhC,IAAuC,aAAWtB;MAA/E,GACElF,wCAASsS,UAAT,GACEtS;QAAI0E,SAAS,EAAE,KAAKC,WAAL,CAAiBC;MAAhC,GACG5B,YAAY,CAAC0P,UAAb,IAA2B,KAAKjL,gBAAL,CAAsBvC,KAAtB,EAA6BmN,cAA7B,EAA6C,IAA7C,EAAmD,IAAnD,CAD9B,EAEG3K,UAAU,IACT,KAAKE,eAAL,CAAqBF,UAArB,EAAiC0K,WAAW,CAAC5L,GAAZ,IAAmBtB,KAApD,EAA2DmN,cAA3D,EAA2ED,WAAW,CAACvK,KAAvF,CAHJ,EAIG7E,YAAY,CAACJ,KAAb,CAAmBqC,GAAnB,CAAuB,UAAC0N,kBAAD,EAAqBC,UAArB,EAA+B;QACrD,YAAI,CAACxN,eAAL,CACEuN,kBADF,EAEEC,UAFF,EAGEA,UAHF,EAIE5P,YAAY,CAACJ,KAAb,CAAmB+I,MAJrB,EAKEpH,aALF,EAMEC,QANF;MAOC,CARF,CAJH,EAcGxB,YAAY,CAAC6P,aAAb,IAA8B,KAAKpL,gBAAL,CAAsBvC,KAAtB,EAA6BmN,cAA7B,EAA6C,KAA7C,EAAoD,IAApD,CAdjC,CADF,CADF,CADF;IAsBD;EACF,CAzEO;;EA2EAlF,+CAAR,UACE2F,OADF,EAEEtM,GAFF,EAGEuM,UAHF,EAGmC;EACjClL,KAJF,EAIgB;IAEd,OACE7H;MAAIyE,IAAI,EAAC,cAAT;MAAwBoD,KAAK,EAAEA,KAA/B;MAAsCrB,GAAG,EAAEA,GAA3C;MAAgD9B,SAAS,EAAEqO,UAAU,CAACrQ;IAAtE,GACGoQ,OADH,CADF;EAKD,CAXO;;EAaA3F,gDAAR,UACEjI,KADF,EAEE6N,UAFF,EAEmC;EACjCC,GAHF,EAIEC,WAJF,EAIuB;IAErB,IAAIA,WAAW,IAAI/N,KAAK,GAAG,CAA3B,EAA8B;MAC5B,OACElF;QACEyE,IAAI,EAAC,WADP;QAEE+B,GAAG,EAAE,eAAetB,KAAf,IAAwB8N,GAAG,KAAKjN,SAAR,GAAoB,EAApB,GAAyBiN,GAAG,GAAG,MAAH,GAAY,SAAhE,CAFP;QAGEtO,SAAS,EAAEqO,UAAU,CAACG,OAHxB;QAG+B,eACjB;MAJd,EADF;IAQD;;IACD,OAAO,IAAP;EACD,CAjBO;;EAmBA/F,iDAAR,UACEzK,IADF,EAEEqQ,UAFF,EAEmC;EACjC7N,KAHF,EAIEQ,qBAJF,EAKEpB,cALF,EAMEC,aANF,EAOEC,QAPF,EAOmB;IAEjB,IAAI9B,IAAI,CAACyQ,QAAT,EAAmB;MACjB,OAAOzQ,IAAI,CAACyQ,QAAL,CAAa7D;QAChB,iBAAiB5J,qBAAqB,GAAG,CADzB;QAC4B,gBAAgBpB;MAD5C,GAC+D5B,IAD/D,CAAb,EAEL,KAAK0G,OAFA,CAAP;IAID;;IACD,IAAI1G,IAAI,CAAC+D,IAAT,EAAe;MACb,OAAO,KAAK2M,qBAAL,CACL1Q,IADK,EAELqQ,UAFK,EAGL7N,KAHK,EAILQ,qBAJK,EAKLpB,cALK,EAMLC,aANK,EAOLC,QAPK,CAAP;IASD;;IAED,IAAI9B,IAAI,CAAC2Q,KAAL,IAAc1R,UAAU,CAACe,IAAD,CAA5B,EAAoC;MAClC,OAAO,KAAK4Q,kBAAL,CACL5Q,IADK,EAELqQ,UAFK,EAGL7N,KAHK,EAILQ,qBAJK,EAKLpB,cALK,EAMLC,aANK,EAOLC,QAPK,CAAP;IASD;;IAED,OAAO,KAAK+O,iBAAL,CACL7Q,IADK,EAELqQ,UAFK,EAGL7N,KAHK,EAILQ,qBAJK,EAKLpB,cALK,EAMLC,aANK,EAOLC,QAPK,CAAP;EASD,CAhDO;;EAkDA2I,qDAAR,UACEzK,IADF,EAEE;EACAqQ,UAHF,EAIE7N,KAJF,EAKEX,aALF,EAMEC,QANF,EAMmB;IAET;IAAA;IACA;IAAA,IAAWqI,YAAX;IACR,IAAM2G,iBAAiB,GACrB1N,SAAS,IAAIvF,cAAc,CAAuCuF,SAAvC,EAAkDxF,aAAlD,CAD7B;IAEA,OACE;MACAN;QAAK6M,EAAE,EAAEA,EAAT;QAAanI,SAAS,EAAE,KAAKC,WAAL,CAAiB8O;MAAzC,GAAqDD,iBAArD,EAAsE;QAAE3C,KAAK,EAAEnO,IAAI,CAACmO;MAAd,CAAtE,GACE7Q,oBAAC0T,gBAAD,EAAiBpE;QACf5M,IAAI,EAAEA,IADS;QAEfqQ,UAAU,EAAEA,UAFG;QAGf7N,KAAK,EAAEA,KAHQ;QAIfyO,gBAAgB,EAAEpP,aAAa,GAAG,KAAKqP,YAAR,GAAuB7N,SAJvC;QAKfvB,QAAQ,EAAEA;MALK,GAMXsB,SANW,CAAjB,CADF;IAFF;EAaD,CAzBO;;EA2BAqH,qDAAR,UACEzK,IADF,EAEE;EACAqQ,UAHF,EAIE7N,KAJF,EAKEQ,qBALF,EAMEpB,cANF,EAOEC,aAPF,EAQEC,QARF,EAQmB;IAET;IACA;IACR,OACExE,oBAACoC,oBAAD,EAAqB;MACnBM,IAAI,EAAEA,IADa;MAEnBqQ,UAAU,EAAEA,UAFO;MAGnB7N,KAAK,EAAEA,KAHY;MAInBQ,qBAAqB,EAAEA,qBAJJ;MAKnBpB,cAAc,EAAEA,cALG;MAMnBC,aAAa,EAAEA,aANI;MAOnBC,QAAQ,EAAEA,QAPS;MAQnBqP,oBAAoB,EAAEA,oBARH;MASnBC,gBAAgB,EAAE,KAAKC,qBATJ;MAUnBC,gBAAgB,EAAE,KAAKC,iBAVJ;MAWnBC,eAAe,EAAE,KAAKC,oBAXH;MAYnBC,eAAe,EAAE,KAAKC,gBAZH;MAanBC,gBAAgB,EAAE,KAAK1I,iBAbJ;MAcnBS,WAAW,EAAE,KAAKkI,cAdC;MAenBC,aAAa,EAAE,KAAKC,cAfD;MAgBnBC,YAAY,EAAE,KAAKC,aAhBA;MAiBnBpO,mBAAmB,EAAEA,mBAjBF;MAkBnBqO,WAAW,EAAE,KAAK1I,oBAlBC;MAmBnB2I,cAAc,EAAE,KAAKpI,iBAnBF;MAoBnBqI,WAAW,EAAE,KAAK1L;IApBC,CAArB,CADF;EAwBD,CApCO;;EAsCA+D,iDAAR,UACEzK,IADF,EAEE;EACAqQ,UAHF,EAIE7N,KAJF,EAKEQ,qBALF,EAMEpB,cANF,EAOEC,aAPF,EAQEC,QARF,EAQoB;IAEV;IACA;IAER,OACExE,oBAACmC,oBAAD,EAAqB;MACnBO,IAAI,EAAEA,IADa;MAEnBqQ,UAAU,EAAEA,UAFO;MAGnB7N,KAAK,EAAEA,KAHY;MAInBQ,qBAAqB,EAAEA,qBAJJ;MAKnBpB,cAAc,EAAEA,cALG;MAMnBC,aAAa,EAAEA,aANI;MAOnBC,QAAQ,EAAEA,QAPS;MAQnBqP,oBAAoB,EAAEA,oBARH;MASnBC,gBAAgB,EAAE,KAAKC,qBATJ;MAUnBC,gBAAgB,EAAE,KAAKC,iBAVJ;MAWnBC,eAAe,EAAE,KAAKC,oBAXH;MAYnBC,eAAe,EAAE,KAAKC,gBAZH;MAanBC,gBAAgB,EAAE,KAAK1I,iBAbJ;MAcnBS,WAAW,EAAE,KAAKuH,YAdC;MAenBmB,eAAe,EAAE,KAAKtJ,gBAfH;MAgBnB+I,aAAa,EAAE,KAAKC,cAhBD;MAiBnBC,YAAY,EAAE,KAAKC,aAjBA;MAkBnBpO,mBAAmB,EAAEA,mBAlBF;MAmBnBqO,WAAW,EAAE,KAAK1I,oBAnBC;MAoBnB2I,cAAc,EAAE,KAAKpI,iBApBF;MAqBnBqI,WAAW,EAAE,KAAK1L;IArBC,CAArB,CADF;EAyBD,CAtCO;;EAwCA+D,kDAAR,UACEzK,IADF,EAEE;EACAqQ,UAHF,EAIE7N,KAJF,EAKEQ,qBALF,EAMEpB,cANF,EAOEC,aAPF,EAQEC,QARF,EAQoB;IAEV;IACA;IAER,OACExE,oBAACkC,yBAAD,EAA0B;MACxBQ,IAAI,EAAEA,IADkB;MAExBqQ,UAAU,EAAEA,UAFY;MAGxB7N,KAAK,EAAEA,KAHiB;MAIxBQ,qBAAqB,EAAEA,qBAJC;MAKxBpB,cAAc,EAAEA,cALQ;MAMxBC,aAAa,EAAEA,aANS;MAOxBC,QAAQ,EAAEA,QAPc;MAQxBqP,oBAAoB,EAAEA,oBARE;MASxBC,gBAAgB,EAAE,KAAKC,qBATC;MAUxBC,gBAAgB,EAAE,KAAKC,iBAVC;MAWxBC,eAAe,EAAE,KAAKC,oBAXE;MAYxBC,eAAe,EAAE,KAAKC,gBAZE;MAaxBC,gBAAgB,EAAE,KAAK1I,iBAbC;MAcxBS,WAAW,EAAE,KAAKuH,YAdM;MAexBmB,eAAe,EAAE,KAAKtJ,gBAfE;MAgBxB+I,aAAa,EAAE,KAAKC,cAhBI;MAiBxBG,WAAW,EAAE,KAAK1I,oBAjBM;MAkBxB2I,cAAc,EAAE,KAAKpI,iBAlBG;MAmBxBqI,WAAW,EAAE,KAAK1L,OAnBM;MAoBxB7C,mBAAmB,EAAEA,mBApBG;MAqBxByO,KAAK,EAAE,KAAKC;IArBY,CAA1B,CADF;EAyBD,CAtCO;EAqFR;;;;;EAGQ9H,4CAAR,UAAqBxJ,EAArB,EAAyD;IACvD,OAAOA,EAAE,CAAC0E,KAAH,KAAahH,QAAQ,CAAC6T,GAAtB,IAA6BvR,EAAE,CAAC6C,GAAH,KAAW,MAA/C;EACD,CAFO;;EAyHA2G,uDAAR;IACE,OAAO,CAAC,KAAK3C,aAAN,IAAuB,CAAC,KAAKS,aAApC;EACD,CAFO;EAkCR;;;;;;;EAKQkC,wDAAR,UAAiCzK,IAAjC,EAA4DiB,EAA5D,EAA+FoG,MAA/F,EAAmH;IAAnH;;IACE,IAAMgB,aAAa,GAAGhB,MAAM,GAAGA,MAAH,GAAapG,EAAE,CAACqH,aAA5C;IACQ;IAAA;;IAER,IAAItI,IAAI,CAAC8D,GAAL,KAAa,KAAKF,KAAL,CAAWC,mBAA5B,EAAiD;MAC/C;IACD;;IAED,IAAI,KAAK2E,aAAL,KAAuBnF,SAA3B,EAAsC;MACpC,KAAK2E,MAAL,CAAYC,YAAZ,CAAyB,KAAKO,aAA9B;;MACA,KAAKA,aAAL,GAAqBnF,SAArB;IACD,CAXgH,CAajH;;;IACA,IAAI,KAAKO,KAAL,CAAWC,mBAAX,KAAmCR,SAAvC,EAAkD;MAChDgF,aAAa,CAAC7G,KAAd;IACD,CAhBgH,CAkBjH;IACA;;;IACA,IAAIvC,UAAU,CAACe,IAAD,CAAd,EAAsB;MACpBiB,EAAE,CAAC2F,eAAH;MACA,KAAK4B,aAAL,GAAqB,KAAKR,MAAL,CAAYE,UAAZ,CAAuB;QAC1CG,aAAa,CAAC7G,KAAd;;QACAR,KAAI,CAACmI,QAAL,CAAc;UACZC,oBAAoB,EAAE;QADV,CAAd;;QAGApI,KAAI,CAACwI,oBAAL,CAA0BxJ,IAA1B,EAAgCqI,aAAhC;;QACArH,KAAI,CAACwH,aAAL,GAAqBnF,SAArB;MACD,CAPoB,EAOlBoP,eAPkB,CAArB;IAQD,CAVD,MAUO;MACL,KAAKjK,aAAL,GAAqB,KAAKR,MAAL,CAAYE,UAAZ,CAAuB;QAC1ClH,KAAI,CAAC+I,iBAAL,CAAuB9I,EAAvB;;QACAoH,aAAa,CAAC7G,KAAd;QACAR,KAAI,CAACwH,aAAL,GAAqBnF,SAArB;MACD,CAJoB,EAIlBoP,eAJkB,CAArB;IAKD;EACF,CArCO;;EA6JAhI,gDAAR;IACQ;IAAA,IAAET,gCAAF;IAAA,IAAiBnG,4CAAjB;;IACN,IAAM7D,IAAI,GAAG,KAAK0S,cAAL,CAAoB7O,mBAApB,CAAb;;IACA,IAAIiJ,YAAY,GAAgC,IAAhD;;IAEA,IAAI9M,IAAJ,EAAU;MACR8M,YAAY,GAAG;QACb5M,KAAK,EAAEH,eAAe,CAACC,IAAD,CADT;QAEbqH,MAAM,EAAE2C,aAFK;QAGb7I,SAAS,EAAE,KAAK4I,iBAHH;QAIb/C,SAAS,EAAE,IAJE;QAKbmD,EAAE,EAAE,KAAKvG,KAAL,CAAWwG,SALF;QAMb8B,kBAAkB,EAAE,IANP;QAObC,sBAAsB,EAAE,KAAKvI,KAAL,CAAWwF,oBAPtB;QAQbmC,eAAe,EAAE9M,MAAM,CAAC,KAAKqC,KAAL,CAAW6C,KAAZ,CAAN,GAA2BnG,eAAe,CAACmV,WAA3C,GAAyDnV,eAAe,CAACoV,YAR7E;QASb5Q,SAAS,EAAE,KAAKlB,KAAL,CAAWkB,SATT;QAUb0J,QAAQ,EAAE,CAVG;QAWbsB,aAAa,EAAE;MAXF,CAAf;;MAcA,IAAIhN,IAAI,CAACC,YAAT,EAAuB;QACrB/B,MAAM,CAAC4O,YAAD,EAAe9M,IAAI,CAACC,YAApB,CAAN;MACD;IACF;;IACD,OAAO6M,YAAP;EACD,CAzBO;;EA2BArC,8CAAR,UAAuB3G,GAAvB,EAAkC;IACxB;IACR,OAAO,KAAK+O,uBAAL,CAA6B/O,GAA7B,EAAkC5D,KAAlC,CAAP;EACD,CAHO;EAKR;;;;;;;EAKQuK,uDAAR,UAAgC3G,GAAhC,EAA6C5D,KAA7C,EAAyE;IACvE,KAAmB,2BAAnB,EAAmByM,mBAAnB,EAAmBA,IAAnB,EAA0B;MAArB,IAAM3M,IAAI,cAAV;;MACH,IAAIA,IAAI,CAAC2C,QAAL,KAAkBpF,sBAAsB,CAAC6H,OAAzC,IAAoDpF,IAAI,CAACM,YAA7D,EAA2E;QACzE,IAAMwS,KAAK,GAAG,KAAKD,uBAAL,CAA6B/O,GAA7B,EAAkC9D,IAAI,CAACM,YAAL,CAAkBJ,KAApD,CAAd;;QACA,IAAI4S,KAAJ,EAAW;UACT,OAAOA,KAAP;QACD;MACF,CALD,MAKO,IAAI9S,IAAI,CAAC8D,GAAL,IAAY9D,IAAI,CAAC8D,GAAL,KAAaA,GAA7B,EAAkC;QACvC,OAAO9D,IAAP;MACD;IACF;EACF,CAXO;;EA+BAyK,0DAAR,UAAmCpD,MAAnC,EAAiD;IAC/C,IAAM0L,cAAc,GAAG,KAAKzL,KAA5B;;IAEA,IAAID,MAAJ,EAAY;MACV,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;QAC9B,IAAM2L,UAAU,GAAa3U,WAAW,CAAC0U,cAAD,CAAxC;QACA,KAAK1F,OAAL,GAAe2F,UAAU,GAAIA,UAAU,CAACC,aAAX,CAAyB5L,MAAzB,CAAJ,GAAmD,IAA5E;QACA,KAAKoB,aAAL,GAAqB/J,SAAS,CAACqU,cAAD,CAA9B,CAH8B,CAI9B;MACD,CALD,MAKO,IAAK1L,MAAc,CAACT,eAApB,EAAqC;QAC1C,KAAK6B,aAAL,GAAqB/J,SAAS,CAAE2I,MAAqB,CAACA,MAAxB,CAA9B;QACA,KAAKgG,OAAL,GAAehG,MAAf;MACD,CAHM,MAGA,KACL;MACA,CAAEA,MAAgB,CAACN,IAAjB,KAA0B1D,SAA1B,IAAwCgE,MAAgB,CAAC6L,CAAjB,KAAuB7P,SAAjE,OACA;MACEgE,MAAgB,CAACiJ,GAAjB,KAAyBjN,SAAzB,IAAuCgE,MAAgB,CAAC8L,CAAjB,KAAuB9P,SAFhE,CAFK,EAKL;QACA,KAAKoF,aAAL,GAAqB/J,SAAS,CAACqU,cAAD,CAA9B;QACA,KAAK1F,OAAL,GAAehG,MAAf;MACD,CARM,MAQA,IAAKA,MAAmC,CAAC+L,OAApC,KAAgD/P,SAArD,EAAgE;QACrE,KAAKgK,OAAL,GAAgBhG,MAAmC,CAAC+L,OAApD;QACA,KAAK3K,aAAL,GAAqB/J,SAAS,CAAC,KAAK2O,OAAN,CAA9B;MACD,CAHM,MAGA;QACL,IAAMhF,aAAa,GAAYhB,MAA/B;QACA,KAAKoB,aAAL,GAAqB/J,SAAS,CAAC2J,aAAD,CAA9B;QACA,KAAKgF,OAAL,GAAehG,MAAf;MACD;IACF,CAzBD,MAyBO;MACL,KAAKoB,aAAL,GAAqB/J,SAAS,CAACqU,cAAD,CAA9B;IACD;EACF,CA/BO,CA5tCV,CACE;;;EACctI,kCAAqC;IACjDvK,KAAK,EAAE,EAD0C;IAEjDgM,kBAAkB,EAAE,IAF6B;IAGjDR,QAAQ,EAAE,CAHuC;IAIjDH,eAAe,EAAE/N,eAAe,CAAC6V,cAJgB;IAKjD/H,SAAS,EAAE;EALsC,CAArC;EAFHb,kBAAkB,eAD9BrL,kBAC8B,GAAlBqL,kBAAkB,CAAlB;EA0wCb;AAAC,CA1wCD,CAAwCnN,KAAK,CAACgW,SAA9C;;SAAa7I","names":["React","ContextualMenuItemType","DirectionalHint","FocusZone","FocusZoneDirection","FocusZoneTabbableElements","divProperties","getNativeProps","shallowCompare","warnDeprecations","Async","EventGroup","assign","classNamesFunction","css","getDocument","getFirstFocusable","getId","getLastFocusable","getRTL","getWindow","KeyCodes","shouldWrapFocus","isIOS","isMac","initializeComponentRef","memoizeFunction","hasSubmenu","getIsChecked","isItemDisabled","withResponsiveMode","ResponsiveMode","Callout","ContextualMenuItem","ContextualMenuSplitButton","ContextualMenuButton","ContextualMenuAnchor","concatStyleSetsWithProps","getItemStyles","getClassNames","getContextualMenuItemClassNames","getSubmenuItems","item","subMenuProps","items","canAnyMenuItemsCheck","some","canCheck","sectionProps","NavigationIdleDelay","COMPONENT_NAME","_getMenuItemStylesFunction","styles","styleProps","__spreadArrays","__extends","props","_super","_this","ev","dismissAll","onDismiss","options","onRestoreFocus","containsFocus","_previousActiveElement","focus","menuListProps","defaultRender","indexCorrection","totalItemCount","hasCheckmarks","hasIcons","role","className","_classNames","list","onKeyDown","_onKeyDown","onKeyUp","_onKeyUp","map","index","menuItem","_renderMenuItem","itemType","Divider","Header","indexIncrease","customOnRenderListLength","focusableElementIndex","renderedItems","iconProps","iconName","itemProps","undefined","dividerClassName","subMenuIconClassName","submenuIconProps","itemClassNames","getItemClassNames","theme","state","expandedMenuItemKey","key","href","primaryDisabled","itemStyleProps","disabled","expanded","checked","isAnchorLink","knownIcon","itemClassName","iconClassName","subMenuClassName","subComponentStyles","_a","text","name","push","_renderSeparator","headerItem","_renderHeaderMenuItem","_renderListItem","title","Section","_renderSectionItem","_renderNormalItem","Fragment","_lastKeyDownWasAltOrMeta","_isAltOrMeta","dismissAllMenus","which","escape","_keyHandler","_shouldHandleKeyDown","_shouldCloseSubMenu","up","altKey","metaKey","delayUpdateFocusOnHover","_shouldUpdateFocusOnMouseEvent","_shouldHandleKeyUp","keyPressIsAltOrMetaAlone","shouldHandleKey","handled","_focusingPreviousElement","dismiss","preventDefault","stopPropagation","submenuCloseKey","right","left","isSubMenu","_adjustedFocusZoneProps","direction","vertical","checkForNoWrap","target","_host","hasModifier","isUp","isDown","down","elementToFocus","lastChild","firstChild","_isScrollIdle","_scrollIdleTimeoutId","_async","clearTimeout","setTimeout","_shouldIgnoreMouseEvent","_updateFocusOnMouseEvent","targetElement","currentTarget","_gotMouseMove","_enterTimerId","_targetWindow","document","activeElement","setActive","e","onMouseDown","_onItemClickBase","_cancelSubMenuTimer","length","_executeItemClick","setState","expandedByMouseClick","nativeEvent","detail","pointerType","_onItemSubMenuExpand","isDisabled","onClick","onItemClick","defaultPrevented","openKey","enter","_onSubMenuDismiss","submenuTarget","_mounted","dismissedMenuItemKey","id","subMenuId","_events","getMenuClassNames","contextualMenuItems","_id","ContextualMenuBase","newProps","newState","shouldUpdateWhenHidden","hidden","newTarget","_setTargetWindowAndElement","_isHidden","_onMenuClosed","_onMenuOpened","onMenuDismissed","dispose","labelElementId","beakWidth","directionalHint","directionalHintForRTL","alignTargetEdge","gapSpace","coverTarget","ariaLabel","doNotLayer","bounds","useTargetWidth","useTargetAsMinWidth","directionalHintFixed","shouldFocusOnMount","shouldFocusOnContainer","calloutProps","_b","onRenderSubMenu","_c","onRenderMenuList","focusZoneProps","itemsHaveIcons","_i","__assign","_getFocusZoneDirection","submenuProps","_getSubmenuProps","isBeakVisible","responsiveMode","medium","contextMenuStyle","targetAsHtmlElement","_target","offsetWidth","targetBoundingRect","getBoundingClientRect","targetWidth","width","minWidth","itemCount","calloutStyles","callout","_tryFocusPreviousActiveElement","setInitialFocus","onScroll","_onScroll","style","ref","host","container","tabIndex","_onMenuKeyDown","onFocusCapture","_onMenuFocusCapture","root","isCircularNavigation","handleTabKey","all","defaultMenuItemRenderer","_defaultMenuItemRenderer","_onRenderMenuList","_onRenderSubMenu","on","onMenuOpened","off","documentContainsFocus","hasFocus","originalElement","Error","sectionItem","menuClassNames","groupProps","headerContextualMenuItem","ariaLabellledby","replace","topDivider","contextualMenuItem","itemsIndex","bottomDivider","content","classNames","top","fromSection","divider","onRender","_renderAnchorMenuItem","split","_renderSplitButton","_renderButtonItem","divHtmlProperties","header","ChildrenRenderer","onCheckmarkClick","_onItemClick","contextualMenuItemAs","onItemMouseEnter","_onItemMouseEnterBase","onItemMouseLeave","_onMouseItemLeave","onItemMouseMove","_onItemMouseMoveBase","onItemMouseDown","_onItemMouseDown","executeItemClick","_onAnchorClick","onItemKeyDown","_onItemKeyDown","getSubMenuId","_getSubMenuId","openSubMenu","dismissSubMenu","dismissMenu","onItemClickBase","onTap","_onPointerAndTouchEvent","alt","timeoutDuration","_findItemByKey","leftTopEdge","rightTopEdge","_findItemByKeyFromItems","match","currentElement","currentDoc","querySelector","x","y","current","bottomAutoEdge","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\ContextualMenu\\ContextualMenu.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  ContextualMenuItemType,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, IFocusZoneProps, FocusZoneTabbableElements } from '../../FocusZone';\nimport { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  warnDeprecations,\n  Async,\n  EventGroup,\n  assign,\n  classNamesFunction,\n  css,\n  getDocument,\n  getFirstFocusable,\n  getId,\n  getLastFocusable,\n  getRTL,\n  getWindow,\n  IRenderFunction,\n  Point,\n  KeyCodes,\n  shouldWrapFocus,\n  IStyleFunctionOrObject,\n  isIOS,\n  isMac,\n  initializeComponentRef,\n  memoizeFunction,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout, ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { IProcessedStyleSet, concatStyleSetsWithProps } from '../../Styling';\nimport { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { Target } from '@uifabric/react-hooks';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\nexport interface IContextualMenuState {\n  expandedMenuItemKey?: string;\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  expandedByMouseClick?: boolean;\n  dismissedMenuItemKey?: string;\n  contextualMenuItems?: IContextualMenuItem[];\n  contextualMenuTarget?: Element;\n  submenuTarget?: Element;\n  positions?: any;\n  slideDirectionalClassName?: string;\n  subMenuId?: string;\n  submenuDirection?: DirectionalHint;\n}\n\nexport function getSubmenuItems(item: IContextualMenuItem): IContextualMenuItem[] | undefined {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250 /* ms */;\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n@withResponsiveMode\nexport class ContextualMenuBase extends React.Component<IContextualMenuProps, IContextualMenuState> {\n  // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n  public static defaultProps: IContextualMenuProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _id: string;\n  private _host: HTMLElement;\n  private _previousActiveElement: HTMLElement | undefined;\n  private _enterTimerId: number | undefined;\n  private _targetWindow: Window;\n  private _target: Element | MouseEvent | Point | null;\n  private _isScrollIdle: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n  private _shouldUpdateFocusOnMouseEvent: boolean;\n  private _gotMouseMove: boolean;\n  private _mounted = false;\n  private _focusingPreviousElement: boolean;\n\n  private _adjustedFocusZoneProps: IFocusZoneProps;\n\n  // eslint-disable-next-line deprecation/deprecation\n  private _classNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames;\n\n  constructor(props: IContextualMenuProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles',\n    });\n\n    this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu'),\n    };\n\n    this._id = props.id || getId('ContextualMenu');\n    this._focusingPreviousElement = false;\n    this._isScrollIdle = true;\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n  }\n\n  public dismiss = (ev?: any, dismissAll?: boolean) => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev, dismissAll);\n    }\n  };\n\n  public shouldComponentUpdate(newProps: IContextualMenuProps, newState: IContextualMenuState): boolean {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: IContextualMenuProps): void {\n    if (newProps.target !== this.props.target) {\n      const newTarget = newProps.target;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n        this._previousActiveElement = this._targetWindow\n          ? (this._targetWindow.document.activeElement as HTMLElement)\n          : undefined;\n      }\n    }\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;\n\n      // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }\n\n  // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  public UNSAFE_componentWillMount() {\n    const target = this.props.target;\n    this._setTargetWindowAndElement(target!);\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow\n        ? (this._targetWindow.document.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }\n\n  // Invoked immediately before a component is unmounted from the DOM.\n  public componentWillUnmount() {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n    this._async.dispose();\n    this._mounted = false;\n  }\n\n  public render(): JSX.Element | null {\n    let { isBeakVisible } = this.props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = this._onRenderSubMenu,\n      onRenderMenuList = this._onRenderMenuList,\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = this.props;\n\n    this._classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = { ...focusZoneProps, direction: this._getFocusZoneDirection() };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle;\n    const targetAsHtmlElement = this._target as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2 /* Accounts for 1px border */;\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles = this._classNames.subComponentStyles\n        ? (this._classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <Callout\n          styles={calloutStyles}\n          onRestoreFocus={this._tryFocusPreviousActiveElement}\n          {...calloutProps}\n          target={target}\n          isBeakVisible={isBeakVisible}\n          beakWidth={beakWidth}\n          directionalHint={directionalHint}\n          directionalHintForRTL={directionalHintForRTL}\n          gapSpace={gapSpace}\n          coverTarget={coverTarget}\n          doNotLayer={doNotLayer}\n          className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n          setInitialFocus={shouldFocusOnMount}\n          onDismiss={this.props.onDismiss}\n          onScroll={this._onScroll}\n          bounds={bounds}\n          directionalHintFixed={directionalHintFixed}\n          alignTargetEdge={alignTargetEdge}\n          hidden={this.props.hidden}\n        >\n          <div\n            aria-label={ariaLabel}\n            aria-labelledby={labelElementId}\n            style={contextMenuStyle}\n            ref={(host: HTMLDivElement) => (this._host = host)}\n            id={id}\n            className={this._classNames.container}\n            tabIndex={shouldFocusOnContainer ? 0 : -1}\n            onKeyDown={this._onMenuKeyDown}\n            onKeyUp={this._onKeyUp}\n            onFocusCapture={this._onMenuFocusCapture}\n          >\n            {title && <div className={this._classNames.title}> {title} </div>}\n            {items && items.length ? (\n              <FocusZone\n                className={this._classNames.root}\n                isCircularNavigation={true}\n                handleTabKey={FocusZoneTabbableElements.all}\n                {...this._adjustedFocusZoneProps}\n              >\n                {onRenderMenuList(\n                  {\n                    items,\n                    totalItemCount,\n                    hasCheckmarks,\n                    hasIcons,\n                    defaultMenuItemRenderer: this._defaultMenuItemRenderer,\n                  },\n                  this._onRenderMenuList,\n                )}\n              </FocusZone>\n            ) : null}\n            {submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)}\n          </div>\n        </Callout>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n  private _isHidden(props: IContextualMenuProps) {\n    return !!props.hidden;\n  }\n\n  private _onMenuOpened() {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  }\n\n  private _onMenuClosed() {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n\n    // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement,\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n\n    // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined,\n    });\n  }\n\n  private _tryFocusPreviousActiveElement = (options: {\n    containsFocus: boolean;\n    documentContainsFocus: boolean;\n    originalElement: HTMLElement | Window | undefined;\n  }) => {\n    if (this.props.onRestoreFocus) {\n      this.props.onRestoreFocus(options);\n    } else {\n      if (options && options.containsFocus && this._previousActiveElement) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n        if (this._previousActiveElement.focus) {\n          this._previousActiveElement.focus();\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n  private _getFocusZoneDirection() {\n    const { focusZoneProps } = this.props;\n    return focusZoneProps && focusZoneProps.direction !== undefined\n      ? focusZoneProps.direction\n      : FocusZoneDirection.vertical;\n  }\n\n  private _onRenderSubMenu(\n    subMenuProps: IContextualMenuProps,\n    defaultRender?: IRenderFunction<IContextualMenuProps>,\n  ): JSX.Element {\n    throw Error(\n      'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n        'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n    );\n  }\n\n  private _onRenderMenuList = (\n    menuListProps: IContextualMenuListProps,\n    defaultRender?: IRenderFunction<IContextualMenuListProps>,\n  ): JSX.Element => {\n    let indexCorrection = 0;\n    const { items, totalItemCount, hasCheckmarks, hasIcons, role } = menuListProps;\n    return (\n      <ul className={this._classNames.list} onKeyDown={this._onKeyDown} onKeyUp={this._onKeyUp} role={role ?? 'menu'}>\n        {items.map((item, index) => {\n          const menuItem = this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n          if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n            const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n            indexCorrection += indexIncrease;\n          }\n          return menuItem;\n        })}\n      </ul>\n    );\n  };\n\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n  private _renderMenuItem = (\n    item: IContextualMenuItem,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): JSX.Element => {\n    const renderedItems: React.ReactNode[] = [];\n    const iconProps = item.iconProps || { iconName: 'None' };\n    const {\n      getItemClassNames, // eslint-disable-line deprecation/deprecation\n      itemProps,\n    } = item;\n    const styles = itemProps ? itemProps.styles : undefined;\n\n    // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n    const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n    // eslint-disable-next-line deprecation/deprecation\n    let itemClassNames: IMenuItemClassNames;\n\n    // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(\n        this.props.theme!,\n        isItemDisabled(item),\n        this.state.expandedMenuItemKey === item.key,\n        !!getIsChecked(item),\n        !!item.href,\n        iconProps.iconName !== 'None',\n        item.className,\n        dividerClassName,\n        iconProps.className,\n        subMenuIconClassName,\n        item.primaryDisabled,\n      );\n    } else {\n      const itemStyleProps: IContextualMenuItemStyleProps = {\n        theme: this.props.theme!,\n        disabled: isItemDisabled(item),\n        expanded: this.state.expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled,\n      };\n\n      // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n      itemClassNames = getContextualMenuItemClassNames(\n        _getMenuItemStylesFunction(this._classNames.subComponentStyles?.menuItem, styles),\n        itemStyleProps,\n      );\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        break;\n      case ContextualMenuItemType.Header:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        const headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n      case ContextualMenuItemType.Section:\n        renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n        break;\n      default:\n        const menuItem = this._renderNormalItem(\n          item,\n          itemClassNames,\n          index,\n          focusableElementIndex,\n          totalItemCount,\n          hasCheckmarks,\n          hasIcons,\n        );\n        renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n\n    // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n    return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n  };\n\n  private _defaultMenuItemRenderer = (item: IContextualMenuItemRenderProps): React.ReactNode => {\n    const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n    return this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  private _renderSectionItem(\n    sectionItem: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    menuClassNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ) {\n    const sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n\n    let headerItem;\n    let groupProps;\n    if (sectionProps.title) {\n      let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n      let ariaLabellledby = '';\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        const id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: `section-${sectionProps.title}-title`,\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id,\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + sectionProps.title.text?.replace(/\\s/g, '');\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby,\n        };\n        headerItem = this._renderHeaderMenuItem(\n          headerContextualMenuItem,\n          menuClassNames,\n          index,\n          hasCheckmarks,\n          hasIcons,\n        );\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return (\n        <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n          <div {...groupProps}>\n            <ul className={this._classNames.list}>\n              {sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true)}\n              {headerItem &&\n                this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title)}\n              {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                this._renderMenuItem(\n                  contextualMenuItem,\n                  itemsIndex,\n                  itemsIndex,\n                  sectionProps.items.length,\n                  hasCheckmarks,\n                  hasIcons,\n                ),\n              )}\n              {sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)}\n            </ul>\n          </div>\n        </li>\n      );\n    }\n  }\n\n  private _renderListItem(\n    content: React.ReactNode,\n    key: string | number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    title?: string,\n  ) {\n    return (\n      <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n        {content}\n      </li>\n    );\n  }\n\n  private _renderSeparator(\n    index: number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    top?: boolean,\n    fromSection?: boolean,\n  ): React.ReactNode {\n    if (fromSection || index > 0) {\n      return (\n        <li\n          role=\"separator\"\n          key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n          className={classNames.divider}\n          aria-hidden=\"true\"\n        />\n      );\n    }\n    return null;\n  }\n\n  private _renderNormalItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    if (item.onRender) {\n      return item.onRender(\n        { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n        this.dismiss,\n      );\n    }\n    if (item.href) {\n      return this._renderAnchorMenuItem(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    return this._renderButtonItem(\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n    );\n  }\n\n  private _renderHeaderMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = this.props;\n    const { itemProps, id } = item;\n    const divHtmlProperties =\n      itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      <div id={id} className={this._classNames.header} {...divHtmlProperties} style={item.style}>\n        <ChildrenRenderer\n          item={item}\n          classNames={classNames}\n          index={index}\n          onCheckmarkClick={hasCheckmarks ? this._onItemClick : undefined}\n          hasIcons={hasIcons}\n          {...itemProps}\n        />\n      </div>\n    );\n  }\n\n  private _renderAnchorMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n    return (\n      <ContextualMenuAnchor\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onAnchorClick}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderButtonItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ) {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderSplitButton(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ): JSX.Element {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuSplitButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n        expandedMenuItemKey={expandedMenuItemKey}\n        onTap={this._onPointerAndTouchEvent}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _shouldHandleKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return this._keyHandler(ev, this._shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  private _shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      ev.which === KeyCodes.escape ||\n      this._shouldCloseSubMenu(ev) ||\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  private _onMenuFocusCapture = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this.props.delayUpdateFocusOnHover) {\n      this._shouldUpdateFocusOnMouseEvent = true;\n    }\n  };\n\n  private _onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return this._keyHandler(ev, this._shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  private _shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  private _keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      this._focusingPreviousElement = true;\n      this.dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  private _shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n    if (ev.which !== submenuCloseKey || !this.props.isSubMenu) {\n      return false;\n    }\n\n    return (\n      this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical ||\n      (!!this._adjustedFocusZoneProps.checkForNoWrap &&\n        !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = this._onKeyDown(ev);\n\n    if (handled || !this._host) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(this._host, this._host.lastChild as HTMLElement, true)\n        : getFirstFocusable(this._host, this._host.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = (): void => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, NavigationIdleDelay);\n  };\n\n  private _onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (this._shouldUpdateFocusOnMouseEvent) {\n      this._gotMouseMove = true;\n    } else {\n      return;\n    }\n\n    if (\n      !this._isScrollIdle ||\n      this._enterTimerId !== undefined ||\n      targetElement === (this._targetWindow.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  private _onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    if (this.state.expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((this._host as any).setActive) {\n      try {\n        (this._host as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      this._host.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  private _updateFocusOnMouseEvent(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement) {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n    const { subMenuHoverDelay: timeoutDuration = NavigationIdleDelay } = this.props;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    // If the menu is not expanded we can update focus without any delay\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(() => {\n        targetElement.focus();\n        this.setState({\n          expandedByMouseClick: true,\n        });\n        this._onItemSubMenuExpand(item, targetElement);\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(() => {\n        this._onSubMenuDismiss(ev);\n        targetElement.focus();\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  }\n\n  private _onItemMouseDown = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void => {\n    if (item.onMouseDown) {\n      item.onMouseDown(item, ev);\n    }\n  };\n\n  private _onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    this._onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  private _onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item);\n\n    // Cancel a async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    this._cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      this._executeItemClick(item, ev);\n    } else {\n      if (item.key !== this.state.expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        this.setState({\n          // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n          // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n          // between a real click event and a keypress event (detail should be the number of mouse clicks).\n          // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n          // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n          // and \"\" for pressing \"Enter\" with Narrator on.\n          expandedByMouseClick: ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse',\n        });\n        this._onItemSubMenuExpand(item, target);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  private _onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    this._executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  private _executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    let dismiss = false;\n    if (item.onClick) {\n      dismiss = !!item.onClick(ev, item);\n    } else if (this.props.onItemClick) {\n      dismiss = !!this.props.onItemClick(ev, item);\n    }\n\n    if (dismiss || !ev.defaultPrevented) {\n      this.dismiss(ev, true);\n\n      // This should be removed whenever possible.\n      // This ensures that the hidden dismissal action maintains the same behavior.\n      // If the menu is being dismissed then the previously focused element should\n      // get focused since the dismiss was triggered by a user click on an item\n      // Rather than focus being lost.\n      this._focusingPreviousElement = true;\n    }\n  };\n\n  private _onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      this.setState({\n        expandedByMouseClick: false,\n      });\n      this._onItemSubMenuExpand(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  // Cancel a async menu item hover timeout action from being taken and instead\n  // do new upcoming behavior\n  private _cancelSubMenuTimer = () => {\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n  };\n\n  private _onItemSubMenuExpand = (item: IContextualMenuItem, target: HTMLElement): void => {\n    if (this.state.expandedMenuItemKey !== item.key) {\n      if (this.state.expandedMenuItemKey) {\n        this._onSubMenuDismiss();\n      }\n\n      // Focus the target to ensure when we close it, we're focusing on the correct element.\n      target.focus();\n      this.setState({\n        expandedMenuItemKey: item.key,\n        submenuTarget: target,\n      });\n    }\n  };\n\n  private _getSubmenuProps() {\n    const { submenuTarget, expandedMenuItemKey } = this.state;\n    const item = this._findItemByKey(expandedMenuItemKey!);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item)!,\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n    return submenuProps;\n  }\n\n  private _findItemByKey(key: string): IContextualMenuItem | undefined {\n    const { items } = this.props;\n    return this._findItemByKeyFromItems(key, items);\n  }\n\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n  private _findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n    for (const item of items) {\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        const match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  }\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The _mounted property is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  private _onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      this.dismiss(ev, dismissAll);\n    } else if (this._mounted) {\n      this.setState({\n        dismissedMenuItemKey: this.state.expandedMenuItemKey,\n        expandedMenuItemKey: undefined,\n        submenuTarget: undefined,\n      });\n    }\n  };\n\n  private _setTargetWindowAndElement(target: Target): void {\n    const currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target as MouseEvent;\n      } else if (\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).left !== undefined || (target as Point).x !== undefined) &&\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).top !== undefined || (target as Point).y !== undefined)\n      ) {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target as Point;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n      } else {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target as Element;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  private _getSubMenuId = (item: IContextualMenuItem): string | undefined => {\n    let { subMenuId } = this.state;\n\n    if (item.subMenuProps && item.subMenuProps.id) {\n      subMenuId = item.subMenuProps.id;\n    }\n\n    return subMenuId;\n  };\n\n  private _onPointerAndTouchEvent = (ev: React.TouchEvent<HTMLElement> | PointerEvent) => {\n    this._cancelSubMenuTimer();\n  };\n}\n"]},"metadata":{},"sourceType":"module"}