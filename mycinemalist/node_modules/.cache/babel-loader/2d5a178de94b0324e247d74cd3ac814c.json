{"ast":null,"code":"import { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { Autofill } from '../Autofill/index';\nimport { initializeComponentRef, css, customizable, divProperties, findElementRecursive, findIndex, focusAsync, getId, getNativeProps, isIOS, isMac, KeyCodes, shallowCompare, mergeAriaAttributeValues, warnMutuallyExclusive, Async, EventGroup } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { CommandButton, IconButton } from '../../Button';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../utilities/selectableOption/index';\nvar SearchDirection;\n\n(function (SearchDirection) {\n  SearchDirection[SearchDirection[\"backward\"] = -1] = \"backward\";\n  SearchDirection[SearchDirection[\"none\"] = 0] = \"none\";\n  SearchDirection[SearchDirection[\"forward\"] = 1] = \"forward\";\n})(SearchDirection || (SearchDirection = {}));\n\nvar HoverStatus;\n\n(function (HoverStatus) {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  HoverStatus[HoverStatus[\"clearAll\"] = -2] = \"clearAll\";\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n\n  HoverStatus[HoverStatus[\"default\"] = -1] = \"default\";\n})(HoverStatus || (HoverStatus = {}));\n\nvar ScrollIdleDelay = 250;\n/* ms */\n\nvar TouchIdleDelay = 500;\n/* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\n\nvar ReadOnlyPendingAutoCompleteTimeout = 1000;\n/* ms */\n\n/**\n * Internal class that is used to wrap all ComboBox options.\n * This is used to customize when we want to rerender components,\n * so we don't rerender every option every time render is executed.\n */\n\nvar ComboBoxOptionWrapper =\n/** @class */\nfunction (_super) {\n  __extends(ComboBoxOptionWrapper, _super);\n\n  function ComboBoxOptionWrapper() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ComboBoxOptionWrapper.prototype.render = function () {\n    return this.props.render();\n  };\n\n  ComboBoxOptionWrapper.prototype.shouldComponentUpdate = function (newProps) {\n    // The render function will always be different, so we ignore that prop\n    return !shallowCompare(__assign(__assign({}, this.props), {\n      render: undefined\n    }), __assign(__assign({}, newProps), {\n      render: undefined\n    }));\n  };\n\n  return ComboBoxOptionWrapper;\n}(React.Component);\n\nvar COMPONENT_NAME = 'ComboBox';\n\nvar ComboBox =\n/** @class */\nfunction (_super) {\n  __extends(ComboBox, _super);\n\n  function ComboBox(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    /** The input aspect of the comboBox */\n\n    _this._autofill = React.createRef();\n    /** The wrapping div of the input and button */\n\n    _this._comboBoxWrapper = React.createRef();\n    /** The callout element */\n\n    _this._comboBoxMenu = React.createRef();\n    /** The menu item element that is currently selected */\n\n    _this._selectedElement = React.createRef();\n    /**\n     * {@inheritdoc}\n     */\n\n    _this.focus = function (shouldOpenOnFocus, useFocusAsync) {\n      if (_this._autofill.current) {\n        if (useFocusAsync) {\n          focusAsync(_this._autofill.current);\n        } else {\n          _this._autofill.current.focus();\n        }\n\n        if (shouldOpenOnFocus) {\n          _this.setState({\n            isOpen: true\n          });\n        }\n      } // Programatically setting focus means that there is nothing else that needs to be done\n      // Focus is now contained\n\n\n      if (!_this._hasFocus()) {\n        _this.setState({\n          focusState: 'focused'\n        });\n      }\n    };\n    /**\n     * Close menu callout if it is open\n     */\n\n\n    _this.dismissMenu = function () {\n      var isOpen = _this.state.isOpen;\n      isOpen && _this.setState({\n        isOpen: false\n      });\n    };\n    /**\n     * componentWillReceiveProps handler for the auto fill component\n     * Checks/updates the iput value to set, if needed\n     * @param defaultVisibleValue - the defaultVisibleValue that got passed\n     *  in to the auto fill's componentWillReceiveProps\n     * @returns - the updated value to set, if needed\n     */\n\n\n    _this._onUpdateValueInAutofillWillReceiveProps = function () {\n      var comboBox = _this._autofill.current;\n\n      if (!comboBox) {\n        return null;\n      }\n\n      if (comboBox.value === null || comboBox.value === undefined) {\n        return null;\n      }\n\n      var visibleValue = _this._normalizeToString(_this._currentVisibleValue);\n\n      if (comboBox.value !== visibleValue) {\n        // If visibleValue is empty, ensure that the empty string is used\n        return visibleValue || '';\n      }\n\n      return comboBox.value;\n    };\n\n    _this._renderComboBoxWrapper = function (multiselectAccessibleText, errorMessageId, keytipAttributes) {\n      if (keytipAttributes === void 0) {\n        keytipAttributes = {};\n      }\n\n      var _a = _this.props,\n          label = _a.label,\n          disabled = _a.disabled,\n          ariaLabel = _a.ariaLabel,\n          ariaDescribedBy = _a.ariaDescribedBy,\n          required = _a.required,\n          errorMessage = _a.errorMessage,\n          buttonIconProps = _a.buttonIconProps,\n          _b = _a.isButtonAriaHidden,\n          isButtonAriaHidden = _b === void 0 ? true : _b,\n          title = _a.title,\n          placeholderProp = _a.placeholder,\n          tabIndex = _a.tabIndex,\n          autofill = _a.autofill,\n          iconButtonProps = _a.iconButtonProps;\n      var _c = _this.state,\n          isOpen = _c.isOpen,\n          suggestedDisplayValue = _c.suggestedDisplayValue; // If the combobox has focus, is multiselect, and has a display string, then use that placeholder\n      // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n      // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n      // should be removed and the multiselect combobox should behave like a picker.\n\n      var placeholder = _this._hasFocus() && _this.props.multiSelect && multiselectAccessibleText ? multiselectAccessibleText : placeholderProp;\n      return React.createElement(\"div\", {\n        \"data-ktp-target\": keytipAttributes['data-ktp-target'],\n        ref: _this._comboBoxWrapper,\n        id: _this._id + 'wrapper',\n        className: _this._classNames.root\n      }, React.createElement(Autofill, __assign({\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target'],\n        \"data-is-interactable\": !disabled,\n        componentRef: _this._autofill,\n        id: _this._id + '-input',\n        className: _this._classNames.input,\n        type: \"text\",\n        onFocus: _this._onFocus,\n        onBlur: _this._onBlur,\n        onKeyDown: _this._onInputKeyDown,\n        onKeyUp: _this._onInputKeyUp,\n        onClick: _this._onAutofillClick,\n        onTouchStart: _this._onTouchStart,\n        onInputValueChange: _this._onInputChange,\n        \"aria-expanded\": isOpen,\n        \"aria-autocomplete\": _this._getAriaAutoCompleteValue(),\n        role: \"combobox\",\n        readOnly: disabled,\n        \"aria-labelledby\": label && _this._id + '-label',\n        \"aria-label\": ariaLabel && !label ? ariaLabel : undefined,\n        \"aria-describedby\": errorMessage !== undefined ? mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'], errorMessageId) : mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        \"aria-activedescendant\": _this._getAriaActiveDescendantValue(),\n        \"aria-required\": required,\n        \"aria-disabled\": disabled,\n        \"aria-owns\": isOpen ? _this._id + '-list' : undefined,\n        spellCheck: false,\n        defaultVisibleValue: _this._currentVisibleValue,\n        suggestedDisplayValue: suggestedDisplayValue,\n        updateValueInWillReceiveProps: _this._onUpdateValueInAutofillWillReceiveProps,\n        shouldSelectFullInputValueInComponentDidUpdate: _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate,\n        title: title,\n        preventValueSelection: !_this._hasFocus(),\n        placeholder: placeholder,\n        tabIndex: tabIndex\n      }, autofill)), React.createElement(IconButton, __assign({\n        className: 'ms-ComboBox-CaretDown-button',\n        styles: _this._getCaretButtonStyles(),\n        role: \"presentation\",\n        \"aria-hidden\": isButtonAriaHidden,\n        \"data-is-focusable\": false,\n        tabIndex: -1,\n        onClick: _this._onComboBoxClick,\n        onBlur: _this._onBlur,\n        iconProps: buttonIconProps,\n        disabled: disabled,\n        checked: isOpen\n      }, iconButtonProps)));\n    };\n    /**\n     * componentDidUpdate handler for the auto fill component\n     *\n     * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n     * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n     * @returns - should the full value of the input be selected?\n     * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n     */\n\n\n    _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = function () {\n      return _this._currentVisibleValue === _this.state.suggestedDisplayValue;\n    };\n    /**\n     * Get the correct value to pass to the input\n     * to show to the user based off of the current props and state\n     * @returns the value to pass to the input\n     */\n\n\n    _this._getVisibleValue = function () {\n      var _a = _this.props,\n          text = _a.text,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete;\n      var _b = _this.state,\n          selectedIndices = _b.selectedIndices,\n          currentPendingValueValidIndex = _b.currentPendingValueValidIndex,\n          currentOptions = _b.currentOptions,\n          currentPendingValue = _b.currentPendingValue,\n          suggestedDisplayValue = _b.suggestedDisplayValue,\n          isOpen = _b.isOpen;\n\n      var currentPendingIndexValid = _this._indexWithinBounds(currentOptions, currentPendingValueValidIndex); // If the user passed is a value prop, use that\n      // unless we are open and have a valid current pending index\n\n\n      if (!(isOpen && currentPendingIndexValid) && text && (currentPendingValue === null || currentPendingValue === undefined)) {\n        return text;\n      }\n\n      if (_this.props.multiSelect) {\n        // Multi-select\n        if (_this._hasFocus()) {\n          var index = -1;\n\n          if (autoComplete === 'on' && currentPendingIndexValid) {\n            index = currentPendingValueValidIndex;\n          }\n\n          return _this._getPendingString(currentPendingValue, currentOptions, index);\n        } else {\n          return _this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n        }\n      } else {\n        // Single-select\n        var index = _this._getFirstSelectedIndex();\n\n        if (allowFreeform) {\n          // If we are allowing freeform and autocomplete is also true\n          // and we've got a pending value that matches an option, remember\n          // the matched option's index\n          if (autoComplete === 'on' && currentPendingIndexValid) {\n            index = currentPendingValueValidIndex;\n          } // Since we are allowing freeform, if there is currently a pending value, use that\n          // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n\n\n          return _this._getPendingString(currentPendingValue, currentOptions, index);\n        } else {\n          // If we are not allowing freeform and have a\n          // valid index that matches the pending value,\n          // we know we will need some version of the pending value\n          if (currentPendingIndexValid && autoComplete === 'on') {\n            // If autoComplete is on, return the\n            // raw pending value, otherwise remember\n            // the matched option's index\n            index = currentPendingValueValidIndex;\n            return _this._normalizeToString(currentPendingValue);\n          } else if (!_this.state.isOpen && currentPendingValue) {\n            return _this._indexWithinBounds(currentOptions, index) ? currentPendingValue : _this._normalizeToString(suggestedDisplayValue);\n          } else {\n            return _this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : _this._normalizeToString(suggestedDisplayValue);\n          }\n        }\n      }\n    };\n    /**\n     * Handler for typing changes on the input\n     * @param updatedValue - the newly changed value\n     */\n\n\n    _this._onInputChange = function (updatedValue) {\n      if (_this.props.disabled) {\n        _this._handleInputWhenDisabled(null\n        /* event */\n        );\n\n        return;\n      }\n\n      _this.props.allowFreeform ? _this._processInputChangeWithFreeform(updatedValue) : _this._processInputChangeWithoutFreeform(updatedValue);\n    };\n    /**\n     * Focus (and select) the content of the input\n     * and set the focused state\n     */\n\n\n    _this._onFocus = function () {\n      if (_this._autofill.current && _this._autofill.current.inputElement) {\n        _this._autofill.current.inputElement.select();\n      }\n\n      if (!_this._hasFocus()) {\n        _this.setState({\n          focusState: 'focusing'\n        });\n      }\n    };\n    /**\n     * Callback issued when the options should be resolved, if they have been updated or\n     * if they need to be passed in the first time. This only does work if an onResolveOptions\n     * callback was passed in\n     */\n\n\n    _this._onResolveOptions = function () {\n      if (_this.props.onResolveOptions) {\n        // get the options\n        var newOptions = _this.props.onResolveOptions(__spreadArrays(_this.state.currentOptions)); // Check to see if the returned value is an array, if it is update the state\n        // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n        // If it is then resolve it asynchronously.\n\n\n        if (Array.isArray(newOptions)) {\n          _this.setState({\n            currentOptions: newOptions\n          });\n        } else if (newOptions && newOptions.then) {\n          // Ensure that the promise will only use the callback if it was the most recent one\n          // and update the state when the promise returns\n          var promise_1 = _this._currentPromise = newOptions;\n          promise_1.then(function (newOptionsFromPromise) {\n            if (promise_1 === _this._currentPromise) {\n              _this.setState({\n                currentOptions: newOptionsFromPromise\n              });\n            }\n          });\n        }\n      }\n    };\n    /**\n     * OnBlur handler. Set the focused state to false\n     * and submit any pending value\n     */\n    // eslint-disable-next-line deprecation/deprecation\n\n\n    _this._onBlur = function (event) {\n      // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really bluring from the whole comboBox\n      var relatedTarget = event.relatedTarget;\n\n      if (event.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = document.activeElement;\n      }\n\n      if (relatedTarget && ( // when event coming from withing the comboBox title\n      _this._root.current && _this._root.current.contains(relatedTarget) || // when event coming from within the comboBox list menu\n      _this._comboBoxMenu.current && (_this._comboBoxMenu.current.contains(relatedTarget) || // when event coming from the callout containing the comboBox list menu (ex: when scrollBar of the\n      // Callout is clicked) checks if the relatedTarget is a parent of _comboBoxMenu\n      findElementRecursive(_this._comboBoxMenu.current, function (element) {\n        return element === relatedTarget;\n      })))) {\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n\n      if (_this._hasFocus()) {\n        _this.setState({\n          focusState: 'none'\n        });\n\n        if (!_this.props.multiSelect || _this.props.allowFreeform) {\n          _this._submitPendingValue(event);\n        }\n      }\n    }; // Render Callout container and pass in list\n\n\n    _this._onRenderContainer = function (props) {\n      var onRenderList = props.onRenderList,\n          calloutProps = props.calloutProps,\n          dropdownWidth = props.dropdownWidth,\n          dropdownMaxWidth = props.dropdownMaxWidth,\n          _a = props.onRenderUpperContent,\n          onRenderUpperContent = _a === void 0 ? _this._onRenderUpperContent : _a,\n          _b = props.onRenderLowerContent,\n          onRenderLowerContent = _b === void 0 ? _this._onRenderLowerContent : _b,\n          useComboBoxAsMenuWidth = props.useComboBoxAsMenuWidth,\n          persistMenu = props.persistMenu,\n          _c = props.shouldRestoreFocus,\n          shouldRestoreFocus = _c === void 0 ? true : _c;\n      var isOpen = _this.state.isOpen;\n      var comboBoxMenuWidth = useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? _this._comboBoxWrapper.current.clientWidth + 2 : undefined;\n      return React.createElement(Callout, __assign({\n        isBeakVisible: false,\n        gapSpace: 0,\n        doNotLayer: false,\n        directionalHint: DirectionalHint.bottomLeftEdge,\n        directionalHintFixed: false\n      }, calloutProps, {\n        onLayerMounted: _this._onLayerMounted,\n        className: css(_this._classNames.callout, calloutProps ? calloutProps.className : undefined),\n        target: _this._comboBoxWrapper.current,\n        onDismiss: _this._onDismiss,\n        onMouseDown: _this._onCalloutMouseDown,\n        onScroll: _this._onScroll,\n        setInitialFocus: false,\n        calloutWidth: useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? comboBoxMenuWidth && comboBoxMenuWidth : dropdownWidth,\n        calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth,\n        hidden: persistMenu ? !isOpen : undefined,\n        shouldRestoreFocus: shouldRestoreFocus\n      }), onRenderUpperContent(_this.props, _this._onRenderUpperContent), React.createElement(\"div\", {\n        className: _this._classNames.optionsContainerWrapper,\n        ref: _this._comboBoxMenu\n      }, onRenderList(__assign({}, props), _this._onRenderList)), onRenderLowerContent(_this.props, _this._onRenderLowerContent));\n    };\n\n    _this._onLayerMounted = function () {\n      _this._onCalloutLayerMounted();\n\n      if (_this.props.calloutProps && _this.props.calloutProps.onLayerMounted) {\n        _this.props.calloutProps.onLayerMounted();\n      }\n    };\n\n    _this._onRenderLabel = function (onRenderLabelProps) {\n      var _a = onRenderLabelProps.props,\n          label = _a.label,\n          disabled = _a.disabled,\n          required = _a.required;\n\n      if (label) {\n        return React.createElement(Label, {\n          id: _this._id + '-label',\n          disabled: disabled,\n          required: required,\n          className: _this._classNames.label\n        }, label, onRenderLabelProps.multiselectAccessibleText && React.createElement(\"span\", {\n          className: _this._classNames.screenReaderText\n        }, onRenderLabelProps.multiselectAccessibleText));\n      }\n\n      return null;\n    }; // Render List of items\n\n\n    _this._onRenderList = function (props) {\n      var onRenderItem = props.onRenderItem,\n          options = props.options;\n      var id = _this._id;\n      return React.createElement(\"div\", {\n        id: id + '-list',\n        className: _this._classNames.optionsContainer,\n        \"aria-labelledby\": id + '-label',\n        role: \"listbox\"\n      }, options.map(function (item) {\n        return onRenderItem(item, _this._onRenderItem);\n      }));\n    }; // Render items\n\n\n    _this._onRenderItem = function (item) {\n      switch (item.itemType) {\n        case SelectableOptionMenuItemType.Divider:\n          return _this._renderSeparator(item);\n\n        case SelectableOptionMenuItemType.Header:\n          return _this._renderHeader(item);\n\n        default:\n          return _this._renderOption(item);\n      }\n    }; // Default _onRenderLowerContent function returns nothing\n\n\n    _this._onRenderLowerContent = function () {\n      return null;\n    }; // Default _onRenderUpperContent function returns nothing\n\n\n    _this._onRenderUpperContent = function () {\n      return null;\n    };\n\n    _this._renderOption = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOptionContent : _a;\n      var id = _this._id;\n\n      var isSelected = _this._isOptionSelected(item.index);\n\n      var isChecked = _this._isOptionChecked(item.index);\n\n      var optionStyles = _this._getCurrentOptionStyles(item);\n\n      var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n\n      var title = _this._getPreviewText(item);\n\n      var onRenderCheckboxLabel = function () {\n        return onRenderOption(item, _this._onRenderOptionContent);\n      };\n\n      var getOptionComponent = function () {\n        return !_this.props.multiSelect ? React.createElement(CommandButton, {\n          id: id + '-list' + item.index,\n          key: item.key,\n          \"data-index\": item.index,\n          styles: optionStyles,\n          checked: isSelected,\n          className: 'ms-ComboBox-option',\n          onClick: _this._onItemClick(item),\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter: _this._onOptionMouseEnter.bind(_this, item.index),\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove: _this._onOptionMouseMove.bind(_this, item.index),\n          onMouseLeave: _this._onOptionMouseLeave,\n          role: \"option\",\n          \"aria-selected\": isSelected ? 'true' : 'false',\n          ariaLabel: _this._getPreviewText(item),\n          disabled: item.disabled,\n          title: title\n        }, React.createElement(\"span\", {\n          className: optionClassNames.optionTextWrapper,\n          ref: isSelected ? _this._selectedElement : undefined\n        }, onRenderOption(item, _this._onRenderOptionContent))) : React.createElement(Checkbox, {\n          id: id + '-list' + item.index,\n          ariaLabel: _this._getPreviewText(item),\n          key: item.key,\n          \"data-index\": item.index,\n          styles: optionStyles,\n          className: 'ms-ComboBox-option',\n          \"data-is-focusable\": true,\n          onChange: _this._onItemClick(item),\n          label: item.text,\n          role: \"option\",\n          checked: isChecked,\n          title: title,\n          disabled: item.disabled,\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel: onRenderCheckboxLabel,\n          inputProps: {\n            'aria-selected': isSelected ? 'true' : 'false'\n          }\n        });\n      };\n\n      return React.createElement(ComboBoxOptionWrapper, {\n        key: item.key,\n        index: item.index,\n        disabled: item.disabled,\n        isSelected: isSelected,\n        isChecked: isChecked,\n        text: item.text,\n        // eslint-disable-next-line react/jsx-no-bind\n        render: getOptionComponent,\n        data: item.data\n      });\n    };\n    /**\n     * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n     */\n\n\n    _this._onCalloutMouseDown = function (ev) {\n      ev.preventDefault();\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, ScrollIdleDelay);\n    };\n\n    _this._onRenderOptionContent = function (item) {\n      var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n      return React.createElement(\"span\", {\n        className: optionClassNames.optionText\n      }, item.text);\n    };\n    /**\n     * Handles dismissing (cancelling) the menu\n     */\n\n\n    _this._onDismiss = function () {\n      var onMenuDismiss = _this.props.onMenuDismiss;\n\n      if (onMenuDismiss) {\n        onMenuDismiss();\n      } // In persistMode we need to simulate callout layer mount\n      // since that only happens once. We do it on dismiss since\n      // it works either way.\n\n\n      if (_this.props.persistMenu) {\n        _this._onCalloutLayerMounted();\n      } // close the menu\n\n\n      _this._setOpenStateAndFocusOnClose(false\n      /* isOpen */\n      , false\n      /* focusInputAfterClose */\n      ); // reset the selected index\n      // to the last value state\n\n\n      _this._resetSelectedIndex();\n    };\n\n    _this._onAfterClearPendingInfo = function () {\n      _this._processingClearPendingInfo = false;\n    };\n    /**\n     * Handle keydown on the input\n     * @param ev - The keyboard event that was fired\n     */\n\n\n    _this._onInputKeyDown = function (ev) {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete;\n      var _b = _this.state,\n          isOpen = _b.isOpen,\n          currentOptions = _b.currentOptions,\n          currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover; // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _onInputKeyUp for reasoning.\n\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n\n      if (disabled) {\n        _this._handleInputWhenDisabled(ev);\n\n        return;\n      }\n\n      var index = _this._getPendingSelectedIndex(false\n      /* includeCurrentPendingValue */\n      );\n\n      switch (ev.which) {\n        case KeyCodes.enter:\n          if (_this._autofill.current && _this._autofill.current.inputElement) {\n            _this._autofill.current.inputElement.select();\n          }\n\n          _this._submitPendingValue(ev);\n\n          if (_this.props.multiSelect && isOpen) {\n            _this.setState({\n              currentPendingValueValidIndex: index\n            });\n          } else {\n            // On enter submit the pending value\n            if (isOpen || (!allowFreeform || _this.state.currentPendingValue === undefined || _this.state.currentPendingValue === null || _this.state.currentPendingValue.length <= 0) && _this.state.currentPendingValueValidIndex < 0) {\n              // if we are open or\n              // if we are not allowing freeform or\n              // our we have no pending value\n              // and no valid pending index\n              // flip the open state\n              _this.setState({\n                isOpen: !isOpen\n              });\n            }\n          }\n\n          break;\n\n        case KeyCodes.tab:\n          // On enter submit the pending value\n          if (!_this.props.multiSelect) {\n            _this._submitPendingValue(ev);\n          } // If we are not allowing freeform\n          // or the comboBox is open, flip the open state\n\n\n          if (isOpen) {\n            _this._setOpenStateAndFocusOnClose(!isOpen, false\n            /* focusInputAfterClose */\n            );\n          } // Allow TAB to propigate\n\n\n          return;\n\n        case KeyCodes.escape:\n          // reset the selected index\n          _this._resetSelectedIndex(); // Close the menu if opened\n\n\n          if (isOpen) {\n            _this.setState({\n              isOpen: false\n            });\n          } else {\n            return;\n          }\n\n          break;\n\n        case KeyCodes.up:\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the last index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = _this.state.currentOptions.length;\n          }\n\n          if (ev.altKey || ev.metaKey) {\n            // Close the menu if it is open and break so\n            // that the event get stopPropagation and prevent default.\n            // Otherwise, we need to let the event continue to propagate\n            if (isOpen) {\n              _this._setOpenStateAndFocusOnClose(!isOpen, true\n              /* focusInputAfterClose */\n              );\n\n              break;\n            }\n\n            return;\n          } // Go to the previous option\n\n\n          _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n\n          break;\n\n        case KeyCodes.down:\n          // Expand the comboBox on ALT + DownArrow\n          if (ev.altKey || ev.metaKey) {\n            _this._setOpenStateAndFocusOnClose(true\n            /* isOpen */\n            , true\n            /* focusInputAfterClose */\n            );\n          } else {\n            // if we are in clearAll state (e.g. the user as hovering\n            // and has since mousedOut of the menu items),\n            // go to the first index\n            if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n              index = -1;\n            } // Got to the next option\n\n\n            _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n          }\n\n          break;\n\n        case KeyCodes.home:\n        case KeyCodes.end:\n          if (allowFreeform) {\n            return;\n          } // Set the initial values to respond to HOME\n          // which goes to the first selectable option\n\n\n          index = -1;\n          var directionToSearch = SearchDirection.forward; // If end, update the values to respond to END\n          // which goes to the last selectable option\n\n          if (ev.which === KeyCodes.end) {\n            index = currentOptions.length;\n            directionToSearch = SearchDirection.backward;\n          }\n\n          _this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n\n          break;\n\n        /* eslint-disable no-fallthrough */\n\n        case KeyCodes.space:\n          // event handled in _onComboBoxKeyUp\n          if (!allowFreeform && autoComplete === 'off') {\n            break;\n          }\n\n        default:\n          /* eslint-enable no-fallthrough */\n          // are we processing a function key? if so bail out\n          if (ev.which >= 112\n          /* F1 */\n          && ev.which <= 123\n          /* F12 */\n          ) {\n            return;\n          } // If we get here and we got either and ALT key\n          // or meta key, let the event propagate\n\n\n          if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta'\n          /* && isOpen */\n          ) {\n            return;\n          } // If we are not allowing freeform and\n          // allowing autoComplete, handle the input here\n          // since we have marked the input as readonly\n\n\n          if (!allowFreeform && autoComplete === 'on') {\n            _this._onInputChange(ev.key);\n\n            break;\n          } // allow the key to propagate by default\n\n\n          return;\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n    /**\n     * Handle keyup on the input\n     * @param ev - the keyboard event that was fired\n     */\n\n\n    _this._onInputKeyUp = function (ev) {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete;\n      var isOpen = _this.state.isOpen; // We close the menu on key up only if ALL of the following are true:\n      // - Most recent key down was alt or meta (command)\n      // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n      //   expand/collapse the menu)\n      // - We're not on a Mac (or iOS)\n      // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n      // closing any open context menus. There is not a similar behavior on Macs.\n\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n\n      _this._lastKeyDownWasAltOrMeta = false;\n      var shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n      if (disabled) {\n        _this._handleInputWhenDisabled(ev);\n\n        return;\n      }\n\n      switch (ev.which) {\n        case KeyCodes.space:\n          // If we are not allowing freeform and are not autoComplete\n          // make space expand/collapse the comboBox\n          // and allow the event to propagate\n          if (!allowFreeform && autoComplete === 'off') {\n            _this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n          }\n\n          return;\n\n        default:\n          if (shouldHandleKey && isOpen) {\n            _this._setOpenStateAndFocusOnClose(!isOpen, true\n            /* focusInputAfterClose */\n            );\n          } else {\n            if (_this.state.focusState === 'focusing' && _this.props.openOnKeyboardFocus) {\n              _this.setState({\n                isOpen: true\n              });\n            }\n\n            if (_this.state.focusState !== 'focused') {\n              _this.setState({\n                focusState: 'focused'\n              });\n            }\n          }\n\n          return;\n      }\n    };\n\n    _this._onOptionMouseLeave = function () {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      } // Ignore the event in persistMenu mode if the callout has\n      // closed. This is to avoid clearing the visuals on item click.\n\n\n      if (_this.props.persistMenu && !_this.state.isOpen) {\n        return;\n      }\n\n      _this.setState({\n        currentPendingValueValidIndexOnHover: HoverStatus.clearAll\n      });\n    };\n    /**\n     * Click handler for the button of the comboBox\n     * and the input when not allowing freeform. This\n     * toggles the expand/collapse state of the comboBox (if enbled)\n     */\n\n\n    _this._onComboBoxClick = function () {\n      var disabled = _this.props.disabled;\n      var isOpen = _this.state.isOpen;\n\n      if (!disabled) {\n        _this._setOpenStateAndFocusOnClose(!isOpen, false\n        /* focusInputAfterClose */\n        );\n\n        _this.setState({\n          focusState: 'focused'\n        });\n      }\n    };\n    /**\n     * Click handler for the autofill.\n     */\n\n\n    _this._onAutofillClick = function () {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform;\n\n      if (allowFreeform && !disabled) {\n        _this.focus(_this.state.isOpen || _this._processingTouch);\n      } else {\n        _this._onComboBoxClick();\n      }\n    };\n\n    _this._onTouchStart = function () {\n      if (_this._comboBoxWrapper.current && !('onpointerdown' in _this._comboBoxWrapper)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._handleTouchAndPointerEvent();\n\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth'\n    });\n    _this._id = props.id || getId('ComboBox');\n\n    var selectedKeys = _this._buildDefaultSelectedKeys(props.defaultSelectedKey, props.selectedKey);\n\n    _this._isScrollIdle = true;\n    _this._processingTouch = false;\n    _this._gotMouseMove = false;\n    _this._processingClearPendingInfo = false;\n\n    var initialSelectedIndices = _this._getSelectedIndices(props.options, selectedKeys);\n\n    _this.state = {\n      isOpen: false,\n      selectedIndices: initialSelectedIndices,\n      focusState: 'none',\n      suggestedDisplayValue: undefined,\n      currentOptions: _this.props.options,\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    };\n    return _this;\n  }\n\n  Object.defineProperty(ComboBox.prototype, \"selectedOptions\", {\n    /**\n     * All selected options\n     */\n    get: function () {\n      var _a = this.state,\n          currentOptions = _a.currentOptions,\n          selectedIndices = _a.selectedIndices;\n      return getAllSelectedOptions(currentOptions, selectedIndices);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ComboBox.prototype.componentDidMount = function () {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  };\n\n  ComboBox.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    // Update the selectedIndex and currentOptions state if\n    // the selectedKey, value, or options have changed\n    if (newProps.selectedKey !== this.props.selectedKey || newProps.text !== this.props.text || newProps.options !== this.props.options) {\n      var selectedKeys = this._buildSelectedKeys(newProps.selectedKey);\n\n      var indices = this._getSelectedIndices(newProps.options, selectedKeys);\n\n      this.setState({\n        selectedIndices: indices,\n        currentOptions: newProps.options\n      });\n\n      if (newProps.selectedKey === null) {\n        this.setState({\n          suggestedDisplayValue: undefined\n        });\n      }\n    }\n  };\n\n  ComboBox.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _this = this;\n\n    var _a = this.props,\n        allowFreeform = _a.allowFreeform,\n        text = _a.text,\n        onMenuOpen = _a.onMenuOpen,\n        onMenuDismissed = _a.onMenuDismissed;\n    var _b = this.state,\n        isOpen = _b.isOpen,\n        selectedIndices = _b.selectedIndices,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex; // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(function () {\n        return _this._scrollIntoView();\n      }, 0);\n    } // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n\n\n    if (this._hasFocus() && (isOpen || prevState.isOpen && !isOpen && this._focusInputAfterClose && this._autofill.current && document.activeElement !== this._autofill.current.inputElement)) {\n      this.focus(undefined\n      /*shouldOpenOnFocus*/\n      , true\n      /*useFocusAsync*/\n      );\n    } // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n\n\n    if (this._focusInputAfterClose && (prevState.isOpen && !isOpen || this._hasFocus() && (!isOpen && !this.props.multiSelect && prevState.selectedIndices && selectedIndices && prevState.selectedIndices[0] !== selectedIndices[0] || !allowFreeform || text !== prevProps.text))) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  };\n\n  ComboBox.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  }; // Primary Render\n\n\n  ComboBox.prototype.render = function () {\n    var _this = this;\n\n    var id = this._id;\n    var errorMessageId = id + '-error';\n    var _a = this.props,\n        className = _a.className,\n        disabled = _a.disabled,\n        required = _a.required,\n        errorMessage = _a.errorMessage,\n        _b = _a.onRenderContainer,\n        onRenderContainer = _b === void 0 ? this._onRenderContainer : _b,\n        _c = _a.onRenderLabel,\n        onRenderLabel = _c === void 0 ? this._onRenderLabel : _c,\n        _d = _a.onRenderList,\n        onRenderList = _d === void 0 ? this._onRenderList : _d,\n        _e = _a.onRenderItem,\n        onRenderItem = _e === void 0 ? this._onRenderItem : _e,\n        _f = _a.onRenderOption,\n        onRenderOption = _f === void 0 ? this._onRenderOptionContent : _f,\n        allowFreeform = _a.allowFreeform,\n        customStyles = _a.styles,\n        theme = _a.theme,\n        keytipProps = _a.keytipProps,\n        persistMenu = _a.persistMenu,\n        multiSelect = _a.multiSelect;\n    var _g = this.state,\n        isOpen = _g.isOpen,\n        suggestedDisplayValue = _g.suggestedDisplayValue;\n    this._currentVisibleValue = this._getVisibleValue(); // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n\n    var multiselectAccessibleText = multiSelect ? this._getMultiselectDisplayString(this.state.selectedIndices, this.state.currentOptions, suggestedDisplayValue) : undefined;\n    var divProps = getNativeProps(this.props, divProperties, ['onChange', 'value']);\n    var hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n    this._classNames = this.props.getClassNames ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage, className) : getClassNames(getStyles(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage);\n    var comboBoxWrapper = keytipProps ? React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return _this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId, keytipAttributes);\n    }) : this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);\n    return React.createElement(\"div\", __assign({}, divProps, {\n      ref: this._root,\n      className: this._classNames.container\n    }), onRenderLabel({\n      props: this.props,\n      multiselectAccessibleText: multiselectAccessibleText\n    }, this._onRenderLabel), comboBoxWrapper, (persistMenu || isOpen) && onRenderContainer(__assign(__assign({}, this.props), {\n      onRenderList: onRenderList,\n      onRenderItem: onRenderItem,\n      onRenderOption: onRenderOption,\n      options: this.state.currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }),\n      onDismiss: this._onDismiss\n    }), this._onRenderContainer), React.createElement(\"div\", {\n      role: \"region\",\n      \"aria-live\": \"polite\",\n      \"aria-atomic\": \"true\",\n      id: errorMessageId,\n      className: hasErrorMessage ? this._classNames.errorMessage : ''\n    }, errorMessage !== undefined ? errorMessage : ''));\n  };\n\n  ComboBox.prototype._getPendingString = function (currentPendingValue, currentOptions, index) {\n    return currentPendingValue !== null && currentPendingValue !== undefined ? currentPendingValue : this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : '';\n  };\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combobox.\n   */\n\n\n  ComboBox.prototype._getMultiselectDisplayString = function (selectedIndices, currentOptions, suggestedDisplayValue) {\n    var displayValues = [];\n\n    for (var idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      var index = selectedIndices[idx];\n      displayValues.push(this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : this._normalizeToString(suggestedDisplayValue));\n    }\n\n    var _a = this.props.multiSelectDelimiter,\n        multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n    return displayValues.join(multiSelectDelimiter);\n  };\n  /**\n   * Is the index within the bounds of the array?\n   * @param options - options to check if the index is valid for\n   * @param index - the index to check\n   * @returns - true if the index is valid for the given options, false otherwise\n   */\n\n\n  ComboBox.prototype._indexWithinBounds = function (options, index) {\n    if (!options) {\n      return false;\n    }\n\n    return index >= 0 && index < options.length;\n  };\n  /**\n   * Process the new input's new value when the comboBox\n   * allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n\n\n  ComboBox.prototype._processInputChangeWithFreeform = function (updatedValue) {\n    var _this = this;\n\n    var currentOptions = this.state.currentOptions;\n    var newCurrentPendingValueValidIndex = -1; // if the new value is empty, see if we have an exact match\n    // and then set the pending info\n\n    if (updatedValue === '') {\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;\n      }).filter(function (option) {\n        return _this._getPreviewText(option) === updatedValue;\n      }); // if we found a match remember the index\n\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n\n      return;\n    } // Remember the original value and then,\n    // make the value lowercase for comparison\n\n\n    var originalUpdatedValue = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n    var newSuggestedDisplayValue = ''; // If autoComplete is on, attempt to find a match from the available options\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;\n      }).filter(function (option) {\n        return _this._getPreviewText(option).toLocaleLowerCase().indexOf(updatedValue) === 0;\n      });\n\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        var text = this._getPreviewText(items[0]); // If the user typed out the complete option text, we don't need any suggested display text anymore\n\n\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : ''; // remember the index of the match we found\n\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;\n      }).filter(function (option) {\n        return _this._getPreviewText(option).toLocaleLowerCase() === updatedValue;\n      }); // if we found a match remember the index\n\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } // Set the updated state\n\n\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  };\n  /**\n   * Process the new input's new value when the comboBox\n   * does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n\n\n  ComboBox.prototype._processInputChangeWithoutFreeform = function (updatedValue) {\n    var _this = this;\n\n    var _a = this.state,\n        currentPendingValue = _a.currentPendingValue,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentOptions = _a.currentOptions;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the keypresses and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with keypresses happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the udpated value\n        if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {\n          this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\n\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n          updatedValue = this._normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        var originalUpdatedValue = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase(); // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n\n        var items = currentOptions.map(function (item, i) {\n          return __assign(__assign({}, item), {\n            index: i\n          });\n        }).filter(function (option) {\n          return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;\n        }).filter(function (option) {\n          return option.text.toLocaleLowerCase().indexOf(updatedValue) === 0;\n        }); // If we found a match, udpdate the state\n\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));\n        } // Schedule a timeout to clear the pending value after the timeout span\n\n\n        this._lastReadOnlyAutoCompleteChangeTimeoutId = this._async.setTimeout(function () {\n          _this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    } // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n\n\n    var index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex(); // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n\n    this._setPendingInfoFromIndex(index);\n  };\n\n  ComboBox.prototype._getFirstSelectedIndex = function () {\n    return this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this.state.selectedIndices[0] : -1;\n  };\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n\n\n  ComboBox.prototype._getNextSelectableIndex = function (index, searchDirection) {\n    var currentOptions = this.state.currentOptions;\n    var newIndex = index + searchDirection;\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!this._indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    var option = currentOptions[newIndex];\n\n    if (option.itemType === SelectableOptionMenuItemType.Header || option.itemType === SelectableOptionMenuItemType.Divider || option.hidden === true) {\n      // Should we continue looking for an index to select?\n      if (searchDirection !== SearchDirection.none && (newIndex > 0 && searchDirection < SearchDirection.none || newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none)) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    } // We have the next valid selectable index, return it\n\n\n    return newIndex;\n  };\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n\n\n  ComboBox.prototype._setSelectedIndex = function (index, submitPendingValueEvent, searchDirection) {\n    var _this = this;\n\n    if (searchDirection === void 0) {\n      searchDirection = SearchDirection.none;\n    }\n\n    var _a = this.props,\n        onChange = _a.onChange,\n        onPendingValueChanged = _a.onPendingValueChanged;\n    var currentOptions = this.state.currentOptions;\n    var initialIndices = this.state.selectedIndices; // Clone selectedIndices so we don't mutate state\n\n    var selectedIndices = initialIndices ? initialIndices.slice() : []; // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!this._indexWithinBounds(currentOptions, index)) {\n      return;\n    } // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n\n\n    if (this.props.multiSelect || selectedIndices.length < 1 || selectedIndices.length === 1 && selectedIndices[0] !== index) {\n      var option_1 = __assign({}, currentOptions[index]); // if option doesn't existing, or option is disabled, we noop\n\n\n      if (!option_1 || option_1.disabled) {\n        return;\n      }\n\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combobox by checking the\n        // selectedIndices array and overriding the undefined issue\n        option_1.selected = option_1.selected !== undefined ? !option_1.selected : selectedIndices.indexOf(index) < 0;\n\n        if (option_1.selected && selectedIndices.indexOf(index) < 0) {\n          selectedIndices.push(index);\n        } else if (!option_1.selected && selectedIndices.indexOf(index) >= 0) {\n          selectedIndices = selectedIndices.filter(function (value) {\n            return value !== index;\n          });\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist(); // Only setstate if combobox is uncontrolled.\n\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If ComboBox value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n\n        if (onChange) {\n          onChange(submitPendingValueEvent, option_1, index, undefined);\n        }\n      } else {\n        // Update current options\n        var changedOptions = currentOptions.slice();\n        changedOptions[index] = option_1; // Call onChange after state is updated\n\n        this.setState({\n          selectedIndices: selectedIndices,\n          currentOptions: changedOptions\n        }, function () {\n          // If ComboBox value is changed, revert preview first\n          if (_this._hasPendingValue && onPendingValueChanged) {\n            onPendingValueChanged();\n            _this._hasPendingValue = false;\n          }\n\n          if (onChange) {\n            onChange(submitPendingValueEvent, option_1, index, undefined);\n          }\n        });\n      }\n    }\n\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    } // clear all of the pending info\n\n\n    this._clearPendingInfo();\n  };\n  /**\n   * Submit a pending value if there is one\n   */\n\n\n  ComboBox.prototype._submitPendingValue = function (submitPendingValueEvent) {\n    var _a = this.props,\n        onChange = _a.onChange,\n        allowFreeform = _a.allowFreeform,\n        autoComplete = _a.autoComplete;\n    var _b = this.state,\n        currentPendingValue = _b.currentPendingValue,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex,\n        currentOptions = _b.currentOptions,\n        currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover;\n    var selectedIndices = this.state.selectedIndices; // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n\n    if (this._processingClearPendingInfo) {\n      return;\n    } // If we allow freeform we need to handle that\n\n\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n\n          this._clearPendingInfo();\n        }\n\n        return;\n      } // Check to see if the user typed an exact match\n\n\n      if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        var pendingOptionText = this._getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase(); // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n\n\n        if (currentPendingValue.toLocaleLowerCase() === pendingOptionText || autoComplete && pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 && this._autofill.current && this._autofill.current.isValueSelected && currentPendingValue.length + (this._autofill.current.selectionEnd - this._autofill.current.selectionStart) === pendingOptionText.length || this._autofill.current && this._autofill.current.inputElement && this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n\n          if (this.props.multiSelect && this.state.isOpen) {\n            return;\n          }\n\n          this._clearPendingInfo();\n\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        var newOption = {\n          key: currentPendingValue || getId(),\n          text: this._normalizeToString(currentPendingValue)\n        }; // If it's multiselect, set selected state to true\n\n        if (this.props.multiSelect) {\n          newOption.selected = true;\n        }\n\n        var newOptions = currentOptions.concat([newOption]);\n\n        if (selectedIndices) {\n          if (!this.props.multiSelect) {\n            selectedIndices = [];\n          }\n\n          selectedIndices.push(newOptions.length - 1);\n        }\n\n        this.setState({\n          currentOptions: newOptions,\n          selectedIndices: selectedIndices\n        });\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    } // Finally, clear the pending info\n\n\n    this._clearPendingInfo();\n  };\n\n  ComboBox.prototype._onCalloutLayerMounted = function () {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }; // Render separator\n\n\n  ComboBox.prototype._renderSeparator = function (item) {\n    var index = item.index,\n        key = item.key;\n\n    if (index && index > 0) {\n      return React.createElement(\"div\", {\n        role: \"separator\",\n        key: key,\n        className: this._classNames.divider\n      });\n    }\n\n    return null;\n  };\n\n  ComboBox.prototype._renderHeader = function (item) {\n    var _a = this.props.onRenderOption,\n        onRenderOption = _a === void 0 ? this._onRenderOptionContent : _a;\n    return React.createElement(\"div\", {\n      key: item.key,\n      className: this._classNames.header\n    }, onRenderOption(item, this._onRenderOptionContent));\n  };\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n\n\n  ComboBox.prototype._isOptionSelected = function (index) {\n    var currentPendingValueValidIndexOnHover = this.state.currentPendingValueValidIndexOnHover; // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return this._getPendingSelectedIndex(true\n    /* includePendingValue */\n    ) === index ? true : false;\n  };\n\n  ComboBox.prototype._isOptionChecked = function (index) {\n    if (this.props.multiSelect && index !== undefined && this.state.selectedIndices) {\n      var idxOfSelectedIndex = -1;\n      idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n\n    return false;\n  };\n  /**\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n\n\n  ComboBox.prototype._getPendingSelectedIndex = function (includeCurrentPendingValue) {\n    var _a = this.state,\n        currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentPendingValue = _a.currentPendingValue;\n    return currentPendingValueValidIndexOnHover >= 0 ? currentPendingValueValidIndexOnHover : currentPendingValueValidIndex >= 0 || includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined ? currentPendingValueValidIndex : this.props.multiSelect ? 0 : this._getFirstSelectedIndex();\n  };\n  /**\n   * Scroll the selected element into view\n   */\n\n\n  ComboBox.prototype._scrollIntoView = function () {\n    var _a = this.props,\n        onScrollToItem = _a.onScrollToItem,\n        scrollSelectedToTop = _a.scrollSelectedToTop;\n    var _b = this.state,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex,\n        currentPendingValue = _b.currentPendingValue;\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(currentPendingValueValidIndex >= 0 || currentPendingValue !== '' ? currentPendingValueValidIndex : this._getFirstSelectedIndex());\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\n      // We are using refs, scroll the ref into view\n      if (scrollSelectedToTop) {\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\n      } else {\n        var alignToTop = true;\n\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n          var scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\n\n          var selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect(); // If we are completely in view then we do not need to scroll\n\n\n          if (scrollableParentRect.top <= selectedElementRect.top && scrollableParentRect.top + scrollableParentRect.height >= selectedElementRect.top + selectedElementRect.height) {\n            return;\n          } // If we are lower than the scrollable parent viewport then we should align to the bottom\n\n\n          if (scrollableParentRect.top + scrollableParentRect.height <= selectedElementRect.top + selectedElementRect.height) {\n            alignToTop = false;\n          }\n        }\n\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  };\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n\n\n  ComboBox.prototype._onItemClick = function (item) {\n    var _this = this;\n\n    var onItemClick = this.props.onItemClick;\n    var index = item.index;\n    return function (ev) {\n      // only close the callout when it's in single-select mode\n      if (!_this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        _this._autofill.current && _this._autofill.current.focus();\n\n        _this.setState({\n          isOpen: false\n        });\n      } // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n\n\n      onItemClick && onItemClick(ev, item, index);\n\n      _this._setSelectedIndex(index, ev);\n    };\n  };\n  /**\n   * Get the indices of the options that are marked as selected\n   * @param options - the comboBox options\n   * @param selectedKeys - the known selected keys to find\n   * @returns - an array of the indices of the selected options, empty array if nothing is selected\n   */\n\n\n  ComboBox.prototype._getSelectedIndices = function (options, selectedKeys) {\n    if (!options || !selectedKeys) {\n      return [];\n    }\n\n    var selectedIndices = {};\n    options.forEach(function (option, index) {\n      if (option.selected) {\n        selectedIndices[index] = true;\n      }\n    });\n\n    var _loop_1 = function (selectedKey) {\n      var index = findIndex(options, function (option) {\n        return option.key === selectedKey;\n      });\n\n      if (index > -1) {\n        selectedIndices[index] = true;\n      }\n    };\n\n    for (var _i = 0, selectedKeys_1 = selectedKeys; _i < selectedKeys_1.length; _i++) {\n      var selectedKey = selectedKeys_1[_i];\n\n      _loop_1(selectedKey);\n    }\n\n    return Object.keys(selectedIndices).map(Number).sort();\n  };\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n\n\n  ComboBox.prototype._resetSelectedIndex = function () {\n    var currentOptions = this.state.currentOptions;\n\n    this._clearPendingInfo();\n\n    var selectedIndex = this._getFirstSelectedIndex();\n\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.setState({\n        suggestedDisplayValue: currentOptions[selectedIndex].text\n      });\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.setState({\n        suggestedDisplayValue: this.props.text\n      });\n    }\n  };\n  /**\n   * Clears the pending info state\n   */\n\n\n  ComboBox.prototype._clearPendingInfo = function () {\n    this._processingClearPendingInfo = true;\n    this.setState({\n      currentPendingValue: undefined,\n      currentPendingValueValidIndex: -1,\n      suggestedDisplayValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    }, this._onAfterClearPendingInfo);\n  };\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n\n\n  ComboBox.prototype._setPendingInfo = function (currentPendingValue, currentPendingValueValidIndex, suggestedDisplayValue) {\n    if (currentPendingValueValidIndex === void 0) {\n      currentPendingValueValidIndex = -1;\n    }\n\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValue: this._normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      suggestedDisplayValue: suggestedDisplayValue,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    });\n  };\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n\n\n  ComboBox.prototype._setPendingInfoFromIndex = function (index) {\n    var currentOptions = this.state.currentOptions;\n\n    if (index >= 0 && index < currentOptions.length) {\n      var option = currentOptions[index];\n\n      this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  };\n  /**\n   * Sets the pending info for the comboBox\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n\n\n  ComboBox.prototype._setPendingInfoFromIndexAndDirection = function (index, searchDirection) {\n    var currentOptions = this.state.currentOptions; // update index to allow content to wrap\n\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    } // get the next \"valid\" index\n\n\n    var indexUpdate = this._getNextSelectableIndex(index, searchDirection); // if the two indicies are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n\n\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (this._indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  };\n\n  ComboBox.prototype._notifyPendingValueChanged = function (prevState) {\n    var onPendingValueChanged = this.props.onPendingValueChanged;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    var _a = this.state,\n        currentPendingValue = _a.currentPendingValue,\n        currentOptions = _a.currentOptions,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover;\n    var newPendingIndex = undefined;\n    var newPendingValue = undefined;\n\n    if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover && this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex && this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    } // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n\n\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  };\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n\n\n  ComboBox.prototype._setOpenStateAndFocusOnClose = function (isOpen, focusInputAfterClose) {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n\n\n  ComboBox.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n\n  ComboBox.prototype._onOptionMouseEnter = function (index) {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index\n    });\n  };\n\n  ComboBox.prototype._onOptionMouseMove = function (index) {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index\n    });\n  };\n\n  ComboBox.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handle dismissing the menu and\n   * eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n\n\n  ComboBox.prototype._handleInputWhenDisabled = function (ev) {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({\n          isOpen: false\n        });\n      } // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n\n\n      if (ev !== null && ev.which !== KeyCodes.tab && ev.which !== KeyCodes.escape && (ev.which < 112\n      /* F1 */\n      || ev.which > 123)\n      /* F12 */\n      ) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    }\n  };\n\n  ComboBox.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this; // If we already have an existing timeeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n\n\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  };\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n\n\n  ComboBox.prototype._getCaretButtonStyles = function () {\n    var customCaretDownButtonStyles = this.props.caretDownButtonStyles;\n    return getCaretDownButtonStyles(this.props.theme, customCaretDownButtonStyles);\n  };\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n\n\n  ComboBox.prototype._getCurrentOptionStyles = function (item) {\n    var customStylesForAllOptions = this.props.comboBoxOptionStyles;\n    var customStylesForCurrentOption = item.styles;\n    return getOptionStyles(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item), item.hidden);\n  };\n  /**\n   * Get the aria-activedescendant value for the comboxbox.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n\n\n  ComboBox.prototype._getAriaActiveDescendantValue = function () {\n    var descendantText = this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this._id + '-list' + this.state.selectedIndices[0] : undefined;\n\n    if (this.state.isOpen && this._hasFocus() && this.state.currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + this.state.currentPendingValueValidIndex;\n    }\n\n    return descendantText;\n  };\n  /**\n   * Get the aria autocomplete value for the Combobox\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\n   */\n\n\n  ComboBox.prototype._getAriaAutoCompleteValue = function () {\n    var autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? this.props.allowFreeform ? 'inline' : 'both' : 'none';\n  };\n\n  ComboBox.prototype._isPendingOption = function (item) {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  };\n  /**\n   * Given default selected key(s) and selected key(s), return the selected keys(s).\n   * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n   *\n   * @returns No matter what specific types the input parameters are, always return an array of\n   *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.\n   */\n\n\n  ComboBox.prototype._buildDefaultSelectedKeys = function (defaultSelectedKey, selectedKey) {\n    var selectedKeys = this._buildSelectedKeys(defaultSelectedKey);\n\n    if (selectedKeys.length) {\n      return selectedKeys;\n    }\n\n    return this._buildSelectedKeys(selectedKey);\n  };\n\n  ComboBox.prototype._buildSelectedKeys = function (selectedKey) {\n    if (selectedKey === undefined) {\n      return [];\n    } // need to cast here so typescript does not complain\n\n\n    return selectedKey instanceof Array ? selectedKey : [selectedKey];\n  }; // For scenarios where the option's text prop contains embedded styles, we use the option's\n  // ariaLabel value as the text in the input and for autocomplete matching. We know to use this\n  // when the useAriaLabelAsText prop is set to true\n\n\n  ComboBox.prototype._getPreviewText = function (item) {\n    return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n  };\n\n  ComboBox.prototype._normalizeToString = function (value) {\n    return value || '';\n  };\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n\n\n  ComboBox.prototype._hasFocus = function () {\n    return this.state.focusState !== 'none';\n  };\n\n  ComboBox.defaultProps = {\n    options: [],\n    allowFreeform: false,\n    autoComplete: 'on',\n    buttonIconProps: {\n      iconName: 'ChevronDown'\n    }\n  };\n  ComboBox = __decorate([customizable('ComboBox', ['theme', 'styles'], true)], ComboBox);\n  return ComboBox;\n}(React.Component);\n\nexport { ComboBox };","map":{"version":3,"mappings":"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","names":["React","Autofill","initializeComponentRef","css","customizable","divProperties","findElementRecursive","findIndex","focusAsync","getId","getNativeProps","isIOS","isMac","KeyCodes","shallowCompare","mergeAriaAttributeValues","warnMutuallyExclusive","Async","EventGroup","Callout","Checkbox","CommandButton","IconButton","DirectionalHint","getCaretDownButtonStyles","getOptionStyles","getStyles","getClassNames","getComboBoxOptionClassNames","KeytipData","Label","SelectableOptionMenuItemType","getAllSelectedOptions","SearchDirection","HoverStatus","ScrollIdleDelay","TouchIdleDelay","ReadOnlyPendingAutoCompleteTimeout","__extends","ComboBoxOptionWrapper","props","render","newProps","undefined","__assign","Component","COMPONENT_NAME","_super","_this","createRef","shouldOpenOnFocus","useFocusAsync","_autofill","current","focus","setState","isOpen","_hasFocus","focusState","comboBox","value","visibleValue","_normalizeToString","_currentVisibleValue","multiselectAccessibleText","errorMessageId","keytipAttributes","label","disabled","ariaLabel","ariaDescribedBy","required","errorMessage","buttonIconProps","_b","isButtonAriaHidden","title","placeholderProp","tabIndex","autofill","iconButtonProps","suggestedDisplayValue","placeholder","multiSelect","ref","_comboBoxWrapper","id","_id","className","_classNames","root","componentRef","input","type","onFocus","_onFocus","onBlur","_onBlur","onKeyDown","_onInputKeyDown","onKeyUp","_onInputKeyUp","onClick","_onAutofillClick","onTouchStart","_onTouchStart","onInputValueChange","_onInputChange","_getAriaAutoCompleteValue","role","readOnly","_getAriaActiveDescendantValue","spellCheck","defaultVisibleValue","updateValueInWillReceiveProps","_onUpdateValueInAutofillWillReceiveProps","shouldSelectFullInputValueInComponentDidUpdate","_onShouldSelectFullInputValueInAutofillComponentDidUpdate","preventValueSelection","styles","_getCaretButtonStyles","_onComboBoxClick","iconProps","checked","state","text","allowFreeform","autoComplete","selectedIndices","currentPendingValueValidIndex","currentOptions","currentPendingValue","currentPendingIndexValid","_indexWithinBounds","index","_getPendingString","_getMultiselectDisplayString","_getFirstSelectedIndex","updatedValue","_handleInputWhenDisabled","_processInputChangeWithFreeform","_processInputChangeWithoutFreeform","inputElement","select","onResolveOptions","newOptions","__spreadArrays","Array","isArray","then","promise_1","_currentPromise","newOptionsFromPromise","event","relatedTarget","document","activeElement","_root","contains","_comboBoxMenu","preventDefault","stopPropagation","_submitPendingValue","calloutProps","dropdownWidth","dropdownMaxWidth","_a","onRenderUpperContent","onRenderLowerContent","useComboBoxAsMenuWidth","persistMenu","_c","shouldRestoreFocus","comboBoxMenuWidth","clientWidth","isBeakVisible","gapSpace","doNotLayer","directionalHint","bottomLeftEdge","directionalHintFixed","onLayerMounted","_onLayerMounted","callout","target","onDismiss","_onDismiss","onMouseDown","_onCalloutMouseDown","onScroll","_onScroll","setInitialFocus","calloutWidth","calloutMaxWidth","hidden","_onRenderUpperContent","optionsContainerWrapper","onRenderList","_onRenderList","_onRenderLowerContent","_onCalloutLayerMounted","onRenderLabelProps","screenReaderText","options","optionsContainer","map","onRenderItem","item","_onRenderItem","itemType","Divider","_renderSeparator","Header","_renderHeader","_renderOption","isSelected","_isOptionSelected","isChecked","_isOptionChecked","optionStyles","_getCurrentOptionStyles","optionClassNames","_getPreviewText","onRenderCheckboxLabel","_onRenderOptionContent","getOptionComponent","key","_onItemClick","onMouseEnter","_onOptionMouseEnter","bind","onMouseMove","_onOptionMouseMove","onMouseLeave","_onOptionMouseLeave","optionTextWrapper","_selectedElement","onRenderOption","onChange","onRenderLabel","inputProps","data","ev","_isScrollIdle","_scrollIdleTimeoutId","_async","clearTimeout","setTimeout","optionText","onMenuDismiss","_setOpenStateAndFocusOnClose","_resetSelectedIndex","_processingClearPendingInfo","currentPendingValueValidIndexOnHover","_lastKeyDownWasAltOrMeta","_isAltOrMeta","_getPendingSelectedIndex","which","enter","length","tab","escape","up","clearAll","altKey","metaKey","_setPendingInfoFromIndexAndDirection","backward","down","forward","home","end","directionToSearch","space","keyCode","alt","keyPressIsAltOrMetaAlone","shouldHandleKey","openOnKeyboardFocus","_shouldIgnoreMouseEvent","_processingTouch","_handleTouchAndPointerEvent","pointerType","stopImmediatePropagation","_events","defaultSelectedKey","selectedKey","selectedKeys","_buildDefaultSelectedKeys","_gotMouseMove","initialSelectedIndices","_getSelectedIndices","default","Object","ComboBox","on","_onResolveOptions","_onPointerDown","_buildSelectedKeys","indices","prevProps","prevState","onMenuOpen","onMenuDismissed","_scrollIntoView","_focusInputAfterClose","_notifyPendingValueChanged","dispose","onRenderContainer","_d","_e","_f","customStyles","theme","keytipProps","_getVisibleValue","divProps","hasErrorMessage","comboBoxWrapper","_renderComboBoxWrapper","container","_onRenderLabel","_onRenderContainer","displayValues","idx","push","join","multiSelectDelimiter","newCurrentPendingValueValidIndex","items","filter","option","_setPendingInfo","originalUpdatedValue","toLocaleLowerCase","newSuggestedDisplayValue","indexOf","_lastReadOnlyAutoCompleteChangeTimeoutId","i","_setPendingInfoFromIndex","searchDirection","newIndex","Math","max","min","none","_getNextSelectableIndex","submitPendingValueEvent","onPendingValueChanged","initialIndices","slice","option_1","selected","persist","_hasPendingValue","changedOptions","_clearPendingInfo","_setSelectedIndex","pendingOptionText","isValueSelected","selectionEnd","selectionStart","newOption","concat","divider","header","idxOfSelectedIndex","includeCurrentPendingValue","onScrollToItem","scrollSelectedToTop","offsetParent","scrollIntoView","alignToTop","scrollableParentRect","getBoundingClientRect","selectedElementRect","top","height","onItemClick","forEach","_i","keys","Number","sort","selectedIndex","_onAfterClearPendingInfo","indexUpdate","newPendingIndex","newPendingValue","focusInputAfterClose","_lastTouchTimeoutId","customCaretDownButtonStyles","customStylesForAllOptions","customStylesForCurrentOption","_isPendingOption","descendantText","useAriaLabelAsText","iconName"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\ComboBox\\ComboBox.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Autofill, IAutofill } from '../Autofill/index';\nimport {\n  initializeComponentRef,\n  css,\n  customizable,\n  divProperties,\n  findElementRecursive,\n  findIndex,\n  focusAsync,\n  getId,\n  getNativeProps,\n  isIOS,\n  isMac,\n  KeyCodes,\n  shallowCompare,\n  mergeAriaAttributeValues,\n  warnMutuallyExclusive,\n  Async,\n  EventGroup,\n} from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { CommandButton, IButtonStyles, IconButton } from '../../Button';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport {\n  IComboBoxOption,\n  IComboBoxOptionStyles,\n  IComboBoxProps,\n  IOnRenderComboBoxLabelProps,\n  IComboBoxClassNames,\n} from './ComboBox.types';\nimport { KeytipData } from '../../KeytipData';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../utilities/selectableOption/index';\nimport { BaseButton, Button } from '../Button/index';\nimport { ICalloutProps } from '../../Callout';\n\nexport interface IComboBoxState {\n  /** The open state */\n  isOpen?: boolean;\n\n  /** The currently selected indices */\n  selectedIndices?: number[];\n\n  /** The focused state of the comboBox */\n  focusState?: 'none' | 'focused' | 'focusing';\n\n  /** This value is used for the autocomplete hint value */\n  suggestedDisplayValue?: string;\n\n  /** The options currently available for the callout */\n  currentOptions: IComboBoxOption[];\n\n  /**\n   * When taking input, this will store the index that the options input matches\n   * (-1 if no input or match)\n   */\n  currentPendingValueValidIndex: number;\n\n  /**\n   * Stores the hovered over value in the dropdown\n   * (used for styling the options without updating the input)\n   */\n  currentPendingValueValidIndexOnHover: number;\n\n  /** When taking input, this will store the actual text that is being entered */\n  currentPendingValue?: string;\n}\n\nenum SearchDirection {\n  backward = -1,\n  none = 0,\n  forward = 1,\n}\n\nenum HoverStatus {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  clearAll = -2,\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n  default = -1,\n}\n\nconst ScrollIdleDelay = 250; /* ms */\nconst TouchIdleDelay = 500; /* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\nconst ReadOnlyPendingAutoCompleteTimeout = 1000; /* ms */\n\ninterface IComboBoxOptionWrapperProps extends IComboBoxOption {\n  /** True if the option is currently selected */\n  isSelected: boolean;\n\n  /** True if the option is currently checked (multi-select) */\n  isChecked: boolean;\n\n  /**\n   * A function that returns the children of the OptionWrapper. We pass this in as a function to ensure that\n   * children methods don't get called unnecessarily if the component doesn't need to be updated. This leads\n   * to a significant performance increase in ComboBoxes with many options and/or complex onRenderOption functions\n   */\n  render: () => JSX.Element;\n}\n\n/**\n * Internal class that is used to wrap all ComboBox options.\n * This is used to customize when we want to rerender components,\n * so we don't rerender every option every time render is executed.\n */\nclass ComboBoxOptionWrapper extends React.Component<IComboBoxOptionWrapperProps, {}> {\n  public render(): React.ReactNode {\n    return this.props.render();\n  }\n\n  public shouldComponentUpdate(newProps: IComboBoxOptionWrapperProps): boolean {\n    // The render function will always be different, so we ignore that prop\n    return !shallowCompare({ ...this.props, render: undefined }, { ...newProps, render: undefined });\n  }\n}\n\nconst COMPONENT_NAME = 'ComboBox';\n\n@customizable('ComboBox', ['theme', 'styles'], true)\nexport class ComboBox extends React.Component<IComboBoxProps, IComboBoxState> {\n  public static defaultProps: IComboBoxProps = {\n    options: [],\n    allowFreeform: false,\n    autoComplete: 'on',\n    buttonIconProps: { iconName: 'ChevronDown' },\n  };\n\n  private _root = React.createRef<HTMLDivElement>();\n\n  /** The input aspect of the comboBox */\n  private _autofill = React.createRef<IAutofill>();\n\n  /** The wrapping div of the input and button */\n  private _comboBoxWrapper = React.createRef<HTMLDivElement>();\n\n  /** The callout element */\n  private _comboBoxMenu = React.createRef<HTMLDivElement>();\n\n  /** The menu item element that is currently selected */\n  private _selectedElement = React.createRef<HTMLSpanElement>();\n\n  /** The base id for the ComboBox */\n  private _id: string;\n\n  /**\n   * After a character is inserted when autocomplete is true and allowFreeform is false,\n   * remember the task that will clear the pending string of characters.\n   */\n  private _lastReadOnlyAutoCompleteChangeTimeoutId: number | undefined;\n\n  /** Promise used when resolving the comboBox options */\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\n\n  /** The current visible value sent to the auto fill on render */\n  private _currentVisibleValue: string | undefined;\n  private _classNames: IComboBoxClassNames;\n  private _isScrollIdle: boolean;\n  private _hasPendingValue: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n\n  /**\n   * Determines if we should be setting focus back to the input when the menu closes.\n   * The general rule of thumb is if the menu was launched via the keyboard focus should go back\n   * to the input, if it was dropped via the mouse focus should not be forced back to the input.\n   */\n  private _focusInputAfterClose: boolean;\n\n  /** Flag for when we get the first mouseMove */\n  private _gotMouseMove: boolean;\n\n  private _processingClearPendingInfo: boolean;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IComboBoxProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth',\n    });\n\n    this._id = props.id || getId('ComboBox');\n    const selectedKeys: string[] | number[] = this._buildDefaultSelectedKeys(\n      props.defaultSelectedKey,\n      props.selectedKey,\n    );\n\n    this._isScrollIdle = true;\n    this._processingTouch = false;\n    this._gotMouseMove = false;\n    this._processingClearPendingInfo = false;\n\n    const initialSelectedIndices: number[] = this._getSelectedIndices(props.options, selectedKeys);\n\n    this.state = {\n      isOpen: false,\n      selectedIndices: initialSelectedIndices,\n      focusState: 'none',\n      suggestedDisplayValue: undefined,\n      currentOptions: this.props.options,\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    };\n  }\n\n  /**\n   * All selected options\n   */\n  public get selectedOptions(): IComboBoxOption[] {\n    const { currentOptions, selectedIndices } = this.state;\n\n    return getAllSelectedOptions(currentOptions, selectedIndices!);\n  }\n\n  public componentDidMount(): void {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: IComboBoxProps): void {\n    // Update the selectedIndex and currentOptions state if\n    // the selectedKey, value, or options have changed\n    if (\n      newProps.selectedKey !== this.props.selectedKey ||\n      newProps.text !== this.props.text ||\n      newProps.options !== this.props.options\n    ) {\n      const selectedKeys: string[] | number[] = this._buildSelectedKeys(newProps.selectedKey);\n      const indices: number[] = this._getSelectedIndices(newProps.options, selectedKeys);\n\n      this.setState({\n        selectedIndices: indices,\n        currentOptions: newProps.options,\n      });\n      if (newProps.selectedKey === null) {\n        this.setState({\n          suggestedDisplayValue: undefined,\n        });\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IComboBoxProps, prevState: IComboBoxState) {\n    const { allowFreeform, text, onMenuOpen, onMenuDismissed } = this.props;\n    const { isOpen, selectedIndices, currentPendingValueValidIndex } = this.state;\n\n    // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(() => this._scrollIntoView(), 0);\n    }\n\n    // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n    if (\n      this._hasFocus() &&\n      (isOpen ||\n        (prevState.isOpen &&\n          !isOpen &&\n          this._focusInputAfterClose &&\n          this._autofill.current &&\n          document.activeElement !== this._autofill.current.inputElement))\n    ) {\n      this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\n    }\n\n    // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n    if (\n      this._focusInputAfterClose &&\n      ((prevState.isOpen && !isOpen) ||\n        (this._hasFocus() &&\n          ((!isOpen &&\n            !this.props.multiSelect &&\n            prevState.selectedIndices &&\n            selectedIndices &&\n            prevState.selectedIndices[0] !== selectedIndices[0]) ||\n            !allowFreeform ||\n            text !== prevProps.text)))\n    ) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  // Primary Render\n  public render(): JSX.Element {\n    const id = this._id;\n    const errorMessageId = id + '-error';\n    const {\n      className,\n      disabled,\n      required,\n      errorMessage,\n      onRenderContainer = this._onRenderContainer,\n      onRenderLabel = this._onRenderLabel,\n      onRenderList = this._onRenderList,\n      onRenderItem = this._onRenderItem,\n      onRenderOption = this._onRenderOptionContent,\n      allowFreeform,\n      styles: customStyles,\n      theme,\n      keytipProps,\n      persistMenu,\n      multiSelect,\n    } = this.props;\n    const { isOpen, suggestedDisplayValue } = this.state;\n    this._currentVisibleValue = this._getVisibleValue();\n\n    // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n    const multiselectAccessibleText = multiSelect\n      ? this._getMultiselectDisplayString(this.state.selectedIndices, this.state.currentOptions, suggestedDisplayValue)\n      : undefined;\n\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onChange',\n      'value',\n    ]);\n\n    const hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n\n    this._classNames = this.props.getClassNames\n      ? this.props.getClassNames(\n          theme!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n          className,\n        )\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          className!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n        );\n\n    const comboBoxWrapper = keytipProps ? (\n      <KeytipData keytipProps={keytipProps} disabled={disabled}>\n        {(keytipAttributes: any): JSX.Element =>\n          this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId, keytipAttributes)\n        }\n      </KeytipData>\n    ) : (\n      this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId)\n    );\n\n    return (\n      <div {...divProps} ref={this._root} className={this._classNames.container}>\n        {onRenderLabel({ props: this.props, multiselectAccessibleText }, this._onRenderLabel)}\n        {comboBoxWrapper}\n        {(persistMenu || isOpen) &&\n          onRenderContainer(\n            {\n              ...this.props,\n              onRenderList,\n              onRenderItem,\n              onRenderOption,\n              options: this.state.currentOptions.map((item, index) => ({ ...item, index: index })),\n              onDismiss: this._onDismiss,\n            },\n            this._onRenderContainer,\n          )}\n        <div\n          role=\"region\"\n          aria-live=\"polite\"\n          aria-atomic=\"true\"\n          id={errorMessageId}\n          className={hasErrorMessage ? this._classNames.errorMessage : ''}\n        >\n          {errorMessage !== undefined ? errorMessage : ''}\n        </div>\n      </div>\n    );\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public focus = (shouldOpenOnFocus?: boolean, useFocusAsync?: boolean): void => {\n    if (this._autofill.current) {\n      if (useFocusAsync) {\n        focusAsync(this._autofill.current);\n      } else {\n        this._autofill.current.focus();\n      }\n\n      if (shouldOpenOnFocus) {\n        this.setState({\n          isOpen: true,\n        });\n      }\n    }\n\n    // Programatically setting focus means that there is nothing else that needs to be done\n    // Focus is now contained\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Close menu callout if it is open\n   */\n  public dismissMenu = (): void => {\n    const { isOpen } = this.state;\n    isOpen && this.setState({ isOpen: false });\n  };\n\n  /**\n   * componentWillReceiveProps handler for the auto fill component\n   * Checks/updates the iput value to set, if needed\n   * @param defaultVisibleValue - the defaultVisibleValue that got passed\n   *  in to the auto fill's componentWillReceiveProps\n   * @returns - the updated value to set, if needed\n   */\n  private _onUpdateValueInAutofillWillReceiveProps = (): string | null => {\n    const comboBox = this._autofill.current;\n\n    if (!comboBox) {\n      return null;\n    }\n\n    if (comboBox.value === null || comboBox.value === undefined) {\n      return null;\n    }\n\n    const visibleValue = this._normalizeToString(this._currentVisibleValue);\n    if (comboBox.value !== visibleValue) {\n      // If visibleValue is empty, ensure that the empty string is used\n      return visibleValue || '';\n    }\n\n    return comboBox.value;\n  };\n\n  private _renderComboBoxWrapper = (\n    multiselectAccessibleText: string | undefined,\n    errorMessageId: string,\n    keytipAttributes: any = {},\n  ): JSX.Element => {\n    const {\n      label,\n      disabled,\n      ariaLabel,\n      ariaDescribedBy,\n      required,\n      errorMessage,\n      buttonIconProps,\n      isButtonAriaHidden = true,\n      title,\n      placeholder: placeholderProp,\n      tabIndex,\n      autofill,\n      iconButtonProps,\n    } = this.props;\n\n    const { isOpen, suggestedDisplayValue } = this.state;\n\n    // If the combobox has focus, is multiselect, and has a display string, then use that placeholder\n    // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n    // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n    // should be removed and the multiselect combobox should behave like a picker.\n    const placeholder =\n      this._hasFocus() && this.props.multiSelect && multiselectAccessibleText\n        ? multiselectAccessibleText\n        : placeholderProp;\n\n    return (\n      <div\n        data-ktp-target={keytipAttributes['data-ktp-target']}\n        ref={this._comboBoxWrapper}\n        id={this._id + 'wrapper'}\n        className={this._classNames.root}\n      >\n        <Autofill\n          data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n          data-is-interactable={!disabled}\n          componentRef={this._autofill}\n          id={this._id + '-input'}\n          className={this._classNames.input}\n          type=\"text\"\n          onFocus={this._onFocus}\n          onBlur={this._onBlur}\n          onKeyDown={this._onInputKeyDown}\n          onKeyUp={this._onInputKeyUp}\n          onClick={this._onAutofillClick}\n          onTouchStart={this._onTouchStart}\n          onInputValueChange={this._onInputChange}\n          aria-expanded={isOpen}\n          aria-autocomplete={this._getAriaAutoCompleteValue()}\n          role=\"combobox\"\n          readOnly={disabled}\n          aria-labelledby={label && this._id + '-label'}\n          aria-label={ariaLabel && !label ? ariaLabel : undefined}\n          aria-describedby={\n            errorMessage !== undefined\n              ? mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'], errorMessageId)\n              : mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])\n          }\n          aria-activedescendant={this._getAriaActiveDescendantValue()}\n          aria-required={required}\n          aria-disabled={disabled}\n          aria-owns={isOpen ? this._id + '-list' : undefined}\n          spellCheck={false}\n          defaultVisibleValue={this._currentVisibleValue}\n          suggestedDisplayValue={suggestedDisplayValue}\n          updateValueInWillReceiveProps={this._onUpdateValueInAutofillWillReceiveProps}\n          shouldSelectFullInputValueInComponentDidUpdate={\n            this._onShouldSelectFullInputValueInAutofillComponentDidUpdate\n          }\n          title={title}\n          preventValueSelection={!this._hasFocus()}\n          placeholder={placeholder}\n          tabIndex={tabIndex}\n          {...autofill}\n        />\n        <IconButton\n          className={'ms-ComboBox-CaretDown-button'}\n          styles={this._getCaretButtonStyles()}\n          role=\"presentation\"\n          aria-hidden={isButtonAriaHidden}\n          data-is-focusable={false}\n          tabIndex={-1}\n          onClick={this._onComboBoxClick}\n          onBlur={this._onBlur}\n          iconProps={buttonIconProps}\n          disabled={disabled}\n          checked={isOpen}\n          {...iconButtonProps}\n        />\n      </div>\n    );\n  };\n\n  /**\n   * componentDidUpdate handler for the auto fill component\n   *\n   * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n   * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n   * @returns - should the full value of the input be selected?\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n   */\n  private _onShouldSelectFullInputValueInAutofillComponentDidUpdate = (): boolean => {\n    return this._currentVisibleValue === this.state.suggestedDisplayValue;\n  };\n\n  /**\n   * Get the correct value to pass to the input\n   * to show to the user based off of the current props and state\n   * @returns the value to pass to the input\n   */\n  private _getVisibleValue = (): string | undefined => {\n    const { text, allowFreeform, autoComplete } = this.props;\n    const {\n      selectedIndices,\n      currentPendingValueValidIndex,\n      currentOptions,\n      currentPendingValue,\n      suggestedDisplayValue,\n      isOpen,\n    } = this.state;\n\n    const currentPendingIndexValid = this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);\n\n    // If the user passed is a value prop, use that\n    // unless we are open and have a valid current pending index\n    if (\n      !(isOpen && currentPendingIndexValid) &&\n      text &&\n      (currentPendingValue === null || currentPendingValue === undefined)\n    ) {\n      return text;\n    }\n\n    if (this.props.multiSelect) {\n      // Multi-select\n      if (this._hasFocus()) {\n        let index = -1;\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        return this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n      }\n    } else {\n      // Single-select\n      let index: number = this._getFirstSelectedIndex();\n      if (allowFreeform) {\n        // If we are allowing freeform and autocomplete is also true\n        // and we've got a pending value that matches an option, remember\n        // the matched option's index\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n\n        // Since we are allowing freeform, if there is currently a pending value, use that\n        // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        // If we are not allowing freeform and have a\n        // valid index that matches the pending value,\n        // we know we will need some version of the pending value\n        if (currentPendingIndexValid && autoComplete === 'on') {\n          // If autoComplete is on, return the\n          // raw pending value, otherwise remember\n          // the matched option's index\n          index = currentPendingValueValidIndex;\n          return this._normalizeToString(currentPendingValue);\n        } else if (!this.state.isOpen && currentPendingValue) {\n          return this._indexWithinBounds(currentOptions, index)\n            ? currentPendingValue\n            : this._normalizeToString(suggestedDisplayValue);\n        } else {\n          return this._indexWithinBounds(currentOptions, index)\n            ? currentOptions[index].text\n            : this._normalizeToString(suggestedDisplayValue);\n        }\n      }\n    }\n  };\n\n  private _getPendingString(\n    currentPendingValue: string | null | undefined,\n    currentOptions: IComboBoxOption[],\n    index: number,\n  ) {\n    return currentPendingValue !== null && currentPendingValue !== undefined\n      ? currentPendingValue\n      : this._indexWithinBounds(currentOptions, index)\n      ? currentOptions[index].text\n      : '';\n  }\n\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combobox.\n   */\n  private _getMultiselectDisplayString(\n    selectedIndices: number[] | undefined,\n    currentOptions: IComboBoxOption[],\n    suggestedDisplayValue: string | undefined,\n  ) {\n    const displayValues = [];\n    for (let idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      const index: number = selectedIndices[idx];\n      displayValues.push(\n        this._indexWithinBounds(currentOptions, index)\n          ? currentOptions[index].text\n          : this._normalizeToString(suggestedDisplayValue),\n      );\n    }\n    const { multiSelectDelimiter = ', ' } = this.props;\n    return displayValues.join(multiSelectDelimiter);\n  }\n\n  /**\n   * Is the index within the bounds of the array?\n   * @param options - options to check if the index is valid for\n   * @param index - the index to check\n   * @returns - true if the index is valid for the given options, false otherwise\n   */\n  private _indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\n    if (!options) {\n      return false;\n    }\n    return index >= 0 && index < options.length;\n  }\n\n  /**\n   * Handler for typing changes on the input\n   * @param updatedValue - the newly changed value\n   */\n  private _onInputChange = (updatedValue: string): void => {\n    if (this.props.disabled) {\n      this._handleInputWhenDisabled(null /* event */);\n      return;\n    }\n\n    this.props.allowFreeform\n      ? this._processInputChangeWithFreeform(updatedValue)\n      : this._processInputChangeWithoutFreeform(updatedValue);\n  };\n\n  /**\n   * Process the new input's new value when the comboBox\n   * allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithFreeform(updatedValue: string): void {\n    const { currentOptions } = this.state;\n    let newCurrentPendingValueValidIndex = -1;\n\n    // if the new value is empty, see if we have an exact match\n    // and then set the pending info\n    if (updatedValue === '') {\n      const items = currentOptions\n        .map((item, index) => {\n          return { ...item, index };\n        })\n        .filter(\n          option =>\n            option.itemType !== SelectableOptionMenuItemType.Header &&\n            option.itemType !== SelectableOptionMenuItemType.Divider,\n        )\n        .filter(option => this._getPreviewText(option) === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n      return;\n    }\n\n    // Remember the original value and then,\n    // make the value lowercase for comparison\n    const originalUpdatedValue: string = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n\n    let newSuggestedDisplayValue = '';\n\n    // If autoComplete is on, attempt to find a match from the available options\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      const items = currentOptions\n        .map((item, index) => {\n          return { ...item, index };\n        })\n        .filter(\n          option =>\n            option.itemType !== SelectableOptionMenuItemType.Header &&\n            option.itemType !== SelectableOptionMenuItemType.Divider,\n        )\n        .filter(\n          option =>\n            this._getPreviewText(option)\n              .toLocaleLowerCase()\n              .indexOf(updatedValue) === 0,\n        );\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        const text: string = this._getPreviewText(items[0]);\n\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\n\n        // remember the index of the match we found\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      const items = currentOptions\n        .map((item, index) => {\n          return { ...item, index };\n        })\n        .filter(\n          option =>\n            option.itemType !== SelectableOptionMenuItemType.Header &&\n            option.itemType !== SelectableOptionMenuItemType.Divider,\n        )\n        .filter(option => this._getPreviewText(option).toLocaleLowerCase() === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    }\n\n    // Set the updated state\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  }\n\n  /**\n   * Process the new input's new value when the comboBox\n   * does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithoutFreeform(updatedValue: string): void {\n    const { currentPendingValue, currentPendingValueValidIndex, currentOptions } = this.state;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the keypresses and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with keypresses happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the udpated value\n        if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {\n          this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n          updatedValue = this._normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        const originalUpdatedValue: string = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase();\n\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n        const items = currentOptions\n          .map((item, i) => {\n            return { ...item, index: i };\n          })\n          .filter(\n            option =>\n              option.itemType !== SelectableOptionMenuItemType.Header &&\n              option.itemType !== SelectableOptionMenuItemType.Divider,\n          )\n          .filter(option => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\n\n        // If we found a match, udpdate the state\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));\n        }\n\n        // Schedule a timeout to clear the pending value after the timeout span\n        this._lastReadOnlyAutoCompleteChangeTimeoutId = this._async.setTimeout(() => {\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    }\n\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n    const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\n\n    // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n    this._setPendingInfoFromIndex(index);\n  }\n\n  private _getFirstSelectedIndex(): number {\n    return this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this.state.selectedIndices[0] : -1;\n  }\n\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\n    const { currentOptions } = this.state;\n\n    let newIndex = index + searchDirection;\n\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!this._indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    const option: IComboBoxOption = currentOptions[newIndex];\n\n    if (\n      option.itemType === SelectableOptionMenuItemType.Header ||\n      option.itemType === SelectableOptionMenuItemType.Divider ||\n      option.hidden === true\n    ) {\n      // Should we continue looking for an index to select?\n      if (\n        searchDirection !== SearchDirection.none &&\n        ((newIndex > 0 && searchDirection < SearchDirection.none) ||\n          (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))\n      ) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    }\n\n    // We have the next valid selectable index, return it\n    return newIndex;\n  }\n\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n  private _setSelectedIndex(\n    index: number,\n    submitPendingValueEvent: React.SyntheticEvent<any>,\n    searchDirection: SearchDirection = SearchDirection.none,\n  ): void {\n    const { onChange, onPendingValueChanged } = this.props;\n    const { currentOptions } = this.state;\n    const { selectedIndices: initialIndices } = this.state;\n\n    // Clone selectedIndices so we don't mutate state\n    let selectedIndices = initialIndices ? initialIndices.slice() : [];\n\n    // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!this._indexWithinBounds(currentOptions, index)) {\n      return;\n    }\n\n    // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n    if (\n      this.props.multiSelect ||\n      selectedIndices.length < 1 ||\n      (selectedIndices.length === 1 && selectedIndices[0] !== index)\n    ) {\n      const option: IComboBoxOption = { ...currentOptions[index] };\n      // if option doesn't existing, or option is disabled, we noop\n      if (!option || option.disabled) {\n        return;\n      }\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combobox by checking the\n        // selectedIndices array and overriding the undefined issue\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\n        if (option.selected && selectedIndices.indexOf(index) < 0) {\n          selectedIndices.push(index);\n        } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n          selectedIndices = selectedIndices.filter((value: number) => value !== index);\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist();\n\n      // Only setstate if combobox is uncontrolled.\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If ComboBox value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n        if (onChange) {\n          onChange(submitPendingValueEvent, option, index, undefined);\n        }\n      } else {\n        // Update current options\n        const changedOptions = currentOptions.slice();\n        changedOptions[index] = option;\n\n        // Call onChange after state is updated\n        this.setState(\n          {\n            selectedIndices: selectedIndices,\n            currentOptions: changedOptions,\n          },\n          () => {\n            // If ComboBox value is changed, revert preview first\n            if (this._hasPendingValue && onPendingValueChanged) {\n              onPendingValueChanged();\n              this._hasPendingValue = false;\n            }\n\n            if (onChange) {\n              onChange(submitPendingValueEvent, option, index, undefined);\n            }\n          },\n        );\n      }\n    }\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    }\n    // clear all of the pending info\n    this._clearPendingInfo();\n  }\n\n  /**\n   * Focus (and select) the content of the input\n   * and set the focused state\n   */\n  private _onFocus = (): void => {\n    if (this._autofill.current && this._autofill.current.inputElement) {\n      this._autofill.current.inputElement.select();\n    }\n\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focusing' });\n    }\n  };\n\n  /**\n   * Callback issued when the options should be resolved, if they have been updated or\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\n   * callback was passed in\n   */\n  private _onResolveOptions = (): void => {\n    if (this.props.onResolveOptions) {\n      // get the options\n      const newOptions = this.props.onResolveOptions([...this.state.currentOptions]);\n\n      // Check to see if the returned value is an array, if it is update the state\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n      // If it is then resolve it asynchronously.\n      if (Array.isArray(newOptions)) {\n        this.setState({\n          currentOptions: newOptions,\n        });\n      } else if (newOptions && newOptions.then) {\n        // Ensure that the promise will only use the callback if it was the most recent one\n        // and update the state when the promise returns\n        const promise: PromiseLike<IComboBoxOption[]> = (this._currentPromise = newOptions);\n        promise.then((newOptionsFromPromise: IComboBoxOption[]) => {\n          if (promise === this._currentPromise) {\n            this.setState({\n              currentOptions: newOptionsFromPromise,\n            });\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * OnBlur handler. Set the focused state to false\n   * and submit any pending value\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  private _onBlur = (event: React.FocusEvent<HTMLElement | Autofill | BaseButton | Button>): void => {\n    // Do nothing if the blur is coming from something\n    // inside the comboBox root or the comboBox menu since\n    // it we are not really bluring from the whole comboBox\n    let relatedTarget = event.relatedTarget;\n    if (event.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = document.activeElement as Element;\n    }\n    if (\n      relatedTarget &&\n      // when event coming from withing the comboBox title\n      ((this._root.current && this._root.current.contains(relatedTarget as HTMLElement)) ||\n        // when event coming from within the comboBox list menu\n        (this._comboBoxMenu.current &&\n          (this._comboBoxMenu.current.contains(relatedTarget as HTMLElement) ||\n            // when event coming from the callout containing the comboBox list menu (ex: when scrollBar of the\n            // Callout is clicked) checks if the relatedTarget is a parent of _comboBoxMenu\n            findElementRecursive(this._comboBoxMenu.current, element => element === relatedTarget))))\n    ) {\n      event.preventDefault();\n      event.stopPropagation();\n      return;\n    }\n\n    if (this._hasFocus()) {\n      this.setState({ focusState: 'none' });\n      if (!this.props.multiSelect || this.props.allowFreeform) {\n        this._submitPendingValue(event);\n      }\n    }\n  };\n\n  /**\n   * Submit a pending value if there is one\n   */\n  private _submitPendingValue(submitPendingValueEvent: any): void {\n    const { onChange, allowFreeform, autoComplete } = this.props;\n    const {\n      currentPendingValue,\n      currentPendingValueValidIndex,\n      currentOptions,\n      currentPendingValueValidIndexOnHover,\n    } = this.state;\n    let { selectedIndices } = this.state;\n\n    // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    // If we allow freeform we need to handle that\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n          this._clearPendingInfo();\n        }\n\n        return;\n      }\n\n      // Check to see if the user typed an exact match\n      if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        const pendingOptionText: string = this._getPreviewText(\n          currentOptions[currentPendingValueValidIndex],\n        ).toLocaleLowerCase();\n\n        // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n        if (\n          currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\n          (autoComplete &&\n            pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\n            this._autofill.current &&\n            this._autofill.current.isValueSelected &&\n            currentPendingValue.length +\n              (this._autofill.current.selectionEnd! - this._autofill.current.selectionStart!) ===\n              pendingOptionText.length) ||\n          (this._autofill.current &&\n            this._autofill.current.inputElement &&\n            this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText)\n        ) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n          if (this.props.multiSelect && this.state.isOpen) {\n            return;\n          }\n          this._clearPendingInfo();\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        const newOption: IComboBoxOption = {\n          key: currentPendingValue || getId(),\n          text: this._normalizeToString(currentPendingValue),\n        };\n        // If it's multiselect, set selected state to true\n        if (this.props.multiSelect) {\n          newOption.selected = true;\n        }\n        const newOptions: IComboBoxOption[] = currentOptions.concat([newOption]);\n        if (selectedIndices) {\n          if (!this.props.multiSelect) {\n            selectedIndices = [];\n          }\n          selectedIndices.push(newOptions.length - 1);\n        }\n        this.setState({\n          currentOptions: newOptions,\n          selectedIndices: selectedIndices,\n        });\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    }\n\n    // Finally, clear the pending info\n    this._clearPendingInfo();\n  }\n\n  // Render Callout container and pass in list\n  private _onRenderContainer = (props: IComboBoxProps): JSX.Element => {\n    const {\n      onRenderList,\n      calloutProps,\n      dropdownWidth,\n      dropdownMaxWidth,\n      onRenderUpperContent = this._onRenderUpperContent,\n      onRenderLowerContent = this._onRenderLowerContent,\n      useComboBoxAsMenuWidth,\n      persistMenu,\n      shouldRestoreFocus = true,\n    } = props;\n\n    const { isOpen } = this.state;\n\n    const comboBoxMenuWidth =\n      useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n        ? this._comboBoxWrapper.current.clientWidth + 2\n        : undefined;\n\n    return (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={0}\n        doNotLayer={false}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintFixed={false}\n        {...calloutProps}\n        onLayerMounted={this._onLayerMounted}\n        className={css(this._classNames.callout, calloutProps ? calloutProps.className : undefined)}\n        target={this._comboBoxWrapper.current}\n        onDismiss={this._onDismiss}\n        onMouseDown={this._onCalloutMouseDown}\n        onScroll={this._onScroll}\n        setInitialFocus={false}\n        calloutWidth={\n          useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n            ? comboBoxMenuWidth && comboBoxMenuWidth\n            : dropdownWidth\n        }\n        calloutMaxWidth={dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth}\n        hidden={persistMenu ? !isOpen : undefined}\n        shouldRestoreFocus={shouldRestoreFocus}\n      >\n        {onRenderUpperContent(this.props, this._onRenderUpperContent)}\n        <div className={this._classNames.optionsContainerWrapper} ref={this._comboBoxMenu}>\n          {(onRenderList as any)({ ...props }, this._onRenderList)}\n        </div>\n        {onRenderLowerContent(this.props, this._onRenderLowerContent)}\n      </Callout>\n    );\n  };\n\n  private _onCalloutLayerMounted() {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }\n\n  private _onLayerMounted = () => {\n    this._onCalloutLayerMounted();\n\n    if (this.props.calloutProps && this.props.calloutProps.onLayerMounted) {\n      this.props.calloutProps.onLayerMounted();\n    }\n  };\n\n  private _onRenderLabel = (onRenderLabelProps: IOnRenderComboBoxLabelProps): JSX.Element | null => {\n    const { label, disabled, required } = onRenderLabelProps.props;\n\n    if (label) {\n      return (\n        <Label id={this._id + '-label'} disabled={disabled} required={required} className={this._classNames.label}>\n          {label}\n          {onRenderLabelProps.multiselectAccessibleText && (\n            <span className={this._classNames.screenReaderText}>{onRenderLabelProps.multiselectAccessibleText}</span>\n          )}\n        </Label>\n      );\n    }\n\n    return null;\n  };\n\n  // Render List of items\n  private _onRenderList = (props: IComboBoxProps): JSX.Element => {\n    const { onRenderItem, options } = props;\n\n    const id = this._id;\n    return (\n      <div\n        id={id + '-list'}\n        className={this._classNames.optionsContainer}\n        aria-labelledby={id + '-label'}\n        role=\"listbox\"\n      >\n        {options.map(item => (onRenderItem as any)(item, this._onRenderItem))}\n      </div>\n    );\n  };\n\n  // Render items\n  private _onRenderItem = (item: IComboBoxOption): JSX.Element | null => {\n    switch (item.itemType) {\n      case SelectableOptionMenuItemType.Divider:\n        return this._renderSeparator(item);\n      case SelectableOptionMenuItemType.Header:\n        return this._renderHeader(item);\n      default:\n        return this._renderOption(item);\n    }\n  };\n\n  // Default _onRenderLowerContent function returns nothing\n  private _onRenderLowerContent = (): null => {\n    return null;\n  };\n\n  // Default _onRenderUpperContent function returns nothing\n  private _onRenderUpperContent = (): null => {\n    return null;\n  };\n\n  // Render separator\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\n    const { index, key } = item;\n\n    if (index && index > 0) {\n      return <div role=\"separator\" key={key} className={this._classNames.divider} />;\n    }\n    return null;\n  }\n\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n\n    return (\n      <div key={item.key} className={this._classNames.header}>\n        {onRenderOption(item, this._onRenderOptionContent)}\n      </div>\n    );\n  }\n\n  private _renderOption = (item: IComboBoxOption): JSX.Element => {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n    const id = this._id;\n    const isSelected: boolean = this._isOptionSelected(item.index);\n    const isChecked: boolean = this._isOptionChecked(item.index);\n    const optionStyles = this._getCurrentOptionStyles(item);\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    const title = this._getPreviewText(item);\n\n    const onRenderCheckboxLabel = () => onRenderOption(item, this._onRenderOptionContent);\n\n    const getOptionComponent = () => {\n      return !this.props.multiSelect ? (\n        <CommandButton\n          id={id + '-list' + item.index}\n          key={item.key}\n          data-index={item.index}\n          styles={optionStyles}\n          checked={isSelected}\n          className={'ms-ComboBox-option'}\n          onClick={this._onItemClick(item)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter={this._onOptionMouseEnter.bind(this, item.index)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove={this._onOptionMouseMove.bind(this, item.index)}\n          onMouseLeave={this._onOptionMouseLeave}\n          role=\"option\"\n          aria-selected={isSelected ? 'true' : 'false'}\n          ariaLabel={this._getPreviewText(item)}\n          disabled={item.disabled}\n          title={title}\n        >\n          {\n            <span className={optionClassNames.optionTextWrapper} ref={isSelected ? this._selectedElement : undefined}>\n              {onRenderOption(item, this._onRenderOptionContent)}\n            </span>\n          }\n        </CommandButton>\n      ) : (\n        <Checkbox\n          id={id + '-list' + item.index}\n          ariaLabel={this._getPreviewText(item)}\n          key={item.key}\n          data-index={item.index}\n          styles={optionStyles}\n          className={'ms-ComboBox-option'}\n          data-is-focusable={true}\n          onChange={this._onItemClick(item)}\n          label={item.text}\n          role=\"option\"\n          checked={isChecked}\n          title={title}\n          disabled={item.disabled}\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel={onRenderCheckboxLabel}\n          inputProps={{\n            'aria-selected': isSelected ? 'true' : 'false',\n          }}\n        />\n      );\n    };\n\n    return (\n      <ComboBoxOptionWrapper\n        key={item.key}\n        index={item.index}\n        disabled={item.disabled}\n        isSelected={isSelected}\n        isChecked={isChecked}\n        text={item.text}\n        // eslint-disable-next-line react/jsx-no-bind\n        render={getOptionComponent}\n        data={item.data}\n      />\n    );\n  };\n\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n  private _isOptionSelected(index: number | undefined): boolean {\n    const { currentPendingValueValidIndexOnHover } = this.state;\n\n    // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return this._getPendingSelectedIndex(true /* includePendingValue */) === index ? true : false;\n  }\n\n  private _isOptionChecked(index: number | undefined): boolean {\n    if (this.props.multiSelect && index !== undefined && this.state.selectedIndices) {\n      let idxOfSelectedIndex = -1;\n\n      idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n    return false;\n  }\n\n  /**\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n  private _getPendingSelectedIndex(includeCurrentPendingValue: boolean): number {\n    const { currentPendingValueValidIndexOnHover, currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    return currentPendingValueValidIndexOnHover >= 0\n      ? currentPendingValueValidIndexOnHover\n      : currentPendingValueValidIndex >= 0 ||\n        (includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined)\n      ? currentPendingValueValidIndex\n      : this.props.multiSelect\n      ? 0\n      : this._getFirstSelectedIndex();\n  }\n\n  /**\n   * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n   */\n  private _onCalloutMouseDown: ICalloutProps['onMouseDown'] = ev => {\n    ev.preventDefault();\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = () => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, ScrollIdleDelay);\n  };\n\n  /**\n   * Scroll the selected element into view\n   */\n  private _scrollIntoView(): void {\n    const { onScrollToItem, scrollSelectedToTop } = this.props;\n\n    const { currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(\n        currentPendingValueValidIndex >= 0 || currentPendingValue !== ''\n          ? currentPendingValueValidIndex\n          : this._getFirstSelectedIndex(),\n      );\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\n      // We are using refs, scroll the ref into view\n      if (scrollSelectedToTop) {\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\n      } else {\n        let alignToTop = true;\n\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n          const scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\n          const selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();\n\n          // If we are completely in view then we do not need to scroll\n          if (\n            scrollableParentRect.top <= selectedElementRect.top &&\n            scrollableParentRect.top + scrollableParentRect.height >=\n              selectedElementRect.top + selectedElementRect.height\n          ) {\n            return;\n          }\n\n          // If we are lower than the scrollable parent viewport then we should align to the bottom\n          if (\n            scrollableParentRect.top + scrollableParentRect.height <=\n            selectedElementRect.top + selectedElementRect.height\n          ) {\n            alignToTop = false;\n          }\n        }\n\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  }\n\n  private _onRenderOptionContent = (item: IComboBoxOption): JSX.Element => {\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    return <span className={optionClassNames.optionText}>{item.text}</span>;\n  };\n\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n  private _onItemClick(item: IComboBoxOption): (ev: any) => void {\n    const { onItemClick } = this.props;\n    const { index } = item;\n\n    return (ev: any): void => {\n      // only close the callout when it's in single-select mode\n      if (!this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        this._autofill.current && this._autofill.current.focus();\n        this.setState({\n          isOpen: false,\n        });\n      }\n\n      // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n      onItemClick && onItemClick(ev, item, index);\n      this._setSelectedIndex(index as number, ev);\n    };\n  }\n\n  /**\n   * Handles dismissing (cancelling) the menu\n   */\n  private _onDismiss = (): void => {\n    const { onMenuDismiss } = this.props;\n    if (onMenuDismiss) {\n      onMenuDismiss();\n    }\n\n    // In persistMode we need to simulate callout layer mount\n    // since that only happens once. We do it on dismiss since\n    // it works either way.\n    if (this.props.persistMenu) {\n      this._onCalloutLayerMounted();\n    }\n\n    // close the menu\n    this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\n\n    // reset the selected index\n    // to the last value state\n    this._resetSelectedIndex();\n  };\n\n  /**\n   * Get the indices of the options that are marked as selected\n   * @param options - the comboBox options\n   * @param selectedKeys - the known selected keys to find\n   * @returns - an array of the indices of the selected options, empty array if nothing is selected\n   */\n  private _getSelectedIndices(\n    options: IComboBoxOption[] | undefined,\n    selectedKeys: (string | number | undefined)[],\n  ): number[] {\n    if (!options || !selectedKeys) {\n      return [];\n    }\n\n    const selectedIndices: { [key: number]: boolean } = {};\n    options.forEach((option: IComboBoxOption, index: number) => {\n      if (option.selected) {\n        selectedIndices[index] = true;\n      }\n    });\n\n    for (const selectedKey of selectedKeys) {\n      const index = findIndex(options, option => option.key === selectedKey);\n      if (index > -1) {\n        selectedIndices[index] = true;\n      }\n    }\n\n    return Object.keys(selectedIndices)\n      .map(Number)\n      .sort();\n  }\n\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n  private _resetSelectedIndex(): void {\n    const { currentOptions } = this.state;\n    this._clearPendingInfo();\n\n    const selectedIndex: number = this._getFirstSelectedIndex();\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.setState({\n        suggestedDisplayValue: currentOptions[selectedIndex].text,\n      });\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.setState({\n        suggestedDisplayValue: this.props.text,\n      });\n    }\n  }\n\n  /**\n   * Clears the pending info state\n   */\n  private _clearPendingInfo(): void {\n    this._processingClearPendingInfo = true;\n\n    this.setState(\n      {\n        currentPendingValue: undefined,\n        currentPendingValueValidIndex: -1,\n        suggestedDisplayValue: undefined,\n        currentPendingValueValidIndexOnHover: HoverStatus.default,\n      },\n      this._onAfterClearPendingInfo,\n    );\n  }\n\n  private _onAfterClearPendingInfo = () => {\n    this._processingClearPendingInfo = false;\n  };\n\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n  private _setPendingInfo(\n    currentPendingValue?: string,\n    currentPendingValueValidIndex: number = -1,\n    suggestedDisplayValue?: string,\n  ): void {\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValue: this._normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      suggestedDisplayValue: suggestedDisplayValue,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    });\n  }\n\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n  private _setPendingInfoFromIndex(index: number): void {\n    const { currentOptions } = this.state;\n\n    if (index >= 0 && index < currentOptions.length) {\n      const option = currentOptions[index];\n      this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  }\n\n  /**\n   * Sets the pending info for the comboBox\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n  private _setPendingInfoFromIndexAndDirection(index: number, searchDirection: SearchDirection): void {\n    const { currentOptions } = this.state;\n\n    // update index to allow content to wrap\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    }\n\n    // get the next \"valid\" index\n    const indexUpdate = this._getNextSelectableIndex(index, searchDirection);\n\n    // if the two indicies are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (this._indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  }\n\n  private _notifyPendingValueChanged(prevState: IComboBoxState): void {\n    const { onPendingValueChanged } = this.props;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    const {\n      currentPendingValue,\n      currentOptions,\n      currentPendingValueValidIndex,\n      currentPendingValueValidIndexOnHover,\n    } = this.state;\n\n    let newPendingIndex: number | undefined = undefined;\n    let newPendingValue: string | undefined = undefined;\n\n    if (\n      currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\n      this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)\n    ) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (\n      currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\n      this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)\n    ) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    }\n\n    // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(\n        newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined,\n        newPendingIndex,\n        newPendingValue,\n      );\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  }\n\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n  private _setOpenStateAndFocusOnClose(isOpen: boolean, focusInputAfterClose: boolean): void {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen,\n    });\n  }\n\n  /**\n   * Handle keydown on the input\n   * @param ev - The keyboard event that was fired\n   */\n  private _onInputKeyDown = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const { disabled, allowFreeform, autoComplete } = this.props;\n    const { isOpen, currentOptions, currentPendingValueValidIndexOnHover } = this.state;\n\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _onInputKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\n\n    switch (ev.which) {\n      case KeyCodes.enter:\n        if (this._autofill.current && this._autofill.current.inputElement) {\n          this._autofill.current.inputElement.select();\n        }\n\n        this._submitPendingValue(ev);\n        if (this.props.multiSelect && isOpen) {\n          this.setState({\n            currentPendingValueValidIndex: index,\n          });\n        } else {\n          // On enter submit the pending value\n          if (\n            isOpen ||\n            ((!allowFreeform ||\n              this.state.currentPendingValue === undefined ||\n              this.state.currentPendingValue === null ||\n              this.state.currentPendingValue.length <= 0) &&\n              this.state.currentPendingValueValidIndex < 0)\n          ) {\n            // if we are open or\n            // if we are not allowing freeform or\n            // our we have no pending value\n            // and no valid pending index\n            // flip the open state\n            this.setState({\n              isOpen: !isOpen,\n            });\n          }\n        }\n        break;\n\n      case KeyCodes.tab:\n        // On enter submit the pending value\n        if (!this.props.multiSelect) {\n          this._submitPendingValue(ev);\n        }\n\n        // If we are not allowing freeform\n        // or the comboBox is open, flip the open state\n        if (isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n        }\n\n        // Allow TAB to propigate\n        return;\n\n      case KeyCodes.escape:\n        // reset the selected index\n        this._resetSelectedIndex();\n\n        // Close the menu if opened\n        if (isOpen) {\n          this.setState({\n            isOpen: false,\n          });\n        } else {\n          return;\n        }\n        break;\n\n      case KeyCodes.up:\n        // if we are in clearAll state (e.g. the user as hovering\n        // and has since mousedOut of the menu items),\n        // go to the last index\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n          index = this.state.currentOptions.length;\n        }\n\n        if (ev.altKey || ev.metaKey) {\n          // Close the menu if it is open and break so\n          // that the event get stopPropagation and prevent default.\n          // Otherwise, we need to let the event continue to propagate\n          if (isOpen) {\n            this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n            break;\n          }\n\n          return;\n        }\n\n        // Go to the previous option\n        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n        break;\n\n      case KeyCodes.down:\n        // Expand the comboBox on ALT + DownArrow\n        if (ev.altKey || ev.metaKey) {\n          this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\n        } else {\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the first index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = -1;\n          }\n\n          // Got to the next option\n          this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n        }\n        break;\n\n      case KeyCodes.home:\n      case KeyCodes.end:\n        if (allowFreeform) {\n          return;\n        }\n\n        // Set the initial values to respond to HOME\n        // which goes to the first selectable option\n        index = -1;\n        let directionToSearch = SearchDirection.forward;\n\n        // If end, update the values to respond to END\n        // which goes to the last selectable option\n        if (ev.which === KeyCodes.end) {\n          index = currentOptions.length;\n          directionToSearch = SearchDirection.backward;\n        }\n\n        this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n        break;\n\n      /* eslint-disable no-fallthrough */\n      case KeyCodes.space:\n        // event handled in _onComboBoxKeyUp\n        if (!allowFreeform && autoComplete === 'off') {\n          break;\n        }\n\n      default:\n        /* eslint-enable no-fallthrough */\n        // are we processing a function key? if so bail out\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\n          return;\n        }\n\n        // If we get here and we got either and ALT key\n        // or meta key, let the event propagate\n        if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {\n          return;\n        }\n\n        // If we are not allowing freeform and\n        // allowing autoComplete, handle the input here\n        // since we have marked the input as readonly\n        if (!allowFreeform && autoComplete === 'on') {\n          this._onInputChange(ev.key);\n          break;\n        }\n\n        // allow the key to propagate by default\n        return;\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement | Autofill>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Handle keyup on the input\n   * @param ev - the keyboard event that was fired\n   */\n  private _onInputKeyUp = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const { disabled, allowFreeform, autoComplete } = this.props;\n    const isOpen = this.state.isOpen;\n\n    // We close the menu on key up only if ALL of the following are true:\n    // - Most recent key down was alt or meta (command)\n    // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n    //   expand/collapse the menu)\n    // - We're not on a Mac (or iOS)\n    // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n    // closing any open context menus. There is not a similar behavior on Macs.\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    const shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    switch (ev.which) {\n      case KeyCodes.space:\n        // If we are not allowing freeform and are not autoComplete\n        // make space expand/collapse the comboBox\n        // and allow the event to propagate\n        if (!allowFreeform && autoComplete === 'off') {\n          this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n        }\n        return;\n      default:\n        if (shouldHandleKey && isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n        } else {\n          if (this.state.focusState === 'focusing' && this.props.openOnKeyboardFocus) {\n            this.setState({ isOpen: true });\n          }\n          if (this.state.focusState !== 'focused') {\n            this.setState({ focusState: 'focused' });\n          }\n        }\n        return;\n    }\n  };\n\n  private _onOptionMouseEnter(index: number): void {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseMove(index: number): void {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseLeave = () => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    // Ignore the event in persistMenu mode if the callout has\n    // closed. This is to avoid clearing the visuals on item click.\n    if (this.props.persistMenu && !this.state.isOpen) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: HoverStatus.clearAll,\n    });\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  /**\n   * Handle dismissing the menu and\n   * eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | Autofill> | null): void {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({ isOpen: false });\n      }\n\n      // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n      if (\n        ev !== null &&\n        ev.which !== KeyCodes.tab &&\n        ev.which !== KeyCodes.escape &&\n        (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */\n      ) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Click handler for the button of the comboBox\n   * and the input when not allowing freeform. This\n   * toggles the expand/collapse state of the comboBox (if enbled)\n   */\n  private _onComboBoxClick = (): void => {\n    const { disabled } = this.props;\n    const { isOpen } = this.state;\n\n    if (!disabled) {\n      this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Click handler for the autofill.\n   */\n  private _onAutofillClick = (): void => {\n    const { disabled, allowFreeform } = this.props;\n\n    if (allowFreeform && !disabled) {\n      this.focus(this.state.isOpen || this._processingTouch);\n    } else {\n      this._onComboBoxClick();\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (this._comboBoxWrapper.current && !('onpointerdown' in this._comboBoxWrapper)) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCaretButtonStyles(): IButtonStyles {\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCurrentOptionStyles(item: IComboBoxOption): Partial<IComboBoxOptionStyles> {\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\n    const { styles: customStylesForCurrentOption } = item;\n\n    return getOptionStyles(\n      this.props.theme!,\n      customStylesForAllOptions,\n      customStylesForCurrentOption,\n      this._isPendingOption(item),\n      item.hidden,\n    );\n  }\n\n  /**\n   * Get the aria-activedescendant value for the comboxbox.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n  private _getAriaActiveDescendantValue(): string | undefined {\n    let descendantText =\n      this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length > 0\n        ? this._id + '-list' + this.state.selectedIndices[0]\n        : undefined;\n    if (this.state.isOpen && this._hasFocus() && this.state.currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + this.state.currentPendingValueValidIndex;\n    }\n    return descendantText;\n  }\n\n  /**\n   * Get the aria autocomplete value for the Combobox\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\n   */\n  private _getAriaAutoCompleteValue(): 'none' | 'inline' | 'list' | 'both' | undefined {\n    const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';\n  }\n\n  private _isPendingOption(item: IComboBoxOption): boolean {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  }\n\n  /**\n   * Given default selected key(s) and selected key(s), return the selected keys(s).\n   * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n   *\n   * @returns No matter what specific types the input parameters are, always return an array of\n   *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.\n   */\n  private _buildDefaultSelectedKeys(\n    defaultSelectedKey: string | number | string[] | number[] | null | undefined,\n    selectedKey: string | number | string[] | number[] | null | undefined,\n  ): string[] | number[] {\n    const selectedKeys: string[] | number[] = this._buildSelectedKeys(defaultSelectedKey);\n    if (selectedKeys.length) {\n      return selectedKeys;\n    }\n    return this._buildSelectedKeys(selectedKey);\n  }\n\n  private _buildSelectedKeys(\n    selectedKey: string | number | string[] | number[] | null | undefined,\n  ): string[] | number[] {\n    if (selectedKey === undefined) {\n      return [];\n    }\n\n    // need to cast here so typescript does not complain\n    return (selectedKey instanceof Array ? selectedKey : [selectedKey]) as string[] | number[];\n  }\n\n  // For scenarios where the option's text prop contains embedded styles, we use the option's\n  // ariaLabel value as the text in the input and for autocomplete matching. We know to use this\n  // when the useAriaLabelAsText prop is set to true\n  private _getPreviewText(item: IComboBoxOption): string {\n    return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n  }\n\n  private _normalizeToString(value?: string): string {\n    return value || '';\n  }\n\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n  private _hasFocus() {\n    return this.state.focusState !== 'none';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}