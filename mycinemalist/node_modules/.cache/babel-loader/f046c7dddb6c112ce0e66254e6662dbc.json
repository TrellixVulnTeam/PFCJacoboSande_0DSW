{"ast":null,"code":"import { SELECTION_CHANGE, SELECTION_ITEMS_CHANGE, SelectionMode } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\n/**\n * {@docCategory Selection}\n */\n\nvar Selection =\n/** @class */\nfunction () {\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  function Selection() {\n    var options = []; // Otherwise, arguments require options with `getKey`.\n\n    for (var _i = 0 // Otherwise, arguments require options with `getKey`.\n    ; _i < arguments.length // Otherwise, arguments require options with `getKey`.\n    ; _i++ // Otherwise, arguments require options with `getKey`.\n    ) {\n      options[_i] = arguments[_i]; // Otherwise, arguments require options with `getKey`.\n    }\n\n    var _a = options[0] || {},\n        onSelectionChanged = _a.onSelectionChanged,\n        onItemsChanged = _a.onItemsChanged,\n        getKey = _a.getKey,\n        _b = _a.canSelectItem,\n        canSelectItem = _b === void 0 ? function () {\n      return true;\n    } : _b,\n        items = _a.items,\n        _c = _a.selectionMode,\n        selectionMode = _c === void 0 ? SelectionMode.multiple : _c;\n\n    this.mode = selectionMode;\n    this._getKey = getKey || defaultGetKey;\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n    this._onSelectionChanged = onSelectionChanged;\n    this._onItemsChanged = onItemsChanged;\n    this._canSelectItem = canSelectItem;\n    this._keyToIndexMap = {};\n    this._isModal = false;\n    this.setItems(items || [], true);\n    this.count = this.getSelectedCount();\n  }\n\n  Selection.prototype.canSelectItem = function (item, index) {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  };\n\n  Selection.prototype.getKey = function (item, index) {\n    var key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? \"\" + key : '';\n  };\n\n  Selection.prototype.setChangeEvents = function (isEnabled, suppressChange) {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  };\n\n  Selection.prototype.isModal = function () {\n    return this._isModal;\n  };\n\n  Selection.prototype.setModal = function (isModal) {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  };\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n\n\n  Selection.prototype.setItems = function (items, shouldClear) {\n    if (shouldClear === void 0) {\n      shouldClear = true;\n    }\n\n    var newKeyToIndexMap = {};\n    var newUnselectableIndices = {};\n    var hasSelectionChanged = false;\n    this.setChangeEvents(false); // Reset the unselectable count.\n\n    this._unselectableCount = 0;\n    var haveItemsChanged = false; // Build lookup table for quick selection evaluation.\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item) {\n        var key = this.getKey(item, i);\n\n        if (key) {\n          if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {\n            haveItemsChanged = true;\n          }\n\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    } // Check the exemption list for discrepencies.\n\n\n    var newExemptedIndicies = {};\n    var newExemptedCount = 0;\n\n    for (var indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        var index = Number(indexProperty);\n        var item = this._items[index];\n        var exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    if (!haveItemsChanged) {\n      for (var _i = 0, _a = Object.keys(this._keyToIndexMap); _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (!(key in newKeyToIndexMap)) {\n          haveItemsChanged = true;\n          break;\n        }\n      }\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n    }\n\n    if (haveItemsChanged) {\n      EventGroup.raise(this, SELECTION_ITEMS_CHANGE);\n\n      if (this._onItemsChanged) {\n        this._onItemsChanged();\n      }\n    }\n\n    if (hasSelectionChanged) {\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.getItems = function () {\n    return this._items;\n  };\n\n  Selection.prototype.getSelection = function () {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n      var items = this._items;\n\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  };\n\n  Selection.prototype.getSelectedCount = function () {\n    return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;\n  };\n\n  Selection.prototype.getSelectedIndices = function () {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n      var items = this._items;\n\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  };\n\n  Selection.prototype.getItemIndex = function (key) {\n    var index = this._keyToIndexMap[key];\n    return index !== null && index !== void 0 ? index : -1;\n  };\n\n  Selection.prototype.isRangeSelected = function (fromIndex, count) {\n    if (count === 0) {\n      return false;\n    }\n\n    var endIndex = fromIndex + count;\n\n    for (var i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.isAllSelected = function () {\n    var selectableCount = this._items.length - this._unselectableCount; // In single mode, we can only have a max of 1 item.\n\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return this.count > 0 && this._isAllSelected && this._exemptedCount === 0 || !this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0;\n  };\n\n  Selection.prototype.isKeySelected = function (key) {\n    var index = this._keyToIndexMap[key];\n    return this.isIndexSelected(index);\n  };\n\n  Selection.prototype.isIndexSelected = function (index) {\n    return !!(this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index] || !this._isAllSelected && this._exemptedIndices[index]);\n  };\n\n  Selection.prototype.setAllSelected = function (isAllSelected) {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.setKeySelected = function (key, isSelected, shouldAnchor) {\n    var index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  };\n\n  Selection.prototype.setIndexSelected = function (index, isSelected, shouldAnchor) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    } // Clamp the index.\n\n\n    index = Math.min(Math.max(0, index), this._items.length - 1); // No-op on out of bounds selections.\n\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    var isExempt = this._exemptedIndices[index];\n    var canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      } // Determine if we need to remove the exemption.\n\n\n      if (isExempt && (isSelected && this._isAllSelected || !isSelected && !this._isAllSelected)) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      } // Determine if we need to add the exemption.\n\n\n      if (!isExempt && (isSelected && !this._isAllSelected || !isSelected && this._isAllSelected)) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.selectToKey = function (key, clearSelection) {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  };\n\n  Selection.prototype.selectToIndex = function (index, clearSelection) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    var anchorIndex = this._anchoredIndex || 0;\n    var startIndex = Math.min(index, anchorIndex);\n    var endIndex = Math.max(index, anchorIndex);\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.toggleAllSelected = function () {\n    this.setAllSelected(!this.isAllSelected());\n  };\n\n  Selection.prototype.toggleKeySelected = function (key) {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  };\n\n  Selection.prototype.toggleIndexSelected = function (index) {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  };\n\n  Selection.prototype.toggleRangeSelected = function (fromIndex, count) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    var isRangeSelected = this.isRangeSelected(fromIndex, count);\n    var endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    for (var i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype._updateCount = function (preserveModalState) {\n    if (preserveModalState === void 0) {\n      preserveModalState = false;\n    }\n\n    var count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n\n      this._change();\n    }\n\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  };\n\n  Selection.prototype._setAllSelected = function (isAllSelected, preserveModalState) {\n    if (preserveModalState === void 0) {\n      preserveModalState = false;\n    }\n\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n\n        this._change();\n      }\n\n      this._updateCount(preserveModalState);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype._change = function () {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  };\n\n  return Selection;\n}();\n\nexport { Selection };\n\nfunction defaultGetKey(item, index) {\n  // 0 may be used as a key\n  var _a = (item || {}).key,\n      key = _a === void 0 ? \"\" + index : _a;\n  return key;\n}","map":{"version":3,"mappings":"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","names":["SELECTION_CHANGE","SELECTION_ITEMS_CHANGE","SelectionMode","EventGroup","_i","options","onSelectionChanged","onItemsChanged","getKey","_b","canSelectItem","items","_c","selectionMode","mode","_getKey","defaultGetKey","_changeEventSuppressionCount","_exemptedCount","_anchoredIndex","_unselectableCount","_onSelectionChanged","_onItemsChanged","_canSelectItem","_keyToIndexMap","_isModal","setItems","count","getSelectedCount","Selection","item","index","key","isEnabled","suppressChange","_hasChanged","_change","isModal","setChangeEvents","setAllSelected","shouldClear","newKeyToIndexMap","newUnselectableIndices","hasSelectionChanged","haveItemsChanged","i","length","_setAllSelected","newExemptedIndicies","newExemptedCount","indexProperty","_exemptedIndices","hasOwnProperty","Number","_items","exemptKey","undefined","newIndex","_isAllSelected","keys","_unselectableIndices","_selectedItems","_updateCount","raise","isIndexSelected","push","_selectedIndices","fromIndex","endIndex","selectableCount","single","Math","min","isAllSelected","multiple","isSelected","shouldAnchor","setIndexSelected","none","max","isExempt","canSelect","clearSelection","selectToIndex","anchorIndex","startIndex","setKeySelected","isKeySelected","isRangeSelected","preserveModalState","setModal"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\node_modules\\@uifabric\\utilities\\lib\\src\\selection\\Selection.ts"],"sourcesContent":["import { IObjectWithKey, ISelection, SELECTION_CHANGE, SELECTION_ITEMS_CHANGE, SelectionMode } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionOptions<TItem = IObjectWithKey> {\n  onSelectionChanged?: () => void;\n  onItemsChanged?: () => void;\n  /** Custom logic to generate item keys. Required if `TItem` does not have a `key` property. */\n  getKey?: (item: TItem, index?: number) => string | number;\n  canSelectItem?: (item: TItem, index?: number) => boolean;\n  selectionMode?: SelectionMode;\n  items?: TItem[];\n}\n\n/**\n * Selection options with required `getKey` property.\n * {@docCategory Selection}\n */\nexport type ISelectionOptionsWithRequiredGetKey<TItem> = ISelectionOptions<TItem> &\n  Required<Pick<ISelectionOptions<TItem>, 'getKey'>>;\n\n/**\n * {@docCategory Selection}\n */\nexport class Selection<TItem = IObjectWithKey> implements ISelection<TItem> {\n  /** Number of items selected. Do not modify. */\n  public count: number;\n  public readonly mode: SelectionMode;\n\n  private _getKey: (item: TItem, index?: number) => string | number;\n  private _canSelectItem: (item: TItem, index?: number) => boolean;\n\n  private _changeEventSuppressionCount: number;\n  private _items: TItem[];\n  private _selectedItems: TItem[] | null;\n  private _selectedIndices: number[] | undefined;\n  private _isAllSelected: boolean;\n  private _exemptedIndices: { [index: string]: boolean };\n  private _exemptedCount: number;\n  private _keyToIndexMap: { [key: string]: number };\n  private _anchoredIndex: number;\n  private _onSelectionChanged: (() => void) | undefined;\n  private _onItemsChanged: (() => void) | undefined;\n  private _hasChanged!: boolean;\n  private _unselectableIndices!: { [index: string]: boolean };\n  private _unselectableCount: number;\n  private _isModal: boolean;\n\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  constructor(\n    ...options: TItem extends IObjectWithKey // If the item type has a built-in key...\n      ? [] | [ISelectionOptions<TItem>] // Then the arguments can be empty or have the options without `getKey`\n      : [ISelectionOptionsWithRequiredGetKey<TItem>] // Otherwise, arguments require options with `getKey`.\n  ) {\n    const {\n      onSelectionChanged,\n      onItemsChanged,\n      getKey,\n      canSelectItem = () => true,\n      items,\n      selectionMode = SelectionMode.multiple,\n    } = options[0] || ({} as ISelectionOptions<TItem>);\n\n    this.mode = selectionMode;\n\n    this._getKey = getKey || defaultGetKey;\n\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n\n    this._onSelectionChanged = onSelectionChanged;\n    this._onItemsChanged = onItemsChanged;\n    this._canSelectItem = canSelectItem;\n    this._keyToIndexMap = {};\n\n    this._isModal = false;\n\n    this.setItems(items || [], true);\n\n    this.count = this.getSelectedCount();\n  }\n\n  public canSelectItem(item: TItem, index?: number): boolean {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  }\n\n  public getKey(item: TItem, index?: number): string {\n    const key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? `${key}` : '';\n  }\n\n  public setChangeEvents(isEnabled: boolean, suppressChange?: boolean): void {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  }\n\n  public isModal(): boolean {\n    return this._isModal;\n  }\n\n  public setModal(isModal: boolean): void {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n  public setItems(items: TItem[], shouldClear: boolean = true): void {\n    const newKeyToIndexMap: { [key: string]: number } = {};\n    const newUnselectableIndices: { [key: string]: boolean } = {};\n    let hasSelectionChanged = false;\n\n    this.setChangeEvents(false);\n\n    // Reset the unselectable count.\n    this._unselectableCount = 0;\n\n    let haveItemsChanged = false;\n\n    // Build lookup table for quick selection evaluation.\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      if (item) {\n        const key = this.getKey(item, i);\n\n        if (key) {\n          if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {\n            haveItemsChanged = true;\n          }\n\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    }\n\n    // Check the exemption list for discrepencies.\n    const newExemptedIndicies: { [key: string]: boolean } = {};\n    let newExemptedCount = 0;\n\n    for (const indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        const index = Number(indexProperty);\n        const item = this._items[index];\n        const exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        const newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    if (!haveItemsChanged) {\n      for (const key of Object.keys(this._keyToIndexMap)) {\n        if (!(key in newKeyToIndexMap)) {\n          haveItemsChanged = true;\n          break;\n        }\n      }\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n    }\n\n    if (haveItemsChanged) {\n      EventGroup.raise(this, SELECTION_ITEMS_CHANGE);\n\n      if (this._onItemsChanged) {\n        this._onItemsChanged();\n      }\n    }\n\n    if (hasSelectionChanged) {\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public getItems(): TItem[] {\n    return this._items;\n  }\n\n  public getSelection(): TItem[] {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  }\n\n  public getSelectedCount(): number {\n    return this._isAllSelected\n      ? this._items.length - this._exemptedCount - this._unselectableCount\n      : this._exemptedCount;\n  }\n\n  public getSelectedIndices(): number[] {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  }\n\n  public getItemIndex(key: string): number {\n    const index = this._keyToIndexMap[key];\n\n    return index ?? -1;\n  }\n\n  public isRangeSelected(fromIndex: number, count: number): boolean {\n    if (count === 0) {\n      return false;\n    }\n\n    const endIndex = fromIndex + count;\n\n    for (let i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public isAllSelected(): boolean {\n    let selectableCount = this._items.length - this._unselectableCount;\n\n    // In single mode, we can only have a max of 1 item.\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return (\n      (this.count > 0 && this._isAllSelected && this._exemptedCount === 0) ||\n      (!this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0)\n    );\n  }\n\n  public isKeySelected(key: string): boolean {\n    const index = this._keyToIndexMap[key];\n\n    return this.isIndexSelected(index);\n  }\n\n  public isIndexSelected(index: number): boolean {\n    return !!(\n      (this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index]) ||\n      (!this._isAllSelected && this._exemptedIndices[index])\n    );\n  }\n\n  public setAllSelected(isAllSelected: boolean): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public setKeySelected(key: string, isSelected: boolean, shouldAnchor: boolean): void {\n    const index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  }\n\n  public setIndexSelected(index: number, isSelected: boolean, shouldAnchor: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    // Clamp the index.\n    index = Math.min(Math.max(0, index), this._items.length - 1);\n\n    // No-op on out of bounds selections.\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    const isExempt = this._exemptedIndices[index];\n    const canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      }\n\n      // Determine if we need to remove the exemption.\n      if (isExempt && ((isSelected && this._isAllSelected) || (!isSelected && !this._isAllSelected))) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      }\n\n      // Determine if we need to add the exemption.\n      if (!isExempt && ((isSelected && !this._isAllSelected) || (!isSelected && this._isAllSelected))) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  }\n\n  public selectToKey(key: string, clearSelection?: boolean): void {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  }\n\n  public selectToIndex(index: number, clearSelection?: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = Math.min(index, anchorIndex);\n    const endIndex = Math.max(index, anchorIndex);\n\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public toggleAllSelected(): void {\n    this.setAllSelected(!this.isAllSelected());\n  }\n\n  public toggleKeySelected(key: string): void {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  }\n\n  public toggleIndexSelected(index: number): void {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  }\n\n  public toggleRangeSelected(fromIndex: number, count: number): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    const isRangeSelected = this.isRangeSelected(fromIndex, count);\n    const endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    for (let i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n    this.setChangeEvents(true);\n  }\n\n  private _updateCount(preserveModalState: boolean = false): void {\n    const count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n      this._change();\n    }\n\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  }\n\n  private _setAllSelected(isAllSelected: boolean, preserveModalState: boolean = false): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount(preserveModalState);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  private _change(): void {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  }\n}\n\nfunction defaultGetKey<TItem = IObjectWithKey>(item: TItem, index?: number): string | number {\n  // 0 may be used as a key\n  const { key = `${index}` } = (item || {}) as IObjectWithKey;\n  return key;\n}\n"]},"metadata":{},"sourceType":"module"}