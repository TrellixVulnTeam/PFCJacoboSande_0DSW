{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, getId, allowScrollOnElement, allowOverscrollOnElement, KeyCodes, elementContains, warnDeprecations, Async, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../FocusTrapZone/index';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../Popup/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { DirectionalHint } from '../Callout/index';\nimport { Icon } from '../Icon/index';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { initializeComponentRef } from '@uifabric/utilities'; // @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\nvar DefaultLayerProps = {\n  eventBubblingEnabled: false\n};\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'Modal';\n\nvar ModalBase =\n/** @class */\nfunction (_super) {\n  __extends(ModalBase, _super);\n\n  function ModalBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._focusTrapZone = React.createRef();\n\n    _this._registerInitialModalPosition = function () {\n      var _a;\n\n      if (((_a = _this.props.dragOptions) === null || _a === void 0 ? void 0 : _a.keepInBounds) && !_this._minClampedPosition && !_this._maxClampedPosition) {\n        var dialogMain = document.querySelector(\"[data-id=\" + _this.state.id + \"]\");\n\n        if (dialogMain) {\n          var modalRectangle = dialogMain.getBoundingClientRect();\n          _this._minClampedPosition = {\n            x: -modalRectangle.x,\n            y: -modalRectangle.y\n          };\n          _this._maxClampedPosition = {\n            x: modalRectangle.x,\n            y: modalRectangle.y\n          };\n        }\n      }\n    }; // Allow the user to scroll within the modal but not on the body\n\n\n    _this._allowScrollOnModal = function (elt) {\n      if (elt) {\n        if (_this._allowTouchBodyScroll) {\n          allowOverscrollOnElement(elt, _this._events);\n        } else {\n          allowScrollOnElement(elt, _this._events);\n        }\n      } else {\n        _this._events.off(_this._scrollableContent);\n      }\n\n      _this._scrollableContent = elt;\n    };\n\n    _this._onModalContextMenuClose = function () {\n      _this.setState({\n        isModalMenuOpen: false\n      });\n    };\n\n    _this._onModalClose = function () {\n      _this._lastSetX = 0;\n      _this._lastSetY = 0;\n\n      _this.setState({\n        isModalMenuOpen: false,\n        isInKeyboardMoveMode: false,\n        isOpen: false,\n        x: 0,\n        y: 0\n      });\n\n      if (_this.props.dragOptions && _this._hasRegisteredKeyUp) {\n        _this._events.off(window, 'keyup', _this._onKeyUp, true\n        /* useCapture */\n        );\n      } // Call the onDismiss callback\n\n\n      if (_this.props.onDismissed) {\n        _this.props.onDismissed();\n      }\n    };\n\n    _this._onDragStart = function () {\n      _this.setState({\n        isModalMenuOpen: false,\n        isInKeyboardMoveMode: false\n      });\n    };\n\n    _this._onDrag = function (_, ui) {\n      var _a = _this.state,\n          x = _a.x,\n          y = _a.y;\n\n      _this.setState(_this._getClampedPosition({\n        x: x + ui.delta.x,\n        y: y + ui.delta.y\n      }));\n    };\n\n    _this._onDragStop = function () {\n      _this.focus();\n    };\n\n    _this._onKeyUp = function (event) {\n      // Need to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // Otherwise it would continue to fire a click even if the event was cancelled\n      // during mouseDown.\n      if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n        // Since this is a global handler, we should make sure the target is within the dialog\n        // before opening the dropdown\n        if (elementContains(_this._scrollableContent, event.target)) {\n          _this.setState({\n            isModalMenuOpen: !_this.state.isModalMenuOpen\n          });\n\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    }; // We need a global onKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n\n\n    _this._onKeyDown = function (event) {\n      if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n\n      if (_this.state.isModalMenuOpen && (event.altKey || event.keyCode === KeyCodes.escape)) {\n        _this.setState({\n          isModalMenuOpen: false\n        });\n      }\n\n      if (_this.state.isInKeyboardMoveMode && (event.keyCode === KeyCodes.escape || event.keyCode === KeyCodes.enter)) {\n        _this.setState({\n          isInKeyboardMoveMode: false\n        });\n\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.state.isInKeyboardMoveMode) {\n        var handledEvent = true;\n\n        var delta = _this._getMoveDelta(event);\n\n        switch (event.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            _this.setState({\n              x: _this._lastSetX,\n              y: _this._lastSetY\n            });\n\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n\n              /* eslint-enable no-fallthrough */\n              _this._lastSetX = 0;\n              _this._lastSetY = 0;\n\n              _this.setState({\n                isInKeyboardMoveMode: false\n              });\n\n              break;\n            }\n\n          case KeyCodes.up:\n            {\n              _this.setState({\n                y: _this._getClampedPositionY(_this.state.y - delta)\n              });\n\n              break;\n            }\n\n          case KeyCodes.down:\n            {\n              _this.setState({\n                y: _this._getClampedPositionY(_this.state.y + delta)\n              });\n\n              break;\n            }\n\n          case KeyCodes.left:\n            {\n              _this.setState({\n                x: _this._getClampedPositionX(_this.state.x - delta)\n              });\n\n              break;\n            }\n\n          case KeyCodes.right:\n            {\n              _this.setState({\n                x: _this._getClampedPositionX(_this.state.x + delta)\n              });\n\n              break;\n            }\n\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n\n        if (handledEvent) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    };\n\n    _this._onEnterKeyboardMoveMode = function () {\n      _this._lastSetX = _this.state.x;\n      _this._lastSetY = _this.state.y;\n\n      _this.setState({\n        isInKeyboardMoveMode: true,\n        isModalMenuOpen: false\n      });\n\n      _this._events.on(window, 'keydown', _this._onKeyDown, true\n      /* useCapture */\n      );\n    };\n\n    _this._onExitKeyboardMoveMode = function () {\n      _this._lastSetX = 0;\n      _this._lastSetY = 0;\n\n      _this.setState({\n        isInKeyboardMoveMode: false\n      });\n\n      _this._events.off(window, 'keydown', _this._onKeyDown, true\n      /* useCapture */\n      );\n    };\n\n    _this._registerForKeyUp = function () {\n      if (!_this._hasRegisteredKeyUp) {\n        _this._events.on(window, 'keyup', _this._onKeyUp, true\n        /* useCapture */\n        );\n\n        _this._hasRegisteredKeyUp = true;\n      }\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      onLayerDidMount: 'layerProps.onLayerDidMount'\n    });\n    _this.state = {\n      id: getId('Modal'),\n      isOpen: props.isOpen,\n      isVisible: props.isOpen,\n      hasBeenOpened: props.isOpen,\n      x: 0,\n      y: 0\n    };\n    _this._lastSetX = 0;\n    _this._lastSetY = 0;\n    var _a = _this.props.allowTouchBodyScroll,\n        allowTouchBodyScroll = _a === void 0 ? false : _a;\n    _this._allowTouchBodyScroll = allowTouchBodyScroll;\n    return _this;\n  }\n\n  ModalBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    clearTimeout(this._onModalCloseTimer); // Opening the dialog\n\n    if (newProps.isOpen) {\n      if (!this.state.isOpen) {\n        // First Open\n        this.setState({\n          isOpen: true\n        }); // Add a keyUp handler for all key up events when the dialog is open\n\n        if (newProps.dragOptions) {\n          this._registerForKeyUp();\n        }\n      } else {\n        // Modal has been opened\n        // Reopen during closing\n        this.setState({\n          hasBeenOpened: true,\n          isVisible: true\n        });\n\n        if (newProps.topOffsetFixed) {\n          var dialogMain = document.getElementsByClassName('ms-Dialog-main');\n          var modalRectangle = void 0;\n\n          if (dialogMain.length > 0) {\n            modalRectangle = dialogMain[0].getBoundingClientRect();\n            this.setState({\n              modalRectangleTop: modalRectangle.top\n            });\n          }\n        }\n      }\n    } // Closing the dialog\n\n\n    if (!newProps.isOpen && this.state.isOpen) {\n      this._onModalCloseTimer = this._async.setTimeout(this._onModalClose, parseFloat(animationDuration) * 1000);\n      this.setState({\n        isVisible: false\n      });\n    }\n  };\n\n  ModalBase.prototype.componentDidMount = function () {\n    // Not all modals show just by updating their props. Some only render when they are mounted and pass in\n    // isOpen as true. We need to add the keyUp handler in componentDidMount if we are in that case.\n    if (this.state.isOpen && this.state.isVisible) {\n      this._registerForKeyUp();\n\n      this._registerInitialModalPosition();\n    }\n  };\n\n  ModalBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _this = this;\n\n    if (!prevProps.isOpen && !prevState.isVisible) {\n      this.setState({\n        isVisible: true\n      });\n    }\n\n    if (!prevProps.isOpen && this.props.isOpen) {\n      requestAnimationFrame(function () {\n        return setTimeout(_this._registerInitialModalPosition, 0);\n      });\n    }\n  };\n\n  ModalBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  ModalBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        containerClassName = _a.containerClassName,\n        scrollableContentClassName = _a.scrollableContentClassName,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        firstFocusableSelector = _a.firstFocusableSelector,\n        forceFocusInsideTrap = _a.forceFocusInsideTrap,\n        ignoreExternalFocusing = _a.ignoreExternalFocusing,\n        isBlocking = _a.isBlocking,\n        isClickableOutsideFocusTrap = _a.isClickableOutsideFocusTrap,\n        isDarkOverlay = _a.isDarkOverlay,\n        onDismiss = _a.onDismiss,\n        layerProps = _a.layerProps,\n        overlay = _a.overlay,\n        responsiveMode = _a.responsiveMode,\n        titleAriaId = _a.titleAriaId,\n        styles = _a.styles,\n        subtitleAriaId = _a.subtitleAriaId,\n        theme = _a.theme,\n        topOffsetFixed = _a.topOffsetFixed,\n        // eslint-disable-next-line deprecation/deprecation\n    onLayerDidMount = _a.onLayerDidMount,\n        isModeless = _a.isModeless,\n        dragOptions = _a.dragOptions,\n        enableAriaHiddenSiblings = _a.enableAriaHiddenSiblings;\n    var _b = this.state,\n        isOpen = _b.isOpen,\n        isVisible = _b.isVisible,\n        hasBeenOpened = _b.hasBeenOpened,\n        modalRectangleTop = _b.modalRectangleTop,\n        x = _b.x,\n        y = _b.y,\n        isInKeyboardMoveMode = _b.isInKeyboardMoveMode;\n\n    if (!isOpen) {\n      return null;\n    }\n\n    var layerClassName = layerProps === undefined ? '' : layerProps.className;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      containerClassName: containerClassName,\n      scrollableContentClassName: scrollableContentClassName,\n      isOpen: isOpen,\n      isVisible: isVisible,\n      hasBeenOpened: hasBeenOpened,\n      modalRectangleTop: modalRectangleTop,\n      topOffsetFixed: topOffsetFixed,\n      isModeless: isModeless,\n      layerClassName: layerClassName,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n    });\n\n    var mergedLayerProps = __assign(__assign(__assign({}, DefaultLayerProps), this.props.layerProps), {\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer\n    });\n\n    var modalContent = React.createElement(FocusTrapZone, {\n      \"data-id\": this.state.id,\n      componentRef: this._focusTrapZone,\n      className: classNames.main,\n      elementToFocusOnDismiss: elementToFocusOnDismiss,\n      isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking,\n      ignoreExternalFocusing: ignoreExternalFocusing,\n      forceFocusInsideTrap: isModeless ? !isModeless : forceFocusInsideTrap,\n      firstFocusableSelector: firstFocusableSelector,\n      focusPreviouslyFocusedInnerElement: true,\n      onBlur: isInKeyboardMoveMode ? this._onExitKeyboardMoveMode : undefined,\n      enableAriaHiddenSiblings: enableAriaHiddenSiblings\n    }, dragOptions && isInKeyboardMoveMode && React.createElement(\"div\", {\n      className: classNames.keyboardMoveIconContainer\n    }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n      iconName: \"move\",\n      className: classNames.keyboardMoveIcon\n    })), React.createElement(\"div\", {\n      ref: this._allowScrollOnModal,\n      className: classNames.scrollableContent,\n      \"data-is-scrollable\": true\n    }, dragOptions && this.state.isModalMenuOpen && React.createElement(dragOptions.menu, {\n      items: [{\n        key: 'move',\n        text: dragOptions.moveMenuItemText,\n        onClick: this._onEnterKeyboardMoveMode\n      }, {\n        key: 'close',\n        text: dragOptions.closeMenuItemText,\n        onClick: this._onModalClose\n      }],\n      onDismiss: this._onModalContextMenuClose,\n      alignTargetEdge: true,\n      coverTarget: true,\n      directionalHint: DirectionalHint.topLeftEdge,\n      directionalHintFixed: true,\n      shouldFocusOnMount: true,\n      target: this._scrollableContent\n    }), this.props.children)); // @temp tuatology - Will adjust this to be a panel at certain breakpoints\n\n    if (responsiveMode >= ResponsiveMode.small) {\n      return React.createElement(Layer, __assign({}, mergedLayerProps), React.createElement(Popup, {\n        role: isModeless || !isBlocking ? 'dialog' : 'alertdialog',\n        \"aria-modal\": !isModeless,\n        ariaLabelledBy: titleAriaId,\n        ariaDescribedBy: subtitleAriaId,\n        onDismiss: onDismiss,\n        shouldRestoreFocus: !ignoreExternalFocusing\n      }, React.createElement(\"div\", {\n        className: classNames.root,\n        role: !isModeless ? 'document' : undefined\n      }, !isModeless && React.createElement(Overlay, __assign({\n        isDarkThemed: isDarkOverlay,\n        onClick: isBlocking ? undefined : onDismiss,\n        allowTouchBodyScroll: this._allowTouchBodyScroll\n      }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n        handleSelector: dragOptions.dragHandleSelector || \".\" + classNames.main.split(' ')[0],\n        preventDragSelector: \"button\",\n        onStart: this._onDragStart,\n        onDragChange: this._onDrag,\n        onStop: this._onDragStop,\n        position: {\n          x: x,\n          y: y\n        }\n      }, modalContent) : modalContent)));\n    }\n\n    return null;\n  };\n\n  ModalBase.prototype.focus = function () {\n    if (this._focusTrapZone.current) {\n      this._focusTrapZone.current.focus();\n    }\n  };\n  /**\n   * Clamps the position coordinates to the maximum/minimum value specified in props\n   */\n\n\n  ModalBase.prototype._getClampedPosition = function (position) {\n    if (!this.props.dragOptions || !this.props.dragOptions.keepInBounds) {\n      return position;\n    }\n\n    return {\n      x: this._getClampedPositionX(position.x),\n      y: this._getClampedPositionY(position.y)\n    };\n  };\n\n  ModalBase.prototype._getClampedPositionY = function (y) {\n    var minPosition = this._minClampedPosition;\n    var maxPosition = this._maxClampedPosition;\n\n    if (minPosition) {\n      y = Math.max(minPosition.y, y);\n    }\n\n    if (maxPosition) {\n      y = Math.min(maxPosition.y, y);\n    }\n\n    return y;\n  };\n\n  ModalBase.prototype._getClampedPositionX = function (x) {\n    var minPosition = this._minClampedPosition;\n    var maxPosition = this._maxClampedPosition;\n\n    if (minPosition) {\n      x = Math.max(minPosition.x, x);\n    }\n\n    if (maxPosition) {\n      x = Math.min(maxPosition.x, x);\n    }\n\n    return x;\n  };\n\n  ModalBase.prototype._getMoveDelta = function (event) {\n    var delta = 10;\n\n    if (event.shiftKey) {\n      if (!event.ctrlKey) {\n        delta = 50;\n      }\n    } else if (event.ctrlKey) {\n      delta = 1;\n    }\n\n    return delta;\n  };\n\n  ModalBase.defaultProps = {\n    isOpen: false,\n    isDarkOverlay: true,\n    isBlocking: false,\n    className: '',\n    containerClassName: ''\n  };\n  ModalBase = __decorate([withResponsiveMode], ModalBase);\n  return ModalBase;\n}(React.Component);\n\nexport { ModalBase };","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","getId","allowScrollOnElement","allowOverscrollOnElement","KeyCodes","elementContains","warnDeprecations","Async","EventGroup","FocusTrapZone","animationDuration","Overlay","Layer","Popup","withResponsiveMode","ResponsiveMode","DirectionalHint","Icon","DraggableZone","initializeComponentRef","DefaultLayerProps","eventBubblingEnabled","getClassNames","COMPONENT_NAME","__extends","props","_super","_this","createRef","dragOptions","_a","keepInBounds","_minClampedPosition","_maxClampedPosition","dialogMain","document","querySelector","state","id","modalRectangle","getBoundingClientRect","x","y","elt","_allowTouchBodyScroll","_events","off","_scrollableContent","setState","isModalMenuOpen","_lastSetX","_lastSetY","isInKeyboardMoveMode","isOpen","_hasRegisteredKeyUp","window","_onKeyUp","onDismissed","_","ui","_getClampedPosition","delta","focus","event","altKey","ctrlKey","keyCode","space","target","preventDefault","stopPropagation","escape","enter","handledEvent","_getMoveDelta","up","_getClampedPositionY","down","left","_getClampedPositionX","right","on","_onKeyDown","_async","onLayerDidMount","isVisible","hasBeenOpened","allowTouchBodyScroll","ModalBase","newProps","clearTimeout","_onModalCloseTimer","_registerForKeyUp","topOffsetFixed","getElementsByClassName","length","modalRectangleTop","top","setTimeout","_onModalClose","parseFloat","_registerInitialModalPosition","prevProps","prevState","requestAnimationFrame","dispose","className","containerClassName","scrollableContentClassName","elementToFocusOnDismiss","firstFocusableSelector","forceFocusInsideTrap","ignoreExternalFocusing","isBlocking","isClickableOutsideFocusTrap","isDarkOverlay","onDismiss","layerProps","overlay","responsiveMode","titleAriaId","styles","subtitleAriaId","theme","isModeless","enableAriaHiddenSiblings","layerClassName","undefined","classNames","isDefaultDragHandle","dragHandleSelector","mergedLayerProps","insertFirst","layer","modalContent","componentRef","_focusTrapZone","main","focusPreviouslyFocusedInnerElement","onBlur","_onExitKeyboardMoveMode","keyboardMoveIconContainer","keyboardMoveIconProps","__assign","iconName","keyboardMoveIcon","ref","_allowScrollOnModal","scrollableContent","menu","items","key","text","moveMenuItemText","onClick","_onEnterKeyboardMoveMode","closeMenuItemText","_onModalContextMenuClose","alignTargetEdge","coverTarget","directionalHint","topLeftEdge","directionalHintFixed","shouldFocusOnMount","children","small","role","ariaLabelledBy","ariaDescribedBy","shouldRestoreFocus","root","isDarkThemed","handleSelector","split","preventDragSelector","onStart","_onDragStart","onDragChange","_onDrag","onStop","_onDragStop","position","current","minPosition","maxPosition","Math","max","min","shiftKey","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\Modal\\Modal.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  getId,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  KeyCodes,\n  elementContains,\n  warnDeprecations,\n  Async,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone, IFocusTrapZone } from '../FocusTrapZone/index';\nimport { animationDuration } from './Modal.styles';\nimport { IModalProps, IModalStyleProps, IModalStyles, IModal } from './Modal.types';\nimport { Overlay } from '../../Overlay';\nimport { ILayerProps, Layer } from '../../Layer';\nimport { Popup } from '../Popup/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { DirectionalHint } from '../Callout/index';\nimport { Icon } from '../Icon/index';\nimport { DraggableZone, ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\nimport { initializeComponentRef } from '@uifabric/utilities';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\nconst DefaultLayerProps: ILayerProps = {\n  eventBubblingEnabled: false,\n};\n\nexport interface IDialogState {\n  isOpen?: boolean;\n  isVisible?: boolean;\n  isVisibleClose?: boolean;\n  id?: string;\n  hasBeenOpened?: boolean;\n  modalRectangleTop?: number;\n  isModalMenuOpen?: boolean;\n  isInKeyboardMoveMode?: boolean;\n  x: number;\n  y: number;\n}\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\nconst COMPONENT_NAME = 'Modal';\n\n@withResponsiveMode\nexport class ModalBase extends React.Component<IModalProps, IDialogState> implements IModal {\n  public static defaultProps: IModalProps = {\n    isOpen: false,\n    isDarkOverlay: true,\n    isBlocking: false,\n    className: '',\n    containerClassName: '',\n  };\n\n  private _onModalCloseTimer: number;\n  private _focusTrapZone = React.createRef<IFocusTrapZone>();\n  private _scrollableContent: HTMLDivElement | null;\n  private _lastSetX: number;\n  private _lastSetY: number;\n  private _allowTouchBodyScroll: boolean;\n  private _hasRegisteredKeyUp: boolean;\n  private _async: Async;\n  private _events: EventGroup;\n  private _minClampedPosition: ICoordinates;\n  private _maxClampedPosition: ICoordinates;\n\n  constructor(props: IModalProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      onLayerDidMount: 'layerProps.onLayerDidMount',\n    });\n\n    this.state = {\n      id: getId('Modal'),\n      isOpen: props.isOpen,\n      isVisible: props.isOpen,\n      hasBeenOpened: props.isOpen,\n      x: 0,\n      y: 0,\n    };\n\n    this._lastSetX = 0;\n    this._lastSetY = 0;\n\n    const { allowTouchBodyScroll = false } = this.props;\n    this._allowTouchBodyScroll = allowTouchBodyScroll;\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: IModalProps): void {\n    clearTimeout(this._onModalCloseTimer);\n\n    // Opening the dialog\n    if (newProps.isOpen) {\n      if (!this.state.isOpen) {\n        // First Open\n        this.setState({\n          isOpen: true,\n        });\n        // Add a keyUp handler for all key up events when the dialog is open\n        if (newProps.dragOptions) {\n          this._registerForKeyUp();\n        }\n      } else {\n        // Modal has been opened\n        // Reopen during closing\n        this.setState({\n          hasBeenOpened: true,\n          isVisible: true,\n        });\n\n        if (newProps.topOffsetFixed) {\n          const dialogMain = document.getElementsByClassName('ms-Dialog-main');\n          let modalRectangle;\n          if (dialogMain.length > 0) {\n            modalRectangle = dialogMain[0].getBoundingClientRect();\n            this.setState({\n              modalRectangleTop: modalRectangle.top,\n            });\n          }\n        }\n      }\n    }\n\n    // Closing the dialog\n    if (!newProps.isOpen && this.state.isOpen) {\n      this._onModalCloseTimer = this._async.setTimeout(this._onModalClose, parseFloat(animationDuration) * 1000);\n      this.setState({\n        isVisible: false,\n      });\n    }\n  }\n\n  public componentDidMount() {\n    // Not all modals show just by updating their props. Some only render when they are mounted and pass in\n    // isOpen as true. We need to add the keyUp handler in componentDidMount if we are in that case.\n    if (this.state.isOpen && this.state.isVisible) {\n      this._registerForKeyUp();\n      this._registerInitialModalPosition();\n    }\n  }\n\n  public componentDidUpdate(prevProps: IModalProps, prevState: IDialogState) {\n    if (!prevProps.isOpen && !prevState.isVisible) {\n      this.setState({\n        isVisible: true,\n      });\n    }\n    if (!prevProps.isOpen && this.props.isOpen) {\n      requestAnimationFrame(() => setTimeout(this._registerInitialModalPosition, 0));\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    const {\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      forceFocusInsideTrap,\n      ignoreExternalFocusing,\n      isBlocking,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      responsiveMode,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      enableAriaHiddenSiblings,\n    } = this.props;\n    const { isOpen, isVisible, hasBeenOpened, modalRectangleTop, x, y, isInKeyboardMoveMode } = this.state;\n\n    if (!isOpen) {\n      return null;\n    }\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps = {\n      ...DefaultLayerProps,\n      ...this.props.layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer,\n    };\n    const modalContent = (\n      <FocusTrapZone\n        data-id={this.state.id}\n        componentRef={this._focusTrapZone}\n        className={classNames.main}\n        elementToFocusOnDismiss={elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={isModeless || isClickableOutsideFocusTrap || !isBlocking}\n        ignoreExternalFocusing={ignoreExternalFocusing}\n        forceFocusInsideTrap={isModeless ? !isModeless : forceFocusInsideTrap}\n        firstFocusableSelector={firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement={true}\n        onBlur={isInKeyboardMoveMode ? this._onExitKeyboardMoveMode : undefined}\n        enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n      >\n        {dragOptions && isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={this._allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable={true}>\n          {dragOptions && this.state.isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: this._onEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: this._onModalClose },\n              ]}\n              onDismiss={this._onModalContextMenuClose}\n              alignTargetEdge={true}\n              coverTarget={true}\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed={true}\n              shouldFocusOnMount={true}\n              target={this._scrollableContent}\n            />\n          )}\n          {this.props.children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    // @temp tuatology - Will adjust this to be a panel at certain breakpoints\n    if (responsiveMode! >= ResponsiveMode.small) {\n      return (\n        <Layer {...mergedLayerProps}>\n          <Popup\n            role={isModeless || !isBlocking ? 'dialog' : 'alertdialog'}\n            aria-modal={!isModeless}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!ignoreExternalFocusing}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : (onDismiss as any)}\n                  allowTouchBodyScroll={this._allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `.${classNames.main.split(' ')[0]}`}\n                  preventDragSelector=\"button\"\n                  onStart={this._onDragStart}\n                  onDragChange={this._onDrag}\n                  onStop={this._onDragStop}\n                  position={{ x: x, y: y }}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      );\n    }\n    return null;\n  }\n\n  public focus() {\n    if (this._focusTrapZone.current) {\n      this._focusTrapZone.current.focus();\n    }\n  }\n\n  private _registerInitialModalPosition = (): void => {\n    if (this.props.dragOptions?.keepInBounds && !this._minClampedPosition && !this._maxClampedPosition) {\n      const dialogMain = document.querySelector(`[data-id=${this.state.id}]`);\n      if (dialogMain) {\n        const modalRectangle = dialogMain.getBoundingClientRect();\n        this._minClampedPosition = { x: -modalRectangle.x, y: -modalRectangle.y };\n        this._maxClampedPosition = { x: modalRectangle.x, y: modalRectangle.y };\n      }\n    }\n  };\n\n  /**\n   * Clamps the position coordinates to the maximum/minimum value specified in props\n   */\n  private _getClampedPosition(position: ICoordinates) {\n    if (!this.props.dragOptions || !this.props.dragOptions.keepInBounds) {\n      return position;\n    }\n    return { x: this._getClampedPositionX(position.x), y: this._getClampedPositionY(position.y) };\n  }\n\n  private _getClampedPositionY(y: number) {\n    const minPosition = this._minClampedPosition;\n    const maxPosition = this._maxClampedPosition;\n    if (minPosition) {\n      y = Math.max(minPosition.y, y);\n    }\n    if (maxPosition) {\n      y = Math.min(maxPosition.y, y);\n    }\n    return y;\n  }\n\n  private _getClampedPositionX(x: number) {\n    const minPosition = this._minClampedPosition;\n    const maxPosition = this._maxClampedPosition;\n    if (minPosition) {\n      x = Math.max(minPosition.x, x);\n    }\n    if (maxPosition) {\n      x = Math.min(maxPosition.x, x);\n    }\n    return x;\n  }\n\n  // Allow the user to scroll within the modal but not on the body\n  private _allowScrollOnModal = (elt: HTMLDivElement | null): void => {\n    if (elt) {\n      if (this._allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, this._events);\n      } else {\n        allowScrollOnElement(elt, this._events);\n      }\n    } else {\n      this._events.off(this._scrollableContent);\n    }\n    this._scrollableContent = elt;\n  };\n\n  private _onModalContextMenuClose = (): void => {\n    this.setState({ isModalMenuOpen: false });\n  };\n\n  private _onModalClose = (): void => {\n    this._lastSetX = 0;\n    this._lastSetY = 0;\n\n    this.setState({\n      isModalMenuOpen: false,\n      isInKeyboardMoveMode: false,\n      isOpen: false,\n      x: 0,\n      y: 0,\n    });\n\n    if (this.props.dragOptions && this._hasRegisteredKeyUp) {\n      this._events.off(window, 'keyup', this._onKeyUp, true /* useCapture */);\n    }\n\n    // Call the onDismiss callback\n    if (this.props.onDismissed) {\n      this.props.onDismissed();\n    }\n  };\n\n  private _onDragStart = (): void => {\n    this.setState({ isModalMenuOpen: false, isInKeyboardMoveMode: false });\n  };\n\n  private _onDrag = (_: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, ui: IDragData): void => {\n    const { x, y } = this.state;\n    this.setState(this._getClampedPosition({ x: x + ui.delta.x, y: y + ui.delta.y }));\n  };\n\n  private _onDragStop = (): void => {\n    this.focus();\n  };\n\n  private _onKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    // Need to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n    // Otherwise it would continue to fire a click even if the event was cancelled\n    // during mouseDown.\n    if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n      // Since this is a global handler, we should make sure the target is within the dialog\n      // before opening the dropdown\n      if (elementContains(this._scrollableContent, event.target as HTMLElement)) {\n        this.setState({ isModalMenuOpen: !this.state.isModalMenuOpen });\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  };\n\n  // We need a global onKeyDown event when we are in the move mode so that we can\n  // handle the key presses and the components inside the modal do not get the events\n  private _onKeyDown = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n      // CTRL + ALT + SPACE is handled during keyUp\n      event.preventDefault();\n      event.stopPropagation();\n      return;\n    }\n\n    if (this.state.isModalMenuOpen && (event.altKey || event.keyCode === KeyCodes.escape)) {\n      this.setState({ isModalMenuOpen: false });\n    }\n\n    if (this.state.isInKeyboardMoveMode && (event.keyCode === KeyCodes.escape || event.keyCode === KeyCodes.enter)) {\n      this.setState({ isInKeyboardMoveMode: false });\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.state.isInKeyboardMoveMode) {\n      let handledEvent = true;\n      const delta = this._getMoveDelta(event);\n\n      switch (event.keyCode) {\n        /* eslint-disable no-fallthrough */\n        case KeyCodes.escape:\n          this.setState({ x: this._lastSetX, y: this._lastSetY });\n        case KeyCodes.enter: {\n          // TODO: determine if fallthrough was intentional\n          /* eslint-enable no-fallthrough */\n          this._lastSetX = 0;\n          this._lastSetY = 0;\n          this.setState({ isInKeyboardMoveMode: false });\n          break;\n        }\n        case KeyCodes.up: {\n          this.setState({\n            y: this._getClampedPositionY(this.state.y - delta),\n          });\n          break;\n        }\n        case KeyCodes.down: {\n          this.setState({\n            y: this._getClampedPositionY(this.state.y + delta),\n          });\n          break;\n        }\n        case KeyCodes.left: {\n          this.setState({\n            x: this._getClampedPositionX(this.state.x - delta),\n          });\n          break;\n        }\n        case KeyCodes.right: {\n          this.setState({\n            x: this._getClampedPositionX(this.state.x + delta),\n          });\n          break;\n        }\n        default: {\n          handledEvent = false;\n        }\n      }\n\n      if (handledEvent) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  };\n\n  private _getMoveDelta(event: React.KeyboardEvent<HTMLElement>): number {\n    let delta = 10;\n    if (event.shiftKey) {\n      if (!event.ctrlKey) {\n        delta = 50;\n      }\n    } else if (event.ctrlKey) {\n      delta = 1;\n    }\n\n    return delta;\n  }\n\n  private _onEnterKeyboardMoveMode = () => {\n    this._lastSetX = this.state.x;\n    this._lastSetY = this.state.y;\n    this.setState({ isInKeyboardMoveMode: true, isModalMenuOpen: false });\n    this._events.on(window, 'keydown', this._onKeyDown, true /* useCapture */);\n  };\n\n  private _onExitKeyboardMoveMode = () => {\n    this._lastSetX = 0;\n    this._lastSetY = 0;\n    this.setState({ isInKeyboardMoveMode: false });\n    this._events.off(window, 'keydown', this._onKeyDown, true /* useCapture */);\n  };\n\n  private _registerForKeyUp = (): void => {\n    if (!this._hasRegisteredKeyUp) {\n      this._events.on(window, 'keyup', this._onKeyUp, true /* useCapture */);\n      this._hasRegisteredKeyUp = true;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}