{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { find, values } from '../../Utilities';\nimport { mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\n\nvar KeytipTree =\n/** @class */\nfunction () {\n  /**\n   * KeytipTree constructor\n   */\n  function KeytipTree() {\n    this.nodeMap = {}; // Root has no keytipSequence\n\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: []\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n\n\n  KeytipTree.prototype.addNode = function (keytipProps, uniqueID, persisted) {\n    var fullSequence = this._getFullSequence(keytipProps);\n\n    var nodeID = sequencesToID(fullSequence); // Take off the last item to calculate the parent sequence\n\n    fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n    var parentID = this._getParentID(fullSequence); // Create node and add to map\n\n\n    var node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n\n    this.nodeMap[uniqueID] = node; // Try to add self to parents children, if they exist\n\n    var parent = this.getNode(parentID);\n\n    if (parent) {\n      parent.children.push(nodeID);\n    }\n  };\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n\n\n  KeytipTree.prototype.updateNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n\n    var nodeID = sequencesToID(fullSequence); // Take off the last item to calculate the parent sequence\n\n    fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n    var parentID = this._getParentID(fullSequence);\n\n    var node = this.nodeMap[uniqueID];\n    var prevParent = node.parent;\n    var prevParentNode = this.getNode(prevParent);\n    var parent = this.getNode(parentID);\n\n    if (node) {\n      if (prevParentNode && prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        var childIndex = prevParentNode.children.indexOf(node.id);\n\n        if (childIndex >= 0) {\n          prevParentNode.children.splice(childIndex, 1);\n        }\n      } // If the ID of the node has changed, update node's parent's array of children with new ID\n\n\n      if (parent && node.id !== nodeID) {\n        var index = parent.children.indexOf(node.id);\n\n        if (index >= 0) {\n          parent.children[index] = nodeID;\n        } else {\n          parent.children.push(nodeID);\n        }\n      } // Update values\n\n\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  };\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n\n\n  KeytipTree.prototype.removeNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n\n    var nodeID = sequencesToID(fullSequence); // Take off the last sequence to calculate the parent ID\n\n    fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n    var parentID = this._getParentID(fullSequence);\n\n    var parent = this.getNode(parentID);\n\n    if (parent) {\n      // Remove node from its parent's children\n      parent.children.splice(parent.children.indexOf(nodeID), 1);\n    }\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  };\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n\n\n  KeytipTree.prototype.getExactMatchedNode = function (keySequence, currentKeytip) {\n    var _this = this;\n\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    return find(possibleNodes, function (node) {\n      return _this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n  };\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n\n\n  KeytipTree.prototype.getPartiallyMatchedNodes = function (keySequence, currentKeytip) {\n    var _this = this; // Get children that are persisted\n\n\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter(function (node) {\n      return _this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  };\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n\n\n  KeytipTree.prototype.getChildren = function (node) {\n    var _this = this;\n\n    if (!node) {\n      node = this.currentKeytip;\n\n      if (!node) {\n        return [];\n      }\n    }\n\n    var children = node.children;\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (children.indexOf(_this.nodeMap[key].id) >= 0 && !_this.nodeMap[key].persisted) {\n        nodes.push(_this.nodeMap[key].id);\n      }\n\n      return nodes;\n    }, []);\n  };\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n\n\n  KeytipTree.prototype.getNodes = function (ids) {\n    var _this = this;\n\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (ids.indexOf(_this.nodeMap[key].id) >= 0) {\n        nodes.push(_this.nodeMap[key]);\n      }\n\n      return nodes;\n    }, []);\n  };\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n\n\n  KeytipTree.prototype.getNode = function (id) {\n    var nodeMapValues = values(this.nodeMap);\n    return find(nodeMapValues, function (node) {\n      return node.id === id;\n    });\n  };\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n\n\n  KeytipTree.prototype.isCurrentKeytipParent = function (keytipProps) {\n    if (this.currentKeytip) {\n      var fullSequence = __spreadArrays(keytipProps.keySequences);\n\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      } // Take off the last sequence to calculate the parent ID\n\n\n      fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n      var parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      var matchesCurrWithoutOverflow = false;\n\n      if (this.currentKeytip.overflowSetSequence) {\n        var currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n\n    return false;\n  };\n\n  KeytipTree.prototype._getParentID = function (fullSequence) {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  };\n\n  KeytipTree.prototype._getFullSequence = function (keytipProps) {\n    var fullSequence = __spreadArrays(keytipProps.keySequences);\n\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n\n    return fullSequence;\n  };\n\n  KeytipTree.prototype._getNodeSequence = function (node) {\n    var fullSequence = __spreadArrays(node.keySequences);\n\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n\n    return fullSequence[fullSequence.length - 1];\n  };\n\n  KeytipTree.prototype._createNode = function (id, parentId, children, keytipProps, persisted) {\n    var _this = this;\n\n    var keySequences = keytipProps.keySequences,\n        hasDynamicChildren = keytipProps.hasDynamicChildren,\n        overflowSetSequence = keytipProps.overflowSetSequence,\n        hasMenu = keytipProps.hasMenu,\n        onExecute = keytipProps.onExecute,\n        onReturn = keytipProps.onReturn,\n        disabled = keytipProps.disabled;\n    var node = {\n      id: id,\n      keySequences: keySequences,\n      overflowSetSequence: overflowSetSequence,\n      parent: parentId,\n      children: children,\n      onExecute: onExecute,\n      onReturn: onReturn,\n      hasDynamicChildren: hasDynamicChildren,\n      hasMenu: hasMenu,\n      disabled: disabled,\n      persisted: persisted\n    };\n    node.children = Object.keys(this.nodeMap).reduce(function (array, nodeMapKey) {\n      if (_this.nodeMap[nodeMapKey].parent === id) {\n        array.push(_this.nodeMap[nodeMapKey].id);\n      }\n\n      return array;\n    }, []);\n    return node;\n  };\n\n  return KeytipTree;\n}();\n\nexport { KeytipTree };","map":{"version":3,"mappings":"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","names":["find","values","mergeOverflows","sequencesToID","KTP_LAYER_ID","root","id","children","parent","keySequences","nodeMap","KeytipTree","keytipProps","uniqueID","persisted","fullSequence","_getFullSequence","nodeID","pop","parentID","_getParentID","node","_createNode","getNode","push","prevParent","prevParentNode","childIndex","indexOf","splice","index","overflowSetSequence","onExecute","onReturn","hasDynamicChildren","hasMenu","disabled","keySequence","currentKeytip","possibleNodes","getNodes","_this","_getNodeSequence","filter","Object","keys","reduce","nodes","key","ids","nodeMapValues","length","matchesCurrWithoutOverflow","currKeytipIdWithoutOverflow","parentId","array","nodeMapKey"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\KeytipLayer\\KeytipTree.ts"],"sourcesContent":["import { find, values } from '../../Utilities';\nimport { IKeytipProps } from '../../Keytip';\nimport { IKeytipTreeNode } from './IKeytipTreeNode';\nimport { mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\n\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nexport class KeytipTree {\n  public currentKeytip?: IKeytipTreeNode;\n  public root: IKeytipTreeNode;\n  public nodeMap: { [nodeId: string]: IKeytipTreeNode } = {};\n\n  /**\n   * KeytipTree constructor\n   */\n  constructor() {\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: [],\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  public addNode(keytipProps: IKeytipProps, uniqueID: string, persisted?: boolean): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n\n    // Create node and add to map\n    const node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n\n    // Try to add self to parents children, if they exist\n    const parent = this.getNode(parentID);\n    if (parent) {\n      parent.children.push(nodeID);\n    }\n  }\n\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  public updateNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const node = this.nodeMap[uniqueID];\n    const prevParent = node.parent;\n    const prevParentNode = this.getNode(prevParent);\n    const parent = this.getNode(parentID);\n    if (node) {\n      if (prevParentNode && prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        const childIndex = prevParentNode.children.indexOf(node.id);\n        if (childIndex >= 0) {\n          prevParentNode.children.splice(childIndex, 1);\n        }\n      }\n      // If the ID of the node has changed, update node's parent's array of children with new ID\n      if (parent && node.id !== nodeID) {\n        const index = parent.children.indexOf(node.id);\n        if (index >= 0) {\n          parent.children[index] = nodeID;\n        } else {\n          parent.children.push(nodeID);\n        }\n      }\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  }\n\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  public removeNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const parent = this.getNode(parentID);\n    if (parent) {\n      // Remove node from its parent's children\n      parent.children.splice(parent.children.indexOf(nodeID), 1);\n    }\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  }\n\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  public getExactMatchedNode(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode | undefined {\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return find(possibleNodes, (node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n  }\n\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  public getPartiallyMatchedNodes(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode[] {\n    // Get children that are persisted\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  }\n\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  public getChildren(node?: IKeytipTreeNode): string[] {\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    const children = node.children;\n    return Object.keys(this.nodeMap).reduce((nodes: string[], key: string): string[] => {\n      if (children.indexOf(this.nodeMap[key].id) >= 0 && !this.nodeMap[key].persisted) {\n        nodes.push(this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  public getNodes(ids: string[]): IKeytipTreeNode[] {\n    return Object.keys(this.nodeMap).reduce((nodes: IKeytipTreeNode[], key: string): IKeytipTreeNode[] => {\n      if (ids.indexOf(this.nodeMap[key].id) >= 0) {\n        nodes.push(this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  public getNode(id: string): IKeytipTreeNode | undefined {\n    const nodeMapValues = values<IKeytipTreeNode>(this.nodeMap);\n    return find(nodeMapValues, (node: IKeytipTreeNode): boolean => {\n      return node.id === id;\n    });\n  }\n\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  public isCurrentKeytipParent(keytipProps: IKeytipProps): boolean {\n    if (this.currentKeytip) {\n      let fullSequence = [...keytipProps.keySequences];\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      const parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      let matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        const currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  }\n\n  private _getParentID(fullSequence: string[]): string {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  }\n\n  private _getFullSequence(keytipProps: IKeytipProps): string[] {\n    let fullSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  }\n\n  private _getNodeSequence(node: IKeytipTreeNode): string {\n    let fullSequence = [...node.keySequences];\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  }\n\n  private _createNode(\n    id: string,\n    parentId: string,\n    children: string[],\n    keytipProps: IKeytipProps,\n    persisted?: boolean,\n  ): IKeytipTreeNode {\n    const {\n      keySequences,\n      hasDynamicChildren,\n      overflowSetSequence,\n      hasMenu,\n      onExecute,\n      onReturn,\n      disabled,\n    } = keytipProps;\n    const node = {\n      id,\n      keySequences,\n      overflowSetSequence,\n      parent: parentId,\n      children,\n      onExecute,\n      onReturn,\n      hasDynamicChildren,\n      hasMenu,\n      disabled,\n      persisted,\n    };\n    node.children = Object.keys(this.nodeMap).reduce((array: string[], nodeMapKey: string): string[] => {\n      if (this.nodeMap[nodeMapKey].parent === id) {\n        array.push(this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}