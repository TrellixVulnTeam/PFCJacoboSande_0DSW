{"ast":null,"code":"var _a;\n\nimport { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Async, css, divProperties, elementContains, focusFirstChild, getDocument, getNativeProps, getWindow, on, shallowCompare } from '../../Utilities';\nimport { positionCallout, getMaxHeight, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../utilities/positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nvar ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);\nvar getClassNames = classNamesFunction({\n  disableCaching: true\n});\nvar BEAK_ORIGIN_POSITION = {\n  top: 0,\n  left: 0\n}; // Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\n\nvar OFF_SCREEN_STYLE = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none'\n}; // role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\n\nvar ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nvar CalloutContentBase =\n/** @class */\nfunction (_super) {\n  __extends(CalloutContentBase, _super);\n\n  function CalloutContentBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._hostElement = React.createRef();\n    _this._calloutElement = React.createRef();\n    _this._hasListeners = false;\n    _this._disposables = [];\n\n    _this.dismiss = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev);\n      }\n    };\n\n    _this._dismissOnScroll = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n          preventDismissOnEvent = _a.preventDismissOnEvent,\n          preventDismissOnScroll = _a.preventDismissOnScroll;\n\n      if (_this.state.positions && (preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnScroll)) {\n        _this._dismissOnClickOrScroll(ev);\n      }\n    };\n\n    _this._dismissOnResize = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n          preventDismissOnEvent = _a.preventDismissOnEvent,\n          preventDismissOnResize = _a.preventDismissOnResize;\n\n      if (preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnResize) {\n        _this.dismiss(ev);\n      }\n    };\n\n    _this._dismissOnLostFocus = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n          preventDismissOnEvent = _a.preventDismissOnEvent,\n          preventDismissOnLostFocus = _a.preventDismissOnLostFocus;\n\n      if (preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) {\n        _this._dismissOnClickOrScroll(ev);\n      }\n    };\n\n    _this._setInitialFocus = function () {\n      if (_this.props.setInitialFocus && !_this._didSetInitialFocus && _this.state.positions && _this._calloutElement.current) {\n        _this._didSetInitialFocus = true;\n\n        _this._async.requestAnimationFrame(function () {\n          return focusFirstChild(_this._calloutElement.current);\n        }, _this._calloutElement.current);\n      }\n    };\n\n    _this._onComponentDidMount = function () {\n      _this._addListeners();\n\n      if (_this.props.onLayerMounted) {\n        _this.props.onLayerMounted();\n      }\n\n      _this._updateAsyncPosition();\n\n      _this._setHeightOffsetEveryFrame();\n    };\n\n    _this._dismissOnTargetWindowBlur = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n          preventDismissOnEvent = _a.preventDismissOnEvent,\n          preventDismissOnLostFocus = _a.preventDismissOnLostFocus,\n          shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus; // Do nothing\n\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !_this._targetWindow.document.hasFocus() && ev.relatedTarget === null) {\n        _this.dismiss(ev);\n      }\n    };\n\n    _this._mouseDownOnPopup = function () {\n      _this._isMouseDownOnPopup = true;\n    };\n\n    _this._mouseUpOnPopup = function () {\n      _this._isMouseDownOnPopup = false;\n    };\n\n    _this._async = new Async(_this);\n    _this._didSetInitialFocus = false;\n    _this.state = {\n      positions: undefined,\n      slideDirectionalClassName: undefined,\n      // @TODO it looks like this is not even being used anymore.\n      calloutElementRect: undefined,\n      heightOffset: 0\n    };\n    _this._positionAttempts = 0;\n    return _this;\n  }\n\n  CalloutContentBase.prototype.componentDidUpdate = function () {\n    if (!this.props.hidden) {\n      this._setInitialFocus();\n\n      if (!this._hasListeners) {\n        this._addListeners();\n      }\n\n      this._updateAsyncPosition();\n    } else {\n      if (this._hasListeners) {\n        this._removeListeners();\n      }\n    }\n  };\n\n  CalloutContentBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  };\n\n  CalloutContentBase.prototype.UNSAFE_componentWillMount = function () {\n    this._setTargetWindowAndElement(this._getTarget());\n  };\n\n  CalloutContentBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n\n  CalloutContentBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    // If the target element changed, find the new one. If we are tracking target with class name, always find element\n    // because we do not know if fabric has rendered a new element and disposed the old element.\n    var newTarget = this._getTarget(newProps);\n\n    var oldTarget = this._getTarget();\n\n    if ((newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) && !this._blockResetHeight) {\n      this._maxHeight = undefined;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (newProps.gapSpace !== this.props.gapSpace || this.props.beakWidth !== newProps.beakWidth) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    } // Ensure positioning is recalculated when we are about to show a persisted menu.\n\n\n    if (this._didPositionPropsChange(newProps, this.props)) {\n      this._maxHeight = undefined; // Target might have been updated while hidden.\n\n      this._setTargetWindowAndElement(newTarget);\n\n      this.setState({\n        positions: undefined\n      });\n      this._didSetInitialFocus = false;\n      this._bounds = undefined;\n    }\n\n    this._blockResetHeight = false;\n  };\n\n  CalloutContentBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onComponentDidMount();\n    }\n  };\n\n  CalloutContentBase.prototype.render = function () {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    var target = this.props.target;\n    var _a = this.props,\n        styles = _a.styles,\n        style = _a.style,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        ariaLabelledBy = _a.ariaLabelledBy,\n        className = _a.className,\n        isBeakVisible = _a.isBeakVisible,\n        children = _a.children,\n        beakWidth = _a.beakWidth,\n        calloutWidth = _a.calloutWidth,\n        calloutMaxWidth = _a.calloutMaxWidth,\n        finalHeight = _a.finalHeight,\n        _b = _a.hideOverflow,\n        hideOverflow = _b === void 0 ? !!finalHeight : _b,\n        backgroundColor = _a.backgroundColor,\n        calloutMaxHeight = _a.calloutMaxHeight,\n        onScroll = _a.onScroll,\n        // eslint-disable-next-line deprecation/deprecation\n    _c = _a.shouldRestoreFocus,\n        // eslint-disable-next-line deprecation/deprecation\n    shouldRestoreFocus = _c === void 0 ? true : _c;\n    target = this._getTarget();\n    var positions = this.state.positions;\n    var getContentMaxHeight = this._getMaxHeight() ? this._getMaxHeight() + this.state.heightOffset : undefined;\n    var contentMaxHeight = calloutMaxHeight && getContentMaxHeight && calloutMaxHeight < getContentMaxHeight ? calloutMaxHeight : getContentMaxHeight;\n    var overflowYHidden = hideOverflow;\n    var beakVisible = isBeakVisible && !!target;\n    this._classNames = getClassNames(styles, {\n      theme: this.props.theme,\n      className: className,\n      overflowYHidden: overflowYHidden,\n      calloutWidth: calloutWidth,\n      positions: positions,\n      beakWidth: beakWidth,\n      backgroundColor: backgroundColor,\n      calloutMaxWidth: calloutMaxWidth\n    });\n\n    var overflowStyle = __assign(__assign(__assign({}, style), {\n      maxHeight: contentMaxHeight\n    }), overflowYHidden && {\n      overflowY: 'hidden'\n    });\n\n    var visibilityStyle = this.props.hidden ? {\n      visibility: 'hidden'\n    } : undefined; // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n\n    var content = React.createElement(\"div\", {\n      ref: this._hostElement,\n      className: this._classNames.container,\n      style: visibilityStyle\n    }, React.createElement(\"div\", __assign({}, getNativeProps(this.props, divProperties, ARIA_ROLE_ATTRIBUTES), {\n      className: css(this._classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),\n      style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n      // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n      tabIndex: -1,\n      ref: this._calloutElement\n    }), beakVisible && React.createElement(\"div\", {\n      className: this._classNames.beak,\n      style: this._getBeakPosition()\n    }), beakVisible && React.createElement(\"div\", {\n      className: this._classNames.beakCurtain\n    }), React.createElement(Popup, __assign({}, getNativeProps(this.props, ARIA_ROLE_ATTRIBUTES), {\n      ariaLabel: ariaLabel,\n      onRestoreFocus: this.props.onRestoreFocus,\n      ariaDescribedBy: ariaDescribedBy,\n      ariaLabelledBy: ariaLabelledBy,\n      className: this._classNames.calloutMain,\n      onDismiss: this.dismiss,\n      onScroll: onScroll,\n      shouldRestoreFocus: shouldRestoreFocus,\n      style: overflowStyle,\n      onMouseDown: this._mouseDownOnPopup,\n      onMouseUp: this._mouseUpOnPopup\n    }), children)));\n    return content;\n  };\n\n  CalloutContentBase.prototype._dismissOnClickOrScroll = function (ev) {\n    var target = ev.target;\n    var isEventTargetOutsideCallout = this._hostElement.current && !elementContains(this._hostElement.current, target); // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n\n    if (isEventTargetOutsideCallout && this._isMouseDownOnPopup) {\n      this._isMouseDownOnPopup = false;\n      return;\n    }\n\n    if (!this._target && isEventTargetOutsideCallout || ev.target !== this._targetWindow && isEventTargetOutsideCallout && (this._target.stopPropagation || !this._target || this.props.dismissOnTargetClick || target !== this._target && !elementContains(this._target, target))) {\n      this.dismiss(ev);\n    }\n  };\n\n  CalloutContentBase.prototype._addListeners = function () {\n    var _this = this; // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n\n\n    this._async.setTimeout(function () {\n      _this._disposables.push(on(_this._targetWindow, 'scroll', _this._dismissOnScroll, true), on(_this._targetWindow, 'resize', _this._dismissOnResize, true), on(_this._targetWindow.document.documentElement, 'focus', _this._dismissOnLostFocus, true), on(_this._targetWindow.document.documentElement, 'click', _this._dismissOnLostFocus, true), on(_this._targetWindow, 'blur', _this._dismissOnTargetWindowBlur, true));\n\n      _this._hasListeners = true;\n    }, 0);\n  };\n\n  CalloutContentBase.prototype._removeListeners = function () {\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    });\n\n    this._disposables = [];\n    this._hasListeners = false;\n  };\n\n  CalloutContentBase.prototype._updateAsyncPosition = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      return _this._updatePosition();\n    }, this._calloutElement.current);\n  };\n\n  CalloutContentBase.prototype._getBeakPosition = function () {\n    var positions = this.state.positions;\n\n    var beakPostionStyle = __assign({}, positions && positions.beakPosition ? positions.beakPosition.elementPosition : null);\n\n    if (!beakPostionStyle.top && !beakPostionStyle.bottom && !beakPostionStyle.left && !beakPostionStyle.right) {\n      beakPostionStyle.left = BEAK_ORIGIN_POSITION.left;\n      beakPostionStyle.top = BEAK_ORIGIN_POSITION.top;\n    }\n\n    return beakPostionStyle;\n  };\n\n  CalloutContentBase.prototype._updatePosition = function () {\n    // Try to update the target, page might have changed\n    this._setTargetWindowAndElement(this._getTarget());\n\n    var positions = this.state.positions;\n    var hostElement = this._hostElement.current;\n    var calloutElement = this._calloutElement.current; // If we expect a target element to position against, we need to wait until `this._target` is resolved. Otherwise\n    // we can try to position.\n\n    var expectsTarget = !!this.props.target;\n\n    if (hostElement && calloutElement && (!expectsTarget || this._target)) {\n      var currentProps = __assign({}, this.props);\n\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target; // If there is a finalHeight given then we assume that the user knows and will handle\n      // additional positioning adjustments so we should call positionCard\n\n      var newPositions = this.props.finalHeight ? positionCard(currentProps, hostElement, calloutElement, positions) : positionCallout(currentProps, hostElement, calloutElement, positions); // Set the new position only when the positions are not exists or one of the new callout positions are different.\n      // The position should not change if the position is within 2 decimal places.\n\n      if (!positions && newPositions || positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5) {\n        // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n        // and we should stop trying to reposition to prevent a stack overflow.\n        this._positionAttempts++;\n        this.setState({\n          positions: newPositions\n        });\n      } else if (this._positionAttempts > 0) {\n        // Only call the onPositioned callback if the callout has been re-positioned at least once.\n        this._positionAttempts = 0;\n\n        if (this.props.onPositioned) {\n          this.props.onPositioned(this.state.positions);\n        }\n      }\n    }\n  };\n\n  CalloutContentBase.prototype._getBounds = function () {\n    if (!this._bounds) {\n      var bounds = this.props.bounds;\n      var currentBounds = typeof bounds === 'function' ? bounds(this.props.target, this._targetWindow) : bounds;\n\n      if (!currentBounds) {\n        currentBounds = getBoundsFromTargetWindow(this._target, this._targetWindow);\n        currentBounds = {\n          top: currentBounds.top + this.props.minPagePadding,\n          left: currentBounds.left + this.props.minPagePadding,\n          right: currentBounds.right - this.props.minPagePadding,\n          bottom: currentBounds.bottom - this.props.minPagePadding,\n          width: currentBounds.width - this.props.minPagePadding * 2,\n          height: currentBounds.height - this.props.minPagePadding * 2\n        };\n      }\n\n      this._bounds = currentBounds;\n    }\n\n    return this._bounds;\n  }; // Max height should remain as synchronous as possible, which is why it is not done using set state.\n  // It needs to be synchronous since it will impact the ultimate position of the callout.\n\n\n  CalloutContentBase.prototype._getMaxHeight = function () {\n    var _this = this;\n\n    if (!this._maxHeight) {\n      if (this.props.directionalHintFixed && this._target) {\n        var beakWidth = this.props.isBeakVisible ? this.props.beakWidth : 0;\n        var gapSpace = this.props.gapSpace ? this.props.gapSpace : 0; // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will\n        // overlap with the target.\n\n        var totalGap_1 = gapSpace + beakWidth;\n\n        this._async.requestAnimationFrame(function () {\n          if (_this._target) {\n            _this._maxHeight = getMaxHeight(_this._target, _this.props.directionalHint, totalGap_1, _this._getBounds(), _this.props.coverTarget);\n            _this._blockResetHeight = true;\n\n            _this.forceUpdate();\n          }\n        }, this._target);\n      } else {\n        this._maxHeight = this._getBounds().height;\n      }\n    }\n\n    return this._maxHeight;\n  };\n\n  CalloutContentBase.prototype._arePositionsEqual = function (positions, newPosition) {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition) && this._comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition);\n  };\n\n  CalloutContentBase.prototype._comparePositions = function (oldPositions, newPositions) {\n    for (var key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        var oldPositionEdge = oldPositions[key];\n        var newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  CalloutContentBase.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._calloutElement.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement); // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target; // Same reason here\n      } else if (target.getBoundingClientRect) {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = targetElement;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target); // HTMLImgElements can have x and y values. The check for it being a point must go last.\n      } else {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  };\n\n  CalloutContentBase.prototype._setHeightOffsetEveryFrame = function () {\n    var _this = this;\n\n    if (this._calloutElement.current && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {\n        var calloutMainElem = _this._calloutElement.current && _this._calloutElement.current.lastChild;\n\n        if (!calloutMainElem) {\n          return;\n        }\n\n        var cardScrollHeight = calloutMainElem.scrollHeight;\n        var cardCurrHeight = calloutMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n\n        _this.setState({\n          heightOffset: _this.state.heightOffset + scrollDiff\n        });\n\n        if (calloutMainElem.offsetHeight < _this.props.finalHeight) {\n          _this._setHeightOffsetEveryFrame();\n        } else {\n          _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer, _this._calloutElement.current);\n        }\n      }, this._calloutElement.current);\n    }\n  }; // Whether or not the current positions should be reset\n\n\n  CalloutContentBase.prototype._didPositionPropsChange = function (newProps, oldProps) {\n    return !newProps.hidden && newProps.hidden !== oldProps.hidden || newProps.directionalHint !== oldProps.directionalHint;\n  };\n\n  CalloutContentBase.prototype._getTarget = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var target = props.target;\n    return target;\n  };\n\n  CalloutContentBase.defaultProps = {\n    preventDismissOnLostFocus: false,\n    preventDismissOnScroll: false,\n    preventDismissOnResize: false,\n    isBeakVisible: true,\n    beakWidth: 16,\n    gapSpace: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge\n  };\n  return CalloutContentBase;\n}(React.Component);\n\nexport { CalloutContentBase };","map":{"version":3,"mappings":";;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SACEC,KADF,EAIEC,GAJF,EAKEC,aALF,EAMEC,eANF,EAOEC,eAPF,EAQEC,WARF,EASEC,cATF,EAUEC,SAVF,EAWEC,EAXF,EAYEC,cAZF,QAaO,iBAbP;AAcA,SACEC,eADF,EAIEC,YAJF,EAMEC,aANF,EAOEC,YAPF,EAQEC,yBARF,QASO,6BATP;AAUA,SAASC,KAAT,QAAsB,aAAtB;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AACA,SAASC,mBAAT,QAAoC,eAApC;AAGA,IAAMC,UAAU,aACdC,GAACP,aAAa,CAACQ,GAAf,IAAqBH,mBAAmB,CAACI,WAD3B,EAEdF,GAACP,aAAa,CAACU,MAAf,IAAwBL,mBAAmB,CAACM,aAF9B,EAGdJ,GAACP,aAAa,CAACY,IAAf,IAAsBP,mBAAmB,CAACQ,aAH5B,EAIdN,GAACP,aAAa,CAACc,KAAf,IAAuBT,mBAAmB,CAACU,cAJ7B,KAAhB;AAOA,IAAMC,aAAa,GAAGZ,kBAAkB,CAAmD;AACzFa,gBAAc,EAAE;AADyE,CAAnD,CAAxC;AAIA,IAAMC,oBAAoB,GAAG;AAAEV,KAAG,EAAE,CAAP;AAAUI,MAAI,EAAE;AAAhB,CAA7B,C,CACA;AACA;AACA;AACA;AACA;;AACA,IAAMO,gBAAgB,GAAwB;AAAEC,SAAO,EAAE,CAAX;AAAcC,QAAM,EAAE,YAAtB;AAAoCC,eAAa,EAAE;AAAnD,CAA9C,C,CACA;AACA;AACA;;AACA,IAAMC,oBAAoB,GAAG,CAAC,MAAD,EAAS,sBAAT,CAA7B;;AASA;AAAA;AAAA;AAAwCC;;AA6BtC,8BAAYC,KAAZ,EAAgC;AAAhC,gBACEC,kBAAMD,KAAN,KAAY,IADd;;AAfQE,yBAAezC,KAAK,CAAC0C,SAAN,EAAf;AACAD,4BAAkBzC,KAAK,CAAC0C,SAAN,EAAlB;AAMAD,0BAAgB,KAAhB;AAMAA,yBAA+B,EAA/B;;AAwLDA,oBAAU,UAACE,EAAD,EAA8E;AACrF;;AAER,UAAIC,SAAJ,EAAe;AACbA,iBAAS,CAACD,EAAD,CAAT;AACD;AACF,KANM;;AAQGF,6BAAmB,UAACE,EAAD,EAAU;AACrC;AACM;AAAA,UAAEE,gDAAF;AAAA,UAAyBC,kDAAzB;;AACN,UACEL,KAAI,CAACM,KAAL,CAAWC,SAAX,KACEH,qBAAqB,IAAI,CAACA,qBAAqB,CAACF,EAAD,CAAhD,IAA0D,CAACE,qBAAD,IAA0B,CAACC,sBADtF,CADF,EAGE;AACAL,aAAI,CAACQ,uBAAL,CAA6BN,EAA7B;AACD;AACF,KATS;;AAWAF,6BAAmB,UAACE,EAAD,EAAU;AACrC;AACM;AAAA,UAAEE,gDAAF;AAAA,UAAyBK,kDAAzB;;AACN,UAAKL,qBAAqB,IAAI,CAACA,qBAAqB,CAACF,EAAD,CAAhD,IAA0D,CAACE,qBAAD,IAA0B,CAACK,sBAAzF,EAAkH;AAChHT,aAAI,CAACU,OAAL,CAAaR,EAAb;AACD;AACF,KANS;;AAQAF,gCAAsB,UAACE,EAAD,EAAU;AACxC;AACM;AAAA,UAAEE,gDAAF;AAAA,UAAyBO,wDAAzB;;AACN,UACGP,qBAAqB,IAAI,CAACA,qBAAqB,CAACF,EAAD,CAAhD,IACC,CAACE,qBAAD,IAA0B,CAACO,yBAF9B,EAGE;AACAX,aAAI,CAACQ,uBAAL,CAA6BN,EAA7B;AACD;AACF,KATS;;AAWAF,6BAAmB;AAC3B,UACEA,KAAI,CAACF,KAAL,CAAWc,eAAX,IACA,CAACZ,KAAI,CAACa,mBADN,IAEAb,KAAI,CAACM,KAAL,CAAWC,SAFX,IAGAP,KAAI,CAACc,eAAL,CAAqBC,OAJvB,EAKE;AACAf,aAAI,CAACa,mBAAL,GAA2B,IAA3B;;AACAb,aAAI,CAACgB,MAAL,CAAYC,qBAAZ,CACE;AAAM,gCAAe,CAACjB,KAAI,CAACc,eAAL,CAAqBC,OAAtB,CAAf;AAA8C,SADtD,EAEEf,KAAI,CAACc,eAAL,CAAqBC,OAFvB;AAID;AACF,KAbS;;AAeAf,iCAAuB;AAC/BA,WAAI,CAACkB,aAAL;;AAEA,UAAIlB,KAAI,CAACF,KAAL,CAAWqB,cAAf,EAA+B;AAC7BnB,aAAI,CAACF,KAAL,CAAWqB,cAAX;AACD;;AAEDnB,WAAI,CAACoB,oBAAL;;AACApB,WAAI,CAACqB,0BAAL;AACD,KATS;;AAmCFrB,uCAA6B,UAACE,EAAD,EAAe;AAClD;AACM;AAAA,UAAEE,gDAAF;AAAA,UAAyBO,wDAAzB;AAAA,UAAoDW,0DAApD,CAF4C,CAIlD;;AACA,UAAI,CAACA,0BAAL,EAAiC;AAC/B;AACD;;AAED,UACE,CAAElB,qBAAqB,IAAI,CAACA,qBAAqB,CAACF,EAAD,CAAhD,IACE,CAACE,qBAAD,IAA0B,CAACO,yBAD9B,KAEA,CAACX,KAAI,CAACuB,aAAL,CAAmBC,QAAnB,CAA4BC,QAA5B,EAFD,IAGAvB,EAAE,CAACwB,aAAH,KAAqB,IAJvB,EAKE;AACA1B,aAAI,CAACU,OAAL,CAAaR,EAAb;AACD;AACF,KAjBO;;AAwPAF,8BAAoB;AAC1BA,WAAI,CAAC2B,mBAAL,GAA2B,IAA3B;AACD,KAFO;;AAIA3B,4BAAkB;AACxBA,WAAI,CAAC2B,mBAAL,GAA2B,KAA3B;AACD,KAFO;;AAvgBN3B,SAAI,CAACgB,MAAL,GAAc,IAAIvD,KAAJ,CAAUuC,KAAV,CAAd;AACAA,SAAI,CAACa,mBAAL,GAA2B,KAA3B;AACAb,SAAI,CAACM,KAAL,GAAa;AACXC,eAAS,EAAEqB,SADA;AAEXC,+BAAyB,EAAED,SAFhB;AAGX;AACAE,wBAAkB,EAAEF,SAJT;AAKXG,kBAAY,EAAE;AALH,KAAb;AAOA/B,SAAI,CAACgC,iBAAL,GAAyB,CAAzB;;AACD;;AAEMC,oDAAP;AACE,QAAI,CAAC,KAAKnC,KAAL,CAAWoC,MAAhB,EAAwB;AACtB,WAAKC,gBAAL;;AACA,UAAI,CAAC,KAAKC,aAAV,EAAyB;AACvB,aAAKlB,aAAL;AACD;;AACD,WAAKE,oBAAL;AACD,KAND,MAMO;AACL,UAAI,KAAKgB,aAAT,EAAwB;AACtB,aAAKC,gBAAL;AACD;AACF;AACF,GAZM;;AAcAJ,uDAAP,UAA6BK,QAA7B,EAAsDC,QAAtD,EAA6E;AAC3E,QAAI,CAACD,QAAQ,CAACE,sBAAV,IAAoC,KAAK1C,KAAL,CAAWoC,MAA/C,IAAyDI,QAAQ,CAACJ,MAAtE,EAA8E;AAC5E;AACA,aAAO,KAAP;AACD;;AAED,WAAO,CAAChE,cAAc,CAAC,KAAK4B,KAAN,EAAawC,QAAb,CAAf,IAAyC,CAACpE,cAAc,CAAC,KAAKoC,KAAN,EAAaiC,QAAb,CAA/D;AACD,GAPM;;AASAN,2DAAP;AACE,SAAKQ,0BAAL,CAAgC,KAAKC,UAAL,EAAhC;AACD,GAFM;;AAIAT,sDAAP;AACE,SAAKjB,MAAL,CAAY2B,OAAZ;;AACA,SAAKC,YAAL,CAAkBC,OAAlB,CAA0B,UAACF,OAAD,EAAoB;AAAK,oBAAO,EAAP;AAAS,KAA5D;AACD,GAHM;;AAKAV,4DAAP,UAAkCK,QAAlC,EAAyD;AACvD;AACA;AACA,QAAMQ,SAAS,GAAG,KAAKJ,UAAL,CAAgBJ,QAAhB,CAAlB;;AACA,QAAMS,SAAS,GAAG,KAAKL,UAAL,EAAlB;;AACA,QACE,CAACI,SAAS,KAAKC,SAAd,IAA2B,OAAOD,SAAP,KAAqB,QAAhD,IAA4DA,SAAS,YAAYE,MAAlF,KACA,CAAC,KAAKC,iBAFR,EAGE;AACA,WAAKC,UAAL,GAAkBtB,SAAlB;;AACA,WAAKa,0BAAL,CAAgCK,SAAhC;AACD;;AACD,QAAIR,QAAQ,CAACa,QAAT,KAAsB,KAAKrD,KAAL,CAAWqD,QAAjC,IAA6C,KAAKrD,KAAL,CAAWsD,SAAX,KAAyBd,QAAQ,CAACc,SAAnF,EAA8F;AAC5F,WAAKF,UAAL,GAAkBtB,SAAlB;AACD;;AAED,QAAIU,QAAQ,CAACe,WAAT,KAAyB,KAAKvD,KAAL,CAAWuD,WAAxC,EAAqD;AACnD,WAAKhC,0BAAL;AACD,KAlBsD,CAoBvD;;;AACA,QAAI,KAAKiC,uBAAL,CAA6BhB,QAA7B,EAAuC,KAAKxC,KAA5C,CAAJ,EAAwD;AACtD,WAAKoD,UAAL,GAAkBtB,SAAlB,CADsD,CAEtD;;AACA,WAAKa,0BAAL,CAAgCK,SAAhC;;AACA,WAAKS,QAAL,CAAc;AACZhD,iBAAS,EAAEqB;AADC,OAAd;AAGA,WAAKf,mBAAL,GAA2B,KAA3B;AACA,WAAK2C,OAAL,GAAe5B,SAAf;AACD;;AAED,SAAKqB,iBAAL,GAAyB,KAAzB;AACD,GAjCM;;AAmCAhB,mDAAP;AACE,QAAI,CAAC,KAAKnC,KAAL,CAAWoC,MAAhB,EAAwB;AACtB,WAAKuB,oBAAL;AACD;AACF,GAJM;;AAMAxB,wCAAP;AACE;AACA,QAAI,CAAC,KAAKV,aAAV,EAAyB;AACvB,aAAO,IAAP;AACD;;AACK;AACA;AAAA,QACJmC,kBADI;AAAA,QAEJC,gBAFI;AAAA,QAGJC,wBAHI;AAAA,QAIJC,oCAJI;AAAA,QAKJC,kCALI;AAAA,QAMJC,wBANI;AAAA,QAOJC,gCAPI;AAAA,QAQJC,sBARI;AAAA,QASJb,wBATI;AAAA,QAUJc,8BAVI;AAAA,QAWJC,oCAXI;AAAA,QAYJd,4BAZI;AAAA,QAaJe,oBAbI;AAAA,QAaJC,iDAbI;AAAA,QAcJC,oCAdI;AAAA,QAeJC,sCAfI;AAAA,QAgBJC,sBAhBI;AAAA,QAiBJ;AACAC,8BAlBI;AAAA,QAiBJ;AACAC,kDAlBI;AAoBNC,UAAM,GAAG,KAAKjC,UAAL,EAAT;AACQ;AAER,QAAMkC,mBAAmB,GAAuB,KAAKC,aAAL,KAC5C,KAAKA,aAAL,KAAwB,KAAKvE,KAAL,CAAWyB,YADS,GAE5CH,SAFJ;AAGA,QAAMkD,gBAAgB,GACpBP,gBAAiB,IAAIK,mBAArB,IAA4CL,gBAAiB,GAAGK,mBAAhE,GACIL,gBADJ,GAEIK,mBAHN;AAIA,QAAMG,eAAe,GAAGV,YAAxB;AAEA,QAAMW,WAAW,GAAGhB,aAAa,IAAI,CAAC,CAACW,MAAvC;AACA,SAAKM,WAAL,GAAmB5F,aAAa,CAACqE,MAAD,EAAU;AACxCwB,WAAK,EAAE,KAAKpF,KAAL,CAAWoF,KADsB;AAExCnB,eAAS,WAF+B;AAGxCgB,qBAAe,EAAEA,eAHuB;AAIxCb,kBAAY,cAJ4B;AAKxC3D,eAAS,WAL+B;AAMxC6C,eAAS,WAN+B;AAOxCkB,qBAAe,iBAPyB;AAQxCH,qBAAe;AARyB,KAAV,CAAhC;;AAWA,QAAMgB,aAAa,kCACdxB,KADc,GACT;AACRyB,eAAS,EAAEN;AADH,KADS,GAGbC,eAAe,IAAI;AAAEM,eAAS,EAAE;AAAb,KAHN,CAAnB;;AAMA,QAAMC,eAAe,GAAoC,KAAKxF,KAAL,CAAWoC,MAAX,GAAoB;AAAEqD,gBAAU,EAAE;AAAd,KAApB,GAA+C3D,SAAxG,CAxDF,CAyDE;;AACA,QAAM4D,OAAO,GACXjI;AAAKkI,SAAG,EAAE,KAAKC,YAAf;AAA6B3B,eAAS,EAAE,KAAKkB,WAAL,CAAiBU,SAAzD;AAAoEhC,WAAK,EAAE2B;AAA3E,OACE/H,wCACMQ,cAAc,CAAC,KAAK+B,KAAN,EAAanC,aAAb,EAA4BiC,oBAA5B,CADpB,EACqE;AACnEmE,eAAS,EAAErG,GAAG,CAAC,KAAKuH,WAAL,CAAiBW,IAAlB,EAAwBrF,SAAS,IAAIA,SAAS,CAACsF,UAAvB,IAAqClH,UAAU,CAAC4B,SAAS,CAACsF,UAAX,CAAvE,CADqD;AAEnElC,WAAK,EAAEpD,SAAS,GAAGA,SAAS,CAACuF,eAAb,GAA+BtG,gBAFoB;AAGnE;AACA;AACAuG,cAAQ,EAAE,CAAC,CALwD;AAMnEN,SAAG,EAAE,KAAK3E;AANyD,KADrE,GASGkE,WAAW,IAAIzH;AAAKwG,eAAS,EAAE,KAAKkB,WAAL,CAAiBe,IAAjC;AAAuCrC,WAAK,EAAE,KAAKsC,gBAAL;AAA9C,MATlB,EAUGjB,WAAW,IAAIzH;AAAKwG,eAAS,EAAE,KAAKkB,WAAL,CAAiBiB;AAAjC,MAVlB,EAWE3I,oBAACiB,KAAD,EAAM2H,aACApI,cAAc,CAAC,KAAK+B,KAAN,EAAaF,oBAAb,CADd,EACgD;AACpDgE,eAAS,EAAEA,SADyC;AAEpDwC,oBAAc,EAAE,KAAKtG,KAAL,CAAWsG,cAFyB;AAGpDvC,qBAAe,EAAEA,eAHmC;AAIpDC,oBAAc,EAAEA,cAJoC;AAKpDC,eAAS,EAAE,KAAKkB,WAAL,CAAiBoB,WALwB;AAMpDlG,eAAS,EAAE,KAAKO,OANoC;AAOpD8D,cAAQ,EAAEA,QAP0C;AAQpDE,wBAAkB,EAAEA,kBARgC;AASpDf,WAAK,EAAEwB,aAT6C;AAUpDmB,iBAAW,EAAE,KAAKC,iBAVkC;AAWpDC,eAAS,EAAE,KAAKC;AAXoC,KADhD,CAAN,EAcGxC,QAdH,CAXF,CADF,CADF;AAiCA,WAAOuB,OAAP;AACD,GA5FM;;AA8JCvD,yDAAR,UAAgC/B,EAAhC,EAAyC;AACvC,QAAMyE,MAAM,GAAGzE,EAAE,CAACyE,MAAlB;AACA,QAAM+B,2BAA2B,GAC/B,KAAKhB,YAAL,CAAkB3E,OAAlB,IAA6B,CAACnD,eAAe,CAAC,KAAK8H,YAAL,CAAkB3E,OAAnB,EAA4B4D,MAA5B,CAD/C,CAFuC,CAKvC;;AACA,QAAI+B,2BAA2B,IAAI,KAAK/E,mBAAxC,EAA6D;AAC3D,WAAKA,mBAAL,GAA2B,KAA3B;AACA;AACD;;AAED,QACG,CAAC,KAAKgF,OAAN,IAAiBD,2BAAlB,IACCxG,EAAE,CAACyE,MAAH,KAAc,KAAKpD,aAAnB,IACCmF,2BADD,KAEG,KAAKC,OAAL,CAA4BC,eAA5B,IACA,CAAC,KAAKD,OADN,IAEA,KAAK7G,KAAL,CAAW+G,oBAFX,IAGClC,MAAM,KAAK,KAAKgC,OAAhB,IAA2B,CAAC/I,eAAe,CAAC,KAAK+I,OAAN,EAA8BhC,MAA9B,CAL/C,CAFH,EAQE;AACA,WAAKjE,OAAL,CAAaR,EAAb;AACD;AACF,GAtBO;;AA2CA+B,+CAAR;AAAA,sBACE;AACA;AACA;AACA;;;AACA,SAAKjB,MAAL,CAAY8F,UAAZ,CAAuB;AACrB9G,WAAI,CAAC4C,YAAL,CAAkBmE,IAAlB,CACE9I,EAAE,CAAC+B,KAAI,CAACuB,aAAN,EAAqB,QAArB,EAA+BvB,KAAI,CAACgH,gBAApC,EAAsD,IAAtD,CADJ,EAEE/I,EAAE,CAAC+B,KAAI,CAACuB,aAAN,EAAqB,QAArB,EAA+BvB,KAAI,CAACiH,gBAApC,EAAsD,IAAtD,CAFJ,EAGEhJ,EAAE,CAAC+B,KAAI,CAACuB,aAAL,CAAmBC,QAAnB,CAA4B0F,eAA7B,EAA8C,OAA9C,EAAuDlH,KAAI,CAACmH,mBAA5D,EAAiF,IAAjF,CAHJ,EAIElJ,EAAE,CAAC+B,KAAI,CAACuB,aAAL,CAAmBC,QAAnB,CAA4B0F,eAA7B,EAA8C,OAA9C,EAAuDlH,KAAI,CAACmH,mBAA5D,EAAiF,IAAjF,CAJJ,EAKElJ,EAAE,CAAC+B,KAAI,CAACuB,aAAN,EAAqB,MAArB,EAA6BvB,KAAI,CAACoH,0BAAlC,EAA8D,IAA9D,CALJ;;AAOApH,WAAI,CAACoC,aAAL,GAAqB,IAArB;AACD,KATD,EASG,CATH;AAUD,GAfO;;AAiBAH,kDAAR;AACE,SAAKW,YAAL,CAAkBC,OAAlB,CAA0B,UAACF,OAAD,EAAoB;AAAK,oBAAO,EAAP;AAAS,KAA5D;;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKR,aAAL,GAAqB,KAArB;AACD,GAJO;;AAMAH,sDAAR;AAAA;;AACE,SAAKjB,MAAL,CAAYC,qBAAZ,CAAkC;AAAM,kBAAI,CAACoG,eAAL;AAAsB,KAA9D,EAAgE,KAAKvG,eAAL,CAAqBC,OAArF;AACD,GAFO;;AAIAkB,kDAAR;AACU;;AACR,QAAMqF,gBAAgB,gBAChB/G,SAAS,IAAIA,SAAS,CAACgH,YAAvB,GAAsChH,SAAS,CAACgH,YAAV,CAAuBzB,eAA7D,GAA+E,IAD/D,CAAtB;;AAIA,QAAI,CAACwB,gBAAgB,CAACzI,GAAlB,IAAyB,CAACyI,gBAAgB,CAACvI,MAA3C,IAAqD,CAACuI,gBAAgB,CAACrI,IAAvE,IAA+E,CAACqI,gBAAgB,CAACnI,KAArG,EAA4G;AAC1GmI,sBAAgB,CAACrI,IAAjB,GAAwBM,oBAAoB,CAACN,IAA7C;AACAqI,sBAAgB,CAACzI,GAAjB,GAAuBU,oBAAoB,CAACV,GAA5C;AACD;;AAED,WAAOyI,gBAAP;AACD,GAZO;;AAcArF,iDAAR;AACE;AACA,SAAKQ,0BAAL,CAAgC,KAAKC,UAAL,EAAhC;;AAEQ;AACR,QAAM8E,WAAW,GAAuB,KAAK9B,YAAL,CAAkB3E,OAA1D;AACA,QAAM0G,cAAc,GAAuB,KAAK3G,eAAL,CAAqBC,OAAhE,CANF,CAQE;AACA;;AACA,QAAM2G,aAAa,GAAG,CAAC,CAAC,KAAK5H,KAAL,CAAW6E,MAAnC;;AAEA,QAAI6C,WAAW,IAAIC,cAAf,KAAkC,CAACC,aAAD,IAAkB,KAAKf,OAAzD,CAAJ,EAAuE;AACrE,UAAMgB,YAAY,gBAAyB,KAAK7H,KAA9B,CAAlB;;AACA6H,kBAAY,CAACC,MAAb,GAAsB,KAAKC,UAAL,EAAtB;AACAF,kBAAY,CAAChD,MAAb,GAAsB,KAAKgC,OAA3B,CAHqE,CAIrE;AACA;;AACA,UAAMmB,YAAY,GAA2B,KAAKhI,KAAL,CAAWuD,WAAX,GACzC/E,YAAY,CAACqJ,YAAD,EAAeH,WAAf,EAA4BC,cAA5B,EAA4ClH,SAA5C,CAD6B,GAEzCpC,eAAe,CAACwJ,YAAD,EAAeH,WAAf,EAA4BC,cAA5B,EAA4ClH,SAA5C,CAFnB,CANqE,CAUrE;AACA;;AACA,UACG,CAACA,SAAD,IAAcuH,YAAf,IACCvH,SAAS,IAAIuH,YAAb,IAA6B,CAAC,KAAKC,kBAAL,CAAwBxH,SAAxB,EAAmCuH,YAAnC,CAA9B,IAAkF,KAAK9F,iBAAL,GAAyB,CAF9G,EAGE;AACA;AACA;AACA,aAAKA,iBAAL;AACA,aAAKuB,QAAL,CAAc;AACZhD,mBAAS,EAAEuH;AADC,SAAd;AAGD,OAVD,MAUO,IAAI,KAAK9F,iBAAL,GAAyB,CAA7B,EAAgC;AACrC;AACA,aAAKA,iBAAL,GAAyB,CAAzB;;AACA,YAAI,KAAKlC,KAAL,CAAWkI,YAAf,EAA6B;AAC3B,eAAKlI,KAAL,CAAWkI,YAAX,CAAwB,KAAK1H,KAAL,CAAWC,SAAnC;AACD;AACF;AACF;AACF,GA1CO;;AA4CA0B,4CAAR;AACE,QAAI,CAAC,KAAKuB,OAAV,EAAmB;AACjB,UAAMoE,MAAM,GAAG,KAAK9H,KAAL,CAAW8H,MAA1B;AACA,UAAIK,aAAa,GAAG,OAAOL,MAAP,KAAkB,UAAlB,GAA+BA,MAAM,CAAC,KAAK9H,KAAL,CAAW6E,MAAZ,EAAoB,KAAKpD,aAAzB,CAArC,GAA+EqG,MAAnG;;AAEA,UAAI,CAACK,aAAL,EAAoB;AAClBA,qBAAa,GAAG1J,yBAAyB,CAAC,KAAKoI,OAAN,EAAe,KAAKpF,aAApB,CAAzC;AACA0G,qBAAa,GAAG;AACdpJ,aAAG,EAAEoJ,aAAa,CAACpJ,GAAd,GAAoB,KAAKiB,KAAL,CAAWoI,cADtB;AAEdjJ,cAAI,EAAEgJ,aAAa,CAAChJ,IAAd,GAAqB,KAAKa,KAAL,CAAWoI,cAFxB;AAGd/I,eAAK,EAAE8I,aAAa,CAAC9I,KAAd,GAAuB,KAAKW,KAAL,CAAWoI,cAH3B;AAIdnJ,gBAAM,EAAEkJ,aAAa,CAAClJ,MAAd,GAAwB,KAAKe,KAAL,CAAWoI,cAJ7B;AAKdC,eAAK,EAAEF,aAAa,CAACE,KAAd,GAAsB,KAAKrI,KAAL,CAAWoI,cAAX,GAA6B,CAL5C;AAMdE,gBAAM,EAAEH,aAAa,CAACG,MAAd,GAAuB,KAAKtI,KAAL,CAAWoI,cAAX,GAA6B;AAN9C,SAAhB;AAQD;;AACD,WAAK1E,OAAL,GAAeyE,aAAf;AACD;;AACD,WAAO,KAAKzE,OAAZ;AACD,GAnBO,CAnZV,CAwaE;AACA;;;AACQvB,+CAAR;AAAA;;AACE,QAAI,CAAC,KAAKiB,UAAV,EAAsB;AACpB,UAAI,KAAKpD,KAAL,CAAWuI,oBAAX,IAAmC,KAAK1B,OAA5C,EAAqD;AACnD,YAAMvD,SAAS,GAAG,KAAKtD,KAAL,CAAWkE,aAAX,GAA2B,KAAKlE,KAAL,CAAWsD,SAAtC,GAAkD,CAApE;AACA,YAAMD,QAAQ,GAAG,KAAKrD,KAAL,CAAWqD,QAAX,GAAsB,KAAKrD,KAAL,CAAWqD,QAAjC,GAA4C,CAA7D,CAFmD,CAGnD;AACA;;AACA,YAAMmF,UAAQ,GAAGnF,QAAQ,GAAGC,SAA5B;;AACA,aAAKpC,MAAL,CAAYC,qBAAZ,CAAkC;AAChC,cAAIjB,KAAI,CAAC2G,OAAT,EAAkB;AAChB3G,iBAAI,CAACkD,UAAL,GAAkB9E,YAAY,CAC5B4B,KAAI,CAAC2G,OADuB,EAE5B3G,KAAI,CAACF,KAAL,CAAWyI,eAFiB,EAG5BD,UAH4B,EAI5BtI,KAAI,CAAC6H,UAAL,EAJ4B,EAK5B7H,KAAI,CAACF,KAAL,CAAW0I,WALiB,CAA9B;AAOAxI,iBAAI,CAACiD,iBAAL,GAAyB,IAAzB;;AACAjD,iBAAI,CAACyI,WAAL;AACD;AACF,SAZD,EAYG,KAAK9B,OAZR;AAaD,OAnBD,MAmBO;AACL,aAAKzD,UAAL,GAAkB,KAAK2E,UAAL,GAAkBO,MAApC;AACD;AACF;;AACD,WAAO,KAAKlF,UAAZ;AACD,GA1BO;;AA4BAjB,oDAAR,UAA2B1B,SAA3B,EAA8DmI,WAA9D,EAAiG;AAC/F,WACE,KAAKC,iBAAL,CAAuBpI,SAAS,CAACuF,eAAjC,EAAkD4C,WAAW,CAAC5C,eAA9D,KACA,KAAK6C,iBAAL,CAAuBpI,SAAS,CAACgH,YAAV,CAAuBzB,eAA9C,EAA+D4C,WAAW,CAACnB,YAAZ,CAAyBzB,eAAxF,CAFF;AAID,GALO;;AAOA7D,mDAAR,UAA0B2G,YAA1B,EAAmDd,YAAnD,EAA0E;AACxE,SAAK,IAAMe,GAAX,IAAkBf,YAAlB,EAAgC;AAC9B,UAAIA,YAAY,CAACgB,cAAb,CAA4BD,GAA5B,CAAJ,EAAsC;AACpC,YAAME,eAAe,GAAGH,YAAY,CAACC,GAAD,CAApC;AACA,YAAMG,eAAe,GAAGlB,YAAY,CAACe,GAAD,CAApC;;AAEA,YAAIE,eAAe,KAAKnH,SAApB,IAAiCoH,eAAe,KAAKpH,SAAzD,EAAoE;AAClE,cAAImH,eAAe,CAACE,OAAhB,CAAwB,CAAxB,MAA+BD,eAAe,CAACC,OAAhB,CAAwB,CAAxB,CAAnC,EAA+D;AAC7D,mBAAO,KAAP;AACD;AACF,SAJD,MAIO;AACL,iBAAO,KAAP;AACD;AACF;AACF;;AACD,WAAO,IAAP;AACD,GAhBO;;AAkBAhH,4DAAR,UAAmC0C,MAAnC,EAAiD;AAC/C,QAAMuE,cAAc,GAAG,KAAKpI,eAAL,CAAqBC,OAA5C;;AAEA,QAAI4D,MAAJ,EAAY;AACV,UAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,YAAMwE,UAAU,GAAarL,WAAW,CAACoL,cAAD,CAAxC;AACA,aAAKvC,OAAL,GAAewC,UAAU,GAAIA,UAAU,CAACC,aAAX,CAAyBzE,MAAzB,CAAJ,GAAmD,IAA5E;AACA,aAAKpD,aAAL,GAAqBvD,SAAS,CAACkL,cAAD,CAA9B,CAH8B,CAI9B;AACD,OALD,MAKO,IAAKvE,MAAc,CAACiC,eAApB,EAAqC;AAC1C,aAAKrF,aAAL,GAAqBvD,SAAS,CAAE2G,MAAqB,CAACA,MAAxB,CAA9B;AACA,aAAKgC,OAAL,GAAehC,MAAf,CAF0C,CAG1C;AACD,OAJM,MAIA,IAAKA,MAAc,CAAC0E,qBAApB,EAA2C;AAChD,YAAMC,aAAa,GAAY3E,MAA/B;AACA,aAAKpD,aAAL,GAAqBvD,SAAS,CAACsL,aAAD,CAA9B;AACA,aAAK3C,OAAL,GAAe2C,aAAf;AACD,OAJM,MAIA,IAAK3E,MAAmC,CAAC5D,OAApC,KAAgDa,SAArD,EAAgE;AACrE,aAAK+E,OAAL,GAAgBhC,MAAmC,CAAC5D,OAApD;AACA,aAAKQ,aAAL,GAAqBvD,SAAS,CAAC,KAAK2I,OAAN,CAA9B,CAFqE,CAGrE;AACD,OAJM,MAIA;AACL,aAAKpF,aAAL,GAAqBvD,SAAS,CAACkL,cAAD,CAA9B;AACA,aAAKvC,OAAL,GAAehC,MAAf;AACD;AACF,KAtBD,MAsBO;AACL,WAAKpD,aAAL,GAAqBvD,SAAS,CAACkL,cAAD,CAA9B;AACD;AACF,GA5BO;;AA8BAjH,4DAAR;AAAA;;AACE,QAAI,KAAKnB,eAAL,CAAqBC,OAArB,IAAgC,KAAKjB,KAAL,CAAWuD,WAA/C,EAA4D;AAC1D,WAAKkG,qBAAL,GAA6B,KAAKvI,MAAL,CAAYC,qBAAZ,CAAkC;AAC7D,YAAMuI,eAAe,GAAGxJ,KAAI,CAACc,eAAL,CAAqBC,OAArB,IAAiCf,KAAI,CAACc,eAAL,CAAqBC,OAArB,CAA6B0I,SAAtF;;AAEA,YAAI,CAACD,eAAL,EAAsB;AACpB;AACD;;AAED,YAAME,gBAAgB,GAAWF,eAAe,CAACG,YAAjD;AACA,YAAMC,cAAc,GAAWJ,eAAe,CAACK,YAA/C;AACA,YAAMC,UAAU,GAAWJ,gBAAgB,GAAGE,cAA9C;;AAEA5J,aAAI,CAACuD,QAAL,CAAc;AACZxB,sBAAY,EAAE/B,KAAI,CAACM,KAAL,CAAWyB,YAAX,GAA2B+H;AAD7B,SAAd;;AAIA,YAAIN,eAAe,CAACK,YAAhB,GAA+B7J,KAAI,CAACF,KAAL,CAAWuD,WAA9C,EAA4D;AAC1DrD,eAAI,CAACqB,0BAAL;AACD,SAFD,MAEO;AACLrB,eAAI,CAACgB,MAAL,CAAY+I,oBAAZ,CAAiC/J,KAAI,CAACuJ,qBAAtC,EAA6DvJ,KAAI,CAACc,eAAL,CAAqBC,OAAlF;AACD;AACF,OApB4B,EAoB1B,KAAKD,eAAL,CAAqBC,OApBK,CAA7B;AAqBD;AACF,GAxBO,CA7fV,CAuhBE;;;AACQkB,yDAAR,UAAgCK,QAAhC,EAAyD0H,QAAzD,EAAgF;AAC9E,WACG,CAAC1H,QAAQ,CAACJ,MAAV,IAAoBI,QAAQ,CAACJ,MAAT,KAAoB8H,QAAQ,CAAC9H,MAAlD,IAA6DI,QAAQ,CAACiG,eAAT,KAA6ByB,QAAQ,CAACzB,eADrG;AAGD,GAJO;;AAMAtG,4CAAR,UAAmBnC,KAAnB,EAAoD;AAAjC;AAAAA,cAAuB,KAAKA,KAA5B;AAAiC;;AAC1C;AACR,WAAO6E,MAAP;AACD,GAHO;;AA7hBM1C,oCAAe;AAC3BtB,6BAAyB,EAAE,KADA;AAE3BN,0BAAsB,EAAE,KAFG;AAG3BI,0BAAsB,EAAE,KAHG;AAI3BuD,iBAAa,EAAE,IAJY;AAK3BZ,aAAS,EAAE,EALgB;AAM3BD,YAAQ,EAAE,CANiB;AAO3B+E,kBAAc,EAAE,CAPW;AAQ3BK,mBAAe,EAAE/K,eAAe,CAACyM;AARN,GAAf;AAyiBhB;AAAC,CA1iBD,CAAwC1M,KAAK,CAAC2M,SAA9C;;SAAajI","names":["React","DirectionalHint","Async","css","divProperties","elementContains","focusFirstChild","getDocument","getNativeProps","getWindow","on","shallowCompare","positionCallout","getMaxHeight","RectangleEdge","positionCard","getBoundsFromTargetWindow","Popup","classNamesFunction","AnimationClassNames","ANIMATIONS","_a","top","slideUpIn10","bottom","slideDownIn10","left","slideLeftIn10","right","slideRightIn10","getClassNames","disableCaching","BEAK_ORIGIN_POSITION","OFF_SCREEN_STYLE","opacity","filter","pointerEvents","ARIA_ROLE_ATTRIBUTES","__extends","props","_super","_this","createRef","ev","onDismiss","preventDismissOnEvent","preventDismissOnScroll","state","positions","_dismissOnClickOrScroll","preventDismissOnResize","dismiss","preventDismissOnLostFocus","setInitialFocus","_didSetInitialFocus","_calloutElement","current","_async","requestAnimationFrame","_addListeners","onLayerMounted","_updateAsyncPosition","_setHeightOffsetEveryFrame","shouldDismissOnWindowFocus","_targetWindow","document","hasFocus","relatedTarget","_isMouseDownOnPopup","undefined","slideDirectionalClassName","calloutElementRect","heightOffset","_positionAttempts","CalloutContentBase","hidden","_setInitialFocus","_hasListeners","_removeListeners","newProps","newState","shouldUpdateWhenHidden","_setTargetWindowAndElement","_getTarget","dispose","_disposables","forEach","newTarget","oldTarget","String","_blockResetHeight","_maxHeight","gapSpace","beakWidth","finalHeight","_didPositionPropsChange","setState","_bounds","_onComponentDidMount","styles","style","ariaLabel","ariaDescribedBy","ariaLabelledBy","className","isBeakVisible","children","calloutWidth","calloutMaxWidth","_b","hideOverflow","backgroundColor","calloutMaxHeight","onScroll","_c","shouldRestoreFocus","target","getContentMaxHeight","_getMaxHeight","contentMaxHeight","overflowYHidden","beakVisible","_classNames","theme","overflowStyle","maxHeight","overflowY","visibilityStyle","visibility","content","ref","_hostElement","container","root","targetEdge","elementPosition","tabIndex","beak","_getBeakPosition","beakCurtain","__assign","onRestoreFocus","calloutMain","onMouseDown","_mouseDownOnPopup","onMouseUp","_mouseUpOnPopup","isEventTargetOutsideCallout","_target","stopPropagation","dismissOnTargetClick","setTimeout","push","_dismissOnScroll","_dismissOnResize","documentElement","_dismissOnLostFocus","_dismissOnTargetWindowBlur","_updatePosition","beakPostionStyle","beakPosition","hostElement","calloutElement","expectsTarget","currentProps","bounds","_getBounds","newPositions","_arePositionsEqual","onPositioned","currentBounds","minPagePadding","width","height","directionalHintFixed","totalGap_1","directionalHint","coverTarget","forceUpdate","newPosition","_comparePositions","oldPositions","key","hasOwnProperty","oldPositionEdge","newPositionEdge","toFixed","currentElement","currentDoc","querySelector","getBoundingClientRect","targetElement","_setHeightOffsetTimer","calloutMainElem","lastChild","cardScrollHeight","scrollHeight","cardCurrHeight","offsetHeight","scrollDiff","cancelAnimationFrame","oldProps","bottomAutoEdge","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\Callout\\CalloutContent.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { ICalloutProps, ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  Async,\n  Point,\n  IRectangle,\n  css,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getDocument,\n  getNativeProps,\n  getWindow,\n  on,\n  shallowCompare,\n} from '../../Utilities';\nimport {\n  positionCallout,\n  ICalloutPositionedInfo,\n  IPositionProps,\n  getMaxHeight,\n  IPosition,\n  RectangleEdge,\n  positionCard,\n  getBoundsFromTargetWindow,\n} from '../../utilities/positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { Target } from '@uifabric/react-hooks';\n\nconst ANIMATIONS: { [key: number]: string | undefined } = {\n  [RectangleEdge.top]: AnimationClassNames.slideUpIn10,\n  [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,\n  [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,\n  [RectangleEdge.right]: AnimationClassNames.slideRightIn10,\n};\n\nconst getClassNames = classNamesFunction<ICalloutContentStyleProps, ICalloutContentStyles>({\n  disableCaching: true, // disabling caching because stylesProp.position mutates often\n});\n\nconst BEAK_ORIGIN_POSITION = { top: 0, left: 0 };\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nconst OFF_SCREEN_STYLE: React.CSSProperties = { opacity: 0, filter: 'opacity(0)', pointerEvents: 'none' };\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nconst ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nexport interface ICalloutState {\n  positions?: ICalloutPositionedInfo;\n  slideDirectionalClassName?: string;\n  calloutElementRect?: ClientRect;\n  heightOffset?: number;\n}\n\nexport class CalloutContentBase extends React.Component<ICalloutProps, ICalloutState> {\n  public static defaultProps = {\n    preventDismissOnLostFocus: false,\n    preventDismissOnScroll: false,\n    preventDismissOnResize: false,\n    isBeakVisible: true,\n    beakWidth: 16,\n    gapSpace: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n  };\n\n  private _classNames: { [key in keyof ICalloutContentStyles]: string };\n  private _didSetInitialFocus: boolean;\n  private _hostElement = React.createRef<HTMLDivElement>();\n  private _calloutElement = React.createRef<HTMLDivElement>();\n  private _targetWindow: Window;\n  private _bounds: IRectangle | undefined;\n  private _positionAttempts: number;\n  private _target: Element | MouseEvent | Point | null;\n  private _setHeightOffsetTimer: number;\n  private _hasListeners = false;\n  private _maxHeight: number | undefined;\n  private _blockResetHeight: boolean;\n  private _isMouseDownOnPopup: boolean;\n\n  private _async: Async;\n  private _disposables: (() => void)[] = [];\n\n  constructor(props: ICalloutProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._didSetInitialFocus = false;\n    this.state = {\n      positions: undefined,\n      slideDirectionalClassName: undefined,\n      // @TODO it looks like this is not even being used anymore.\n      calloutElementRect: undefined,\n      heightOffset: 0,\n    };\n    this._positionAttempts = 0;\n  }\n\n  public componentDidUpdate() {\n    if (!this.props.hidden) {\n      this._setInitialFocus();\n      if (!this._hasListeners) {\n        this._addListeners();\n      }\n      this._updateAsyncPosition();\n    } else {\n      if (this._hasListeners) {\n        this._removeListeners();\n      }\n    }\n  }\n\n  public shouldComponentUpdate(newProps: ICalloutProps, newState: ICalloutState): boolean {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  public UNSAFE_componentWillMount() {\n    this._setTargetWindowAndElement(this._getTarget());\n  }\n\n  public componentWillUnmount() {\n    this._async.dispose();\n    this._disposables.forEach((dispose: () => void) => dispose());\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: ICalloutProps): void {\n    // If the target element changed, find the new one. If we are tracking target with class name, always find element\n    // because we do not know if fabric has rendered a new element and disposed the old element.\n    const newTarget = this._getTarget(newProps);\n    const oldTarget = this._getTarget();\n    if (\n      (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) &&\n      !this._blockResetHeight\n    ) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n    if (newProps.gapSpace !== this.props.gapSpace || this.props.beakWidth !== newProps.beakWidth) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n\n    // Ensure positioning is recalculated when we are about to show a persisted menu.\n    if (this._didPositionPropsChange(newProps, this.props)) {\n      this._maxHeight = undefined;\n      // Target might have been updated while hidden.\n      this._setTargetWindowAndElement(newTarget);\n      this.setState({\n        positions: undefined,\n      });\n      this._didSetInitialFocus = false;\n      this._bounds = undefined;\n    }\n\n    this._blockResetHeight = false;\n  }\n\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onComponentDidMount();\n    }\n  }\n\n  public render(): JSX.Element | null {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n    let { target } = this.props;\n    const {\n      styles,\n      style,\n      ariaLabel,\n      ariaDescribedBy,\n      ariaLabelledBy,\n      className,\n      isBeakVisible,\n      children,\n      beakWidth,\n      calloutWidth,\n      calloutMaxWidth,\n      finalHeight,\n      hideOverflow = !!finalHeight,\n      backgroundColor,\n      calloutMaxHeight,\n      onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = true,\n    } = this.props;\n    target = this._getTarget();\n    const { positions } = this.state;\n\n    const getContentMaxHeight: number | undefined = this._getMaxHeight()\n      ? this._getMaxHeight()! + this.state.heightOffset!\n      : undefined;\n    const contentMaxHeight: number | undefined =\n      calloutMaxHeight! && getContentMaxHeight && calloutMaxHeight! < getContentMaxHeight\n        ? calloutMaxHeight!\n        : getContentMaxHeight!;\n    const overflowYHidden = hideOverflow;\n\n    const beakVisible = isBeakVisible && !!target;\n    this._classNames = getClassNames(styles!, {\n      theme: this.props.theme!,\n      className,\n      overflowYHidden: overflowYHidden,\n      calloutWidth,\n      positions,\n      beakWidth,\n      backgroundColor,\n      calloutMaxWidth,\n    });\n\n    const overflowStyle: React.CSSProperties = {\n      ...style,\n      maxHeight: contentMaxHeight,\n      ...(overflowYHidden && { overflowY: 'hidden' }),\n    };\n\n    const visibilityStyle: React.CSSProperties | undefined = this.props.hidden ? { visibility: 'hidden' } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    const content = (\n      <div ref={this._hostElement} className={this._classNames.container} style={visibilityStyle}>\n        <div\n          {...getNativeProps(this.props, divProperties, ARIA_ROLE_ATTRIBUTES)}\n          className={css(this._classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge!])}\n          style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={this._calloutElement}\n        >\n          {beakVisible && <div className={this._classNames.beak} style={this._getBeakPosition()} />}\n          {beakVisible && <div className={this._classNames.beakCurtain} />}\n          <Popup\n            {...getNativeProps(this.props, ARIA_ROLE_ATTRIBUTES)}\n            ariaLabel={ariaLabel}\n            onRestoreFocus={this.props.onRestoreFocus}\n            ariaDescribedBy={ariaDescribedBy}\n            ariaLabelledBy={ariaLabelledBy}\n            className={this._classNames.calloutMain}\n            onDismiss={this.dismiss}\n            onScroll={onScroll}\n            shouldRestoreFocus={shouldRestoreFocus}\n            style={overflowStyle}\n            onMouseDown={this._mouseDownOnPopup}\n            onMouseUp={this._mouseUpOnPopup}\n          >\n            {children}\n          </Popup>\n        </div>\n      </div>\n    );\n\n    return content;\n  }\n\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev);\n    }\n  };\n\n  protected _dismissOnScroll = (ev: Event) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnScroll } = this.props;\n    if (\n      this.state.positions &&\n      ((preventDismissOnEvent && !preventDismissOnEvent(ev)) || (!preventDismissOnEvent && !preventDismissOnScroll))\n    ) {\n      this._dismissOnClickOrScroll(ev);\n    }\n  };\n\n  protected _dismissOnResize = (ev: Event) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnResize } = this.props;\n    if ((preventDismissOnEvent && !preventDismissOnEvent(ev)) || (!preventDismissOnEvent && !preventDismissOnResize)) {\n      this.dismiss(ev);\n    }\n  };\n\n  protected _dismissOnLostFocus = (ev: Event) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnLostFocus } = this.props;\n    if (\n      (preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n      (!preventDismissOnEvent && !preventDismissOnLostFocus)\n    ) {\n      this._dismissOnClickOrScroll(ev);\n    }\n  };\n\n  protected _setInitialFocus = (): void => {\n    if (\n      this.props.setInitialFocus &&\n      !this._didSetInitialFocus &&\n      this.state.positions &&\n      this._calloutElement.current\n    ) {\n      this._didSetInitialFocus = true;\n      this._async.requestAnimationFrame(\n        () => focusFirstChild(this._calloutElement.current!),\n        this._calloutElement.current,\n      );\n    }\n  };\n\n  protected _onComponentDidMount = (): void => {\n    this._addListeners();\n\n    if (this.props.onLayerMounted) {\n      this.props.onLayerMounted();\n    }\n\n    this._updateAsyncPosition();\n    this._setHeightOffsetEveryFrame();\n  };\n\n  private _dismissOnClickOrScroll(ev: Event) {\n    const target = ev.target as HTMLElement;\n    const isEventTargetOutsideCallout =\n      this._hostElement.current && !elementContains(this._hostElement.current, target);\n\n    // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n    if (isEventTargetOutsideCallout && this._isMouseDownOnPopup) {\n      this._isMouseDownOnPopup = false;\n      return;\n    }\n\n    if (\n      (!this._target && isEventTargetOutsideCallout) ||\n      (ev.target !== this._targetWindow &&\n        isEventTargetOutsideCallout &&\n        ((this._target as MouseEvent).stopPropagation ||\n          !this._target ||\n          this.props.dismissOnTargetClick ||\n          (target !== this._target && !elementContains(this._target as HTMLElement, target))))\n    ) {\n      this.dismiss(ev);\n    }\n  }\n\n  private _dismissOnTargetWindowBlur = (ev: FocusEvent) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnLostFocus, shouldDismissOnWindowFocus } = this.props;\n\n    // Do nothing\n    if (!shouldDismissOnWindowFocus) {\n      return;\n    }\n\n    if (\n      ((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n        (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&\n      !this._targetWindow.document.hasFocus() &&\n      ev.relatedTarget === null\n    ) {\n      this.dismiss(ev);\n    }\n  };\n\n  private _addListeners() {\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    this._async.setTimeout(() => {\n      this._disposables.push(\n        on(this._targetWindow, 'scroll', this._dismissOnScroll, true),\n        on(this._targetWindow, 'resize', this._dismissOnResize, true),\n        on(this._targetWindow.document.documentElement, 'focus', this._dismissOnLostFocus, true),\n        on(this._targetWindow.document.documentElement, 'click', this._dismissOnLostFocus, true),\n        on(this._targetWindow, 'blur', this._dismissOnTargetWindowBlur, true),\n      );\n      this._hasListeners = true;\n    }, 0);\n  }\n\n  private _removeListeners() {\n    this._disposables.forEach((dispose: () => void) => dispose());\n    this._disposables = [];\n    this._hasListeners = false;\n  }\n\n  private _updateAsyncPosition(): void {\n    this._async.requestAnimationFrame(() => this._updatePosition(), this._calloutElement.current);\n  }\n\n  private _getBeakPosition(): React.CSSProperties {\n    const { positions } = this.state;\n    const beakPostionStyle: React.CSSProperties = {\n      ...(positions && positions.beakPosition ? positions.beakPosition.elementPosition : null),\n    };\n\n    if (!beakPostionStyle.top && !beakPostionStyle.bottom && !beakPostionStyle.left && !beakPostionStyle.right) {\n      beakPostionStyle.left = BEAK_ORIGIN_POSITION.left;\n      beakPostionStyle.top = BEAK_ORIGIN_POSITION.top;\n    }\n\n    return beakPostionStyle;\n  }\n\n  private _updatePosition(): void {\n    // Try to update the target, page might have changed\n    this._setTargetWindowAndElement(this._getTarget());\n\n    const { positions } = this.state;\n    const hostElement: HTMLElement | null = this._hostElement.current;\n    const calloutElement: HTMLElement | null = this._calloutElement.current;\n\n    // If we expect a target element to position against, we need to wait until `this._target` is resolved. Otherwise\n    // we can try to position.\n    const expectsTarget = !!this.props.target;\n\n    if (hostElement && calloutElement && (!expectsTarget || this._target)) {\n      const currentProps: IPositionProps = { ...(this.props as any) };\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target!;\n      // If there is a finalHeight given then we assume that the user knows and will handle\n      // additional positioning adjustments so we should call positionCard\n      const newPositions: ICalloutPositionedInfo = this.props.finalHeight\n        ? positionCard(currentProps, hostElement, calloutElement, positions)\n        : positionCallout(currentProps, hostElement, calloutElement, positions);\n\n      // Set the new position only when the positions are not exists or one of the new callout positions are different.\n      // The position should not change if the position is within 2 decimal places.\n      if (\n        (!positions && newPositions) ||\n        (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)\n      ) {\n        // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n        // and we should stop trying to reposition to prevent a stack overflow.\n        this._positionAttempts++;\n        this.setState({\n          positions: newPositions,\n        });\n      } else if (this._positionAttempts > 0) {\n        // Only call the onPositioned callback if the callout has been re-positioned at least once.\n        this._positionAttempts = 0;\n        if (this.props.onPositioned) {\n          this.props.onPositioned(this.state.positions);\n        }\n      }\n    }\n  }\n\n  private _getBounds(): IRectangle {\n    if (!this._bounds) {\n      const bounds = this.props.bounds;\n      let currentBounds = typeof bounds === 'function' ? bounds(this.props.target, this._targetWindow) : bounds;\n\n      if (!currentBounds) {\n        currentBounds = getBoundsFromTargetWindow(this._target, this._targetWindow);\n        currentBounds = {\n          top: currentBounds.top + this.props.minPagePadding!,\n          left: currentBounds.left + this.props.minPagePadding!,\n          right: currentBounds.right! - this.props.minPagePadding!,\n          bottom: currentBounds.bottom! - this.props.minPagePadding!,\n          width: currentBounds.width - this.props.minPagePadding! * 2,\n          height: currentBounds.height - this.props.minPagePadding! * 2,\n        };\n      }\n      this._bounds = currentBounds;\n    }\n    return this._bounds;\n  }\n\n  // Max height should remain as synchronous as possible, which is why it is not done using set state.\n  // It needs to be synchronous since it will impact the ultimate position of the callout.\n  private _getMaxHeight(): number | undefined {\n    if (!this._maxHeight) {\n      if (this.props.directionalHintFixed && this._target) {\n        const beakWidth = this.props.isBeakVisible ? this.props.beakWidth : 0;\n        const gapSpace = this.props.gapSpace ? this.props.gapSpace : 0;\n        // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will\n        // overlap with the target.\n        const totalGap = gapSpace + beakWidth!;\n        this._async.requestAnimationFrame(() => {\n          if (this._target) {\n            this._maxHeight = getMaxHeight(\n              this._target,\n              this.props.directionalHint!,\n              totalGap,\n              this._getBounds(),\n              this.props.coverTarget,\n            );\n            this._blockResetHeight = true;\n            this.forceUpdate();\n          }\n        }, this._target as Element);\n      } else {\n        this._maxHeight = this._getBounds().height!;\n      }\n    }\n    return this._maxHeight!;\n  }\n\n  private _arePositionsEqual(positions: ICalloutPositionedInfo, newPosition: ICalloutPositionedInfo): boolean {\n    return (\n      this._comparePositions(positions.elementPosition, newPosition.elementPosition) &&\n      this._comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition)\n    );\n  }\n\n  private _comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n    for (const key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        const oldPositionEdge = oldPositions[key];\n        const newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  private _setTargetWindowAndElement(target: Target): void {\n    const currentElement = this._calloutElement.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target as MouseEvent;\n        // Same reason here\n      } else if ((target as any).getBoundingClientRect) {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = targetElement;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n        // HTMLImgElements can have x and y values. The check for it being a point must go last.\n      } else {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target as Point;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  private _setHeightOffsetEveryFrame(): void {\n    if (this._calloutElement.current && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {\n        const calloutMainElem = this._calloutElement.current && (this._calloutElement.current.lastChild as HTMLElement);\n\n        if (!calloutMainElem) {\n          return;\n        }\n\n        const cardScrollHeight: number = calloutMainElem.scrollHeight;\n        const cardCurrHeight: number = calloutMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        this.setState({\n          heightOffset: this.state.heightOffset! + scrollDiff,\n        });\n\n        if (calloutMainElem.offsetHeight < this.props.finalHeight!) {\n          this._setHeightOffsetEveryFrame();\n        } else {\n          this._async.cancelAnimationFrame(this._setHeightOffsetTimer, this._calloutElement.current);\n        }\n      }, this._calloutElement.current);\n    }\n  }\n\n  // Whether or not the current positions should be reset\n  private _didPositionPropsChange(newProps: ICalloutProps, oldProps: ICalloutProps): boolean {\n    return (\n      (!newProps.hidden && newProps.hidden !== oldProps.hidden) || newProps.directionalHint !== oldProps.directionalHint\n    );\n  }\n\n  private _getTarget(props: ICalloutProps = this.props): Target {\n    const { target } = props;\n    return target!;\n  }\n\n  private _mouseDownOnPopup = () => {\n    this._isMouseDownOnPopup = true;\n  };\n\n  private _mouseUpOnPopup = () => {\n    this._isMouseDownOnPopup = false;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}