{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\n\nfunction _createPositionData(targetEdge, alignmentEdge, isAuto) {\n  return {\n    targetEdge: targetEdge,\n    alignmentEdge: alignmentEdge,\n    isAuto: isAuto\n  };\n} // Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\n\n\nvar DirectionalDictionary = (_a = {}, _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, undefined, true), _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, undefined, true), _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a);\n\nfunction _isRectangleWithinBounds(rect, boundingRect) {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\n\n\nfunction _getOutOfBoundsEdges(rect, boundingRect) {\n  var outOfBounds = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect, edge) {\n  return rect[RectangleEdge[edge]];\n}\n\nfunction _setEdgeValue(rect, edge, value) {\n  rect[RectangleEdge[edge]] = value;\n  return rect;\n}\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\n\n\nfunction _getCenterValue(rect, edge) {\n  var edges = _getFlankingEdges(edge);\n\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reveserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\n\n\nfunction _getRelativeEdgeValue(edge, value) {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge, rect) {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect, hostRect, edge) {\n  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n */\n\n\nfunction _moveEdge(rect, edge, newValue) {\n  var difference = _getEdgeValue(rect, edge) - newValue;\n  rect = _setEdgeValue(rect, edge, newValue);\n  rect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  return rect;\n}\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\n\n\nfunction _alignEdges(rect, target, edge, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\n\n\nfunction _alignOppositeEdges(rect, target, targetEdge, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var oppositeEdge = targetEdge * -1;\n\n  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\n\n\nfunction _isEdgeInBounds(rect, bounds, edge) {\n  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the original position should be returned.\n */\n\n\nfunction _flipToFit(rect, target, bounding, positionData, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var directions = [RectangleEdge.left, RectangleEdge.right, RectangleEdge.bottom, RectangleEdge.top]; // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n\n  var currentEstimate = rect;\n  var currentEdge = positionData.targetEdge;\n  var currentAlignment = positionData.alignmentEdge; // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n\n  for (var i = 0; i < 4; i++) {\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      directions.splice(directions.indexOf(currentEdge), 1);\n\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n\n        currentEstimate = _estimatePosition(rect, target, {\n          targetEdge: currentEdge,\n          alignmentEdge: currentAlignment\n        }, gap);\n      }\n    } else {\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment\n      };\n    }\n  }\n\n  return {\n    elementRectangle: rect,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: positionData.alignmentEdge\n  };\n}\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when alignTargetEdge is specified.\n */\n\n\nfunction _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {\n  var alignmentEdge = elementEstimate.alignmentEdge,\n      targetEdge = elementEstimate.targetEdge,\n      elementRectangle = elementEstimate.elementRectangle;\n  var oppositeEdge = alignmentEdge * -1;\n\n  var newEstimate = _estimatePosition(elementRectangle, target, {\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge\n  }, gap, coverTarget);\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge\n  };\n}\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\n\n\nfunction _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var alignmentEdge = positionData.alignmentEdge,\n      alignTargetEdge = positionData.alignTargetEdge;\n  var elementEstimate = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: alignmentEdge\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\n  }\n\n  var outOfBounds = _getOutOfBoundsEdges(element, bounding);\n\n  if (alignTargetEdge) {\n    // The edge opposite to the alignment edge might be out of bounds.\n    // Flip alignment to see if we can get it within bounds.\n    if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n      var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n\n      if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n        return flippedElementEstimate;\n      } else {\n        // If the flipped elements edges are still out of bounds, try nudging it.\n        elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding);\n      }\n    }\n  } else {\n    elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding);\n  }\n\n  return elementEstimate;\n}\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n */\n\n\nfunction _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding) {\n  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {\n    var direction = outOfBoundsEdges_1[_i];\n    elementEstimate.elementRectangle = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n  }\n\n  return elementEstimate;\n}\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\n\n\nfunction _centerEdgeToPoint(rect, edge, point) {\n  var positiveEdge = _getFlankingEdges(edge).positiveEdge;\n\n  var elementMiddle = _getCenterValue(rect, edge);\n\n  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\n\n\nfunction _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n\n  var estimatedElementPosition;\n  var alignmentEdge = positionData.alignmentEdge,\n      targetEdge = positionData.targetEdge;\n  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget ? _alignEdges(elementToPosition, target, targetEdge, gap) : _alignOppositeEdges(elementToPosition, target, targetEdge, gap); // if no alignment edge is provided it's supposed to be centered.\n\n  if (!alignmentEdge) {\n    var targetMiddlePoint = _getCenterValue(target, targetEdge);\n\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\n\n\nfunction _getFlankingEdges(edge) {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom\n    };\n  }\n}\n/**\n * Retrieve the final value for the return edge of elementRectangle. If the elementRectangle is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\n\n\nfunction _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {\n  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n/**\n * Finalizes the element positon based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the callou shrinks it shrinks towards that corner.\n */\n\n\nfunction _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge) {\n  var returnValue = {};\n\n  var hostRect = _getRectangleFromElement(hostElement);\n\n  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  var elementEdgeString = RectangleEdge[elementEdge];\n  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n\n  if (!doNotFinalizeReturnEdge) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[elementEdgeString] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n  return returnValue;\n} // Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\n\n\nfunction _calculateActualBeakWidthInPixels(beakWidth) {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\n\n\nfunction _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {\n  if (directionalHint === void 0) {\n    directionalHint = DirectionalHint.bottomAutoEdge;\n  }\n\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge\n    };\n  }\n\n  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);\n\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n\n  return positionInformation;\n}\n/**\n * Get's the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\n\n\nfunction _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge, target, boundingRect) {\n  var targetCenter = _getCenterValue(target, targetEdge);\n\n  var boundingCenter = _getCenterValue(boundingRect, targetEdge);\n\n  var _a = _getFlankingEdges(targetEdge),\n      positiveEdge = _a.positiveEdge,\n      negativeEdge = _a.negativeEdge;\n\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {\n  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);\n\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge\n    };\n  } else {\n    return _adjustFitWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);\n  }\n}\n\nfunction _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {\n  var targetEdge = elementPosition.targetEdge * -1; // The \"host\" element that we will use to help position the beak.\n\n  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);\n  var returnValue = {};\n\n  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);\n\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n  return {\n    elementPosition: __assign({}, returnValue),\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge: targetEdge\n  };\n}\n\nfunction _positionBeak(beakWidth, elementPosition) {\n  var target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n\n  var _a = _getFlankingEdges(elementPosition.targetEdge),\n      positiveEdge = _a.positiveEdge,\n      negativeEdge = _a.negativeEdge;\n\n  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n\n  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);\n  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element) {\n  var clientRect = element.getBoundingClientRect();\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect) {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds, target) {\n  var targetRectangle;\n\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!target.preventDefault) {\n      var ev = target;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY); // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!target.getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target); // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      var point = target; // eslint-disable-next-line deprecation/deprecation\n\n      var left = point.left || point.x; // eslint-disable-next-line deprecation/deprecation\n\n      var top_1 = point.top || point.y;\n      targetRectangle = new Rectangle(left, left, top_1, top_1);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {\n        var direction = outOfBounds_1[_i];\n        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\n\n\nfunction _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {\n  var maxHeight = 0;\n  var directionalHint = DirectionalDictionary[targetEdge]; // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n\n  var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {\n  var gap = props.gapSpace ? props.gapSpace : 0;\n\n  var targetRect = _getTargetRect(boundingRect, props.target);\n\n  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);\n\n  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);\n\n  return __assign(__assign({}, positionedElement), {\n    targetRectangle: targetRect\n  });\n}\n\nfunction _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {\n  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge);\n\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge\n  };\n}\n\nfunction _positionElement(props, hostElement, elementToPosition, previousPositions) {\n  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);\n\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {\n  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  var positionProps = props;\n  positionProps.gapSpace = gap;\n  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);\n\n  var beakPositioned = _positionBeak(beakWidth, positionedElement);\n\n  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);\n\n  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), {\n    beakPosition: finalizedBeakPosition\n  });\n}\n\nfunction _positionCard(props, hostElement, callout, previousPositions) {\n  return _positionCallout(props, hostElement, callout, previousPositions, true);\n} // END PRIVATE FUNCTIONS\n\n\nexport var __positioningTestPackage = {\n  _finalizePositionData: _finalizePositionData,\n  _finalizeBeakPosition: _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels: _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds: _positionElementWithinBounds,\n  _positionBeak: _positionBeak,\n  _getPositionData: _getPositionData,\n  _getMaxHeightFromTargetRectangle: _getMaxHeightFromTargetRectangle\n};\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\n\nexport function positionElement(props, hostElement, elementToPosition, previousPositions) {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\n}\nexport function positionCallout(props, hostElement, elementToPosition, previousPositions) {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\n}\nexport function positionCard(props, hostElement, elementToPosition, previousPositions) {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions);\n}\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\n\nexport function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget) {\n  if (gapSpace === void 0) {\n    gapSpace = 0;\n  }\n\n  var mouseTarget = target;\n  var elementTarget = target;\n  var pointTarget = target;\n  var targetRect;\n  var boundingRectangle = bounds ? _getRectangleFromIRect(bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight); // eslint-disable-next-line deprecation/deprecation\n\n  var left = pointTarget.left || pointTarget.x; // eslint-disable-next-line deprecation/deprecation\n\n  var top = pointTarget.top || pointTarget.y; // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, left, top, top);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\n\nexport function getOppositeEdge(edge) {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(target, targetWindow) {\n  var segments = undefined;\n\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  } // Identify if we're dealing with single screen scenarios.\n\n\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight\n    };\n  } // Logic for determining dual screen scenarios.\n\n\n  var x = 0;\n  var y = 0; // If the target is an Element get coordinates for its center.\n\n  if (target !== null && !!target.getBoundingClientRect) {\n    var clientRect = target.getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  } // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = target.left || target.x; // eslint-disable-next-line deprecation/deprecation\n\n    y = target.top || target.y;\n  }\n\n  var bounds = {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: 0,\n    height: 0\n  }; // Define which window segment are the coordinates in and calculate bounds based on that.\n\n  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n    var segment = segments_1[_i];\n\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(target, targetWindow) {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}","map":{"version":3,"mappings":"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","names":["DirectionalHint","getScrollbarWidth","getRTL","RectangleEdge","Rectangle","_createPositionData","targetEdge","alignmentEdge","isAuto","DirectionalDictionary","_a","topLeftEdge","top","left","topCenter","topRightEdge","right","topAutoEdge","undefined","bottomLeftEdge","bottom","bottomCenter","bottomRightEdge","bottomAutoEdge","leftTopEdge","leftCenter","leftBottomEdge","rightTopEdge","rightCenter","rightBottomEdge","_isRectangleWithinBounds","rect","boundingRect","_getOutOfBoundsEdges","outOfBounds","push","_getEdgeValue","edge","_setEdgeValue","value","_getCenterValue","edges","_getFlankingEdges","positiveEdge","negativeEdge","_getRelativeEdgeValue","_getRelativeRectEdgeValue","_getRelativeEdgeDifference","hostRect","edgeDifference","_moveEdge","newValue","difference","_alignEdges","target","gap","_alignOppositeEdges","oppositeEdge","adjustedGap","_isEdgeInBounds","bounds","adjustedRectValue","_flipToFit","bounding","positionData","directions","currentEstimate","currentEdge","currentAlignment","i","splice","indexOf","length","slice","_estimatePosition","elementRectangle","_flipAlignmentEdge","elementEstimate","coverTarget","newEstimate","_adjustFitWithinBounds","element","directionalHintFixed","alignTargetEdge","flippedElementEstimate","_alignOutOfBoundsEdges","outOfBoundsEdges","_i","direction","_centerEdgeToPoint","point","elementMiddle","distanceToMiddle","elementToPosition","estimatedElementPosition","elementEdge","targetMiddlePoint","_finalizeReturnEdge","returnEdge","Math","abs","_finalizeElementPosition","hostElement","doNotFinalizeReturnEdge","returnValue","_getRectangleFromElement","elementEdgeString","_calculateActualBeakWidthInPixels","beakWidth","sqrt","_getPositionData","directionalHint","directionalHintForRTL","previousPositions","positionInformation","_getAlignmentData","getClosestEdge","targetCenter","boundingCenter","_positionElementWithinBounds","_finalizeBeakPosition","elementPosition","positionedBeak","actualElement","width","height","closestEdge","_positionBeak","targetRectangle","beakTargetPoint","elementBounds","beakPosition","clientRect","getBoundingClientRect","_getRectangleFromIRect","_getTargetRect","preventDefault","ev","clientX","clientY","x","top_1","y","_getMaxHeightFromTargetRectangle","gapSpace","maxHeight","_positionElementRelative","props","targetRect","positionedElement","_finalizePositionData","finalizedElement","_positionElement","window","innerWidth","innerHeight","_positionCallout","callout","isBeakVisible","positionProps","beakPositioned","finalizedBeakPosition","_positionCard","__positioningTestPackage","positionElement","positionCallout","positionCard","getMaxHeight","mouseTarget","elementTarget","pointTarget","boundingRectangle","stopPropagation","getOppositeEdge","_getBoundsFromTargetWindow","targetWindow","segments","getWindowSegments","segment","getBoundsFromTargetWindow"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\utilities\\src\\utilities\\positioning\\positioning.ts"],"sourcesContent":["import { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL, IRectangle } from '../../Utilities';\nimport {\n  IPositionDirectionalHintData,\n  IPositionedData,\n  ICalloutPositionedInfo,\n  ICalloutBeakPositionedInfo,\n  IPositionProps,\n  ICalloutPositionProps,\n  RectangleEdge,\n  IWindowWithSegments,\n} from './positioning.types';\nimport { Point, Rectangle } from '../../Utilities';\n\nfunction _createPositionData(\n  targetEdge: RectangleEdge,\n  alignmentEdge?: RectangleEdge,\n  isAuto?: boolean,\n): IPositionDirectionalHintData {\n  return {\n    targetEdge: targetEdge,\n    alignmentEdge: alignmentEdge,\n    isAuto: isAuto,\n  };\n}\n\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nconst DirectionalDictionary: { [key: number]: IPositionDirectionalHintData } = {\n  [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),\n  [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),\n  [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),\n  [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),\n  [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\n  [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),\n  [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\n  [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),\n  [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),\n  [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),\n  [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\n  [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),\n  [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),\n  [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom),\n};\n\n/**\n * Do not call methods from this directly, use either positionCallout or positionElement or make another function that\n * utilizes them.\n * START Private functions and interfaces\n */\n\nexport interface IElementPosition {\n  elementRectangle: Rectangle;\n  targetEdge: RectangleEdge;\n  alignmentEdge: RectangleEdge | undefined;\n}\n\nexport interface IElementPositionInfo extends IElementPosition {\n  targetRectangle: Rectangle;\n}\n\ntype PartialIRectangle = Partial<IRectangle>;\n\ninterface IPartialIRectangle extends PartialIRectangle {\n  [key: string]: number | undefined;\n}\n\nfunction _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\n  const outOfBounds: RectangleEdge[] = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect: Rectangle, edge: RectangleEdge): number {\n  return (rect as any)[RectangleEdge[edge]] as number;\n}\n\nfunction _setEdgeValue(rect: Rectangle, edge: RectangleEdge, value: number) {\n  (rect as any)[RectangleEdge[edge]] = value;\n  return rect;\n}\n\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect: Rectangle, edge: RectangleEdge): number {\n  const edges = _getFlankingEdges(edge);\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reveserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge: RectangleEdge, value: number): number {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge: RectangleEdge, rect: Rectangle): number {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect: Rectangle, hostRect: Rectangle, edge: RectangleEdge): number {\n  const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n */\nfunction _moveEdge(rect: Rectangle, edge: RectangleEdge, newValue: number): Rectangle {\n  const difference = _getEdgeValue(rect, edge) - newValue;\n  rect = _setEdgeValue(rect, edge, newValue);\n  rect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  return rect;\n}\n\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect: Rectangle, target: Rectangle, edge: RectangleEdge, gap: number = 0): Rectangle {\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(\n  rect: Rectangle,\n  target: Rectangle,\n  targetEdge: RectangleEdge,\n  gap: number = 0,\n): Rectangle {\n  const oppositeEdge = targetEdge * -1;\n  const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect: Rectangle, bounds: Rectangle, edge: RectangleEdge): boolean {\n  const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the original position should be returned.\n */\nfunction _flipToFit(\n  rect: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n): IElementPosition {\n  const directions: RectangleEdge[] = [\n    RectangleEdge.left,\n    RectangleEdge.right,\n    RectangleEdge.bottom,\n    RectangleEdge.top,\n  ];\n  // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n  let currentEstimate = rect;\n  let currentEdge = positionData.targetEdge;\n  let currentAlignment = positionData.alignmentEdge;\n  // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n  for (let i = 0; i < 4; i++) {\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      directions.splice(directions.indexOf(currentEdge), 1);\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n        currentEstimate = _estimatePosition(\n          rect,\n          target,\n          { targetEdge: currentEdge, alignmentEdge: currentAlignment },\n          gap,\n        );\n      }\n    } else {\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n      };\n    }\n  }\n  return {\n    elementRectangle: rect,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: positionData.alignmentEdge,\n  };\n}\n\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when alignTargetEdge is specified.\n */\nfunction _flipAlignmentEdge(\n  elementEstimate: IElementPosition,\n  target: Rectangle,\n  gap: number,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;\n  const oppositeEdge = alignmentEdge! * -1;\n  const newEstimate = _estimatePosition(\n    elementRectangle,\n    target,\n    { targetEdge: targetEdge, alignmentEdge: oppositeEdge },\n    gap,\n    coverTarget,\n  );\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge,\n  };\n}\n\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(\n  element: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, alignTargetEdge } = positionData;\n  let elementEstimate: IElementPosition = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: alignmentEdge,\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\n  }\n  const outOfBounds = _getOutOfBoundsEdges(element, bounding);\n\n  if (alignTargetEdge) {\n    // The edge opposite to the alignment edge might be out of bounds.\n    // Flip alignment to see if we can get it within bounds.\n    if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n      const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n      if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n        return flippedElementEstimate;\n      } else {\n        // If the flipped elements edges are still out of bounds, try nudging it.\n        elementEstimate = _alignOutOfBoundsEdges(\n          _getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding),\n          elementEstimate,\n          bounding,\n        );\n      }\n    }\n  } else {\n    elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding);\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n */\nfunction _alignOutOfBoundsEdges(\n  outOfBoundsEdges: RectangleEdge[],\n  elementEstimate: IElementPosition,\n  bounding: Rectangle,\n) {\n  for (const direction of outOfBoundsEdges) {\n    elementEstimate.elementRectangle = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: number): Rectangle {\n  const { positiveEdge } = _getFlankingEdges(edge);\n  const elementMiddle = _getCenterValue(rect, edge);\n  const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  coverTarget?: boolean,\n): Rectangle {\n  let estimatedElementPosition: Rectangle;\n  const { alignmentEdge, targetEdge } = positionData;\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget\n    ? _alignEdges(elementToPosition, target, targetEdge, gap)\n    : _alignOppositeEdges(elementToPosition, target, targetEdge, gap);\n  // if no alignment edge is provided it's supposed to be centered.\n  if (!alignmentEdge) {\n    const targetMiddlePoint = _getCenterValue(target, targetEdge);\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge: RectangleEdge): { positiveEdge: RectangleEdge; negativeEdge: RectangleEdge } {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right,\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom,\n    };\n  }\n}\n\n/**\n * Retrieve the final value for the return edge of elementRectangle. If the elementRectangle is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(\n  elementRectangle: Rectangle,\n  returnEdge: RectangleEdge,\n  bounds?: Rectangle,\n): RectangleEdge {\n  if (\n    bounds &&\n    Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\n      Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))\n  ) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n\n/**\n * Finalizes the element positon based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the callou shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(\n  elementRectangle: Rectangle,\n  hostElement: HTMLElement,\n  targetEdge: RectangleEdge,\n  bounds?: Rectangle,\n  alignmentEdge?: RectangleEdge,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n): IPartialIRectangle {\n  const returnValue: IPartialIRectangle = {};\n\n  const hostRect: Rectangle = _getRectangleFromElement(hostElement);\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  const elementEdgeString = RectangleEdge[elementEdge];\n  let returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n  if (!doNotFinalizeReturnEdge) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[elementEdgeString] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n\n  return returnValue;\n}\n\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth: number): number {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(\n  directionalHint: DirectionalHint = DirectionalHint.bottomAutoEdge,\n  directionalHintForRTL?: DirectionalHint,\n  previousPositions?: IPositionDirectionalHintData,\n): IPositionDirectionalHintData {\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge,\n    };\n  }\n  const positionInformation: IPositionDirectionalHintData = { ...DirectionalDictionary[directionalHint] };\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n  return positionInformation;\n}\n\n/**\n * Get's the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(\n  positionData: IPositionDirectionalHintData,\n  target: Rectangle,\n  boundingRect: Rectangle,\n  coverTarget?: boolean,\n  alignTargetEdge?: boolean,\n): IPositionDirectionalHintData {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge: RectangleEdge, target: Rectangle, boundingRect: Rectangle): RectangleEdge {\n  const targetCenter: number = _getCenterValue(target, targetEdge);\n  const boundingCenter: number = _getCenterValue(boundingRect, targetEdge);\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const estimatedElementPosition: Rectangle = _estimatePosition(\n    elementToPosition,\n    target,\n    positionData,\n    gap,\n    coverTarget,\n  );\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge,\n    };\n  } else {\n    return _adjustFitWithinBounds(\n      elementToPosition,\n      target,\n      bounding,\n      positionData,\n      gap,\n      directionalHintFixed,\n      coverTarget,\n    );\n  }\n}\n\nfunction _finalizeBeakPosition(\n  elementPosition: IElementPosition,\n  positionedBeak: Rectangle,\n  bounds?: Rectangle,\n): ICalloutBeakPositionedInfo {\n  const targetEdge = elementPosition.targetEdge * -1;\n  // The \"host\" element that we will use to help position the beak.\n  const actualElement = new Rectangle(\n    0,\n    elementPosition.elementRectangle.width,\n    0,\n    elementPosition.elementRectangle.height,\n  );\n  const returnValue: IPartialIRectangle = {};\n  const returnEdge = _finalizeReturnEdge(\n    elementPosition.elementRectangle,\n    elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\n    bounds,\n  );\n\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n\n  return {\n    elementPosition: { ...returnValue },\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge: targetEdge,\n  };\n}\n\nfunction _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle {\n  const target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);\n  const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n  const elementBounds = new Rectangle(\n    beakWidth / 2,\n    elementPosition.elementRectangle.width - beakWidth / 2,\n    beakWidth / 2,\n    elementPosition.elementRectangle.height - beakWidth / 2,\n  );\n\n  let beakPosition: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\n\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n\n  beakPosition = _centerEdgeToPoint(\n    beakPosition,\n    elementPosition.targetEdge * -1,\n    beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle),\n  );\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element: Element): Rectangle {\n  const clientRect: ClientRect = element.getBoundingClientRect();\n\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect: IRectangle): Rectangle {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | Point | undefined): Rectangle {\n  let targetRectangle: Rectangle;\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!(target as MouseEvent).preventDefault) {\n      const ev = target as MouseEvent;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n      // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!(target as Element).getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target as Element);\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      const point: Point = target as Point;\n      // eslint-disable-next-line deprecation/deprecation\n      const left = point.left || point.x;\n      // eslint-disable-next-line deprecation/deprecation\n      const top = point.top || point.y;\n      targetRectangle = new Rectangle(left, left, top, top);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      const outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (const direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(\n  targetRectangle: Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number,\n  bounds: Rectangle,\n  coverTarget?: boolean,\n) {\n  let maxHeight = 0;\n  const directionalHint = DirectionalDictionary[targetEdge];\n\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n  const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(\n  props: IPositionProps,\n  elementToPosition: HTMLElement,\n  boundingRect: Rectangle,\n  previousPositions?: IPositionedData,\n): IElementPositionInfo {\n  const gap: number = props.gapSpace ? props.gapSpace : 0;\n  const targetRect: Rectangle = _getTargetRect(boundingRect, props.target);\n  const positionData: IPositionDirectionalHintData = _getAlignmentData(\n    _getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions)!,\n    targetRect,\n    boundingRect,\n    props.coverTarget,\n    props.alignTargetEdge,\n  );\n  const positionedElement: IElementPosition = _positionElementWithinBounds(\n    _getRectangleFromElement(elementToPosition),\n    targetRect,\n    boundingRect,\n    positionData,\n    gap,\n    props.directionalHintFixed,\n    props.coverTarget,\n  );\n  return { ...positionedElement, targetRectangle: targetRect };\n}\n\nfunction _finalizePositionData(\n  positionedElement: IElementPosition,\n  hostElement: HTMLElement,\n  bounds?: Rectangle,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n): IPositionedData {\n  const finalizedElement: IPartialIRectangle = _finalizeElementPosition(\n    positionedElement.elementRectangle,\n    hostElement,\n    positionedElement.targetEdge,\n    bounds,\n    positionedElement.alignmentEdge,\n    coverTarget,\n    doNotFinalizeReturnEdge,\n  );\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge,\n  };\n}\n\nfunction _positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPosition = _positionElementRelative(\n    props,\n    elementToPosition,\n    boundingRect,\n    previousPositions,\n  );\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _positionCallout(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  doNotFinalizeReturnEdge?: boolean,\n): ICalloutPositionedInfo {\n  const beakWidth: number = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  const gap: number = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  const positionProps: IPositionProps = props;\n  positionProps.gapSpace = gap;\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPositionInfo = _positionElementRelative(\n    positionProps,\n    callout,\n    boundingRect,\n    previousPositions,\n  );\n  const beakPositioned: Rectangle = _positionBeak(beakWidth, positionedElement);\n  const finalizedBeakPosition: ICalloutBeakPositionedInfo = _finalizeBeakPosition(\n    positionedElement,\n    beakPositioned,\n    boundingRect,\n  );\n  return {\n    ..._finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge),\n    beakPosition: finalizedBeakPosition,\n  };\n}\n\nfunction _positionCard(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, callout, previousPositions, true);\n}\n// END PRIVATE FUNCTIONS\n\nexport const __positioningTestPackage = {\n  _finalizePositionData,\n  _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds,\n  _positionBeak,\n  _getPositionData,\n  _getMaxHeightFromTargetRectangle,\n};\n\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCallout(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCard(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions);\n}\n\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(\n  target: Element | MouseEvent | Point,\n  targetEdge: DirectionalHint,\n  gapSpace: number = 0,\n  bounds?: IRectangle,\n  coverTarget?: boolean,\n): number {\n  const mouseTarget: MouseEvent = target as MouseEvent;\n  const elementTarget: Element = target as Element;\n  const pointTarget: Point = target as Point;\n  let targetRect: Rectangle;\n  const boundingRectangle = bounds\n    ? _getRectangleFromIRect(bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  // eslint-disable-next-line deprecation/deprecation\n  const left = pointTarget.left || pointTarget.x;\n  // eslint-disable-next-line deprecation/deprecation\n  const top = pointTarget.top || pointTarget.y;\n\n  // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, left, top, top);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge: RectangleEdge): RectangleEdge {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  let segments = undefined;\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  }\n\n  // Identify if we're dealing with single screen scenarios.\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight,\n    };\n  }\n\n  // Logic for determining dual screen scenarios.\n  let x: number | undefined = 0;\n  let y: number | undefined = 0;\n\n  // If the target is an Element get coordinates for its center.\n  if (target !== null && !!(target as Element).getBoundingClientRect) {\n    const clientRect = (target as Element).getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  }\n  // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = (target as Point).left || (target as MouseEvent | Point).x;\n    // eslint-disable-next-line deprecation/deprecation\n    y = (target as Point).top || (target as MouseEvent | Point).y;\n  }\n\n  let bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };\n\n  // Define which window segment are the coordinates in and calculate bounds based on that.\n  for (const segment of segments) {\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height,\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}\n"]},"metadata":{},"sourceType":"module"}