{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { getLayerStyles } from './KeytipLayer.styles';\nimport { Keytip } from '../../Keytip';\nimport { Layer } from '../../Layer';\nimport { classNamesFunction, getDocument, arraysEqual, warn, isMac, EventGroup, Async, initializeComponentRef, KeyCodes } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { KeytipTree } from './KeytipTree';\nimport { ktpTargetFromId, ktpTargetFromSequences, sequencesToID, mergeOverflows } from '../../utilities/keytips/KeytipUtils';\nimport { transitionKeysContain } from '../../utilities/keytips/IKeytipTransitionKey';\nimport { KeytipEvents, KTP_LAYER_ID, KTP_ARIA_SEPARATOR } from '../../utilities/keytips/KeytipConstants'; // Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\n\nvar defaultStartSequence = {\n  key: isMac() ? 'Control' : 'Meta',\n  modifierKeys: [KeyCodes.alt]\n}; // Default exit sequence is the same as the start sequence\n\nvar defaultExitSequence = defaultStartSequence; // Default return sequence is Escape\n\nvar defaultReturnSequence = {\n  key: 'Escape'\n};\nvar getClassNames = classNamesFunction();\n/**\n * A layer that holds all keytip items\n * {@docCategory Keytips}\n */\n\nvar KeytipLayerBase =\n/** @class */\nfunction (_super) {\n  __extends(KeytipLayerBase, _super);\n\n  function KeytipLayerBase(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this._keytipManager = KeytipManager.getInstance();\n    _this._delayedKeytipQueue = [];\n    _this._keyHandled = false;\n\n    _this._onDismiss = function (ev) {\n      // if we are in keytip mode, then exit keytip mode\n      if (_this.state.inKeytipMode) {\n        _this._exitKeytipMode(ev);\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      _this._keyHandled = false; // using key since which has been deprecated and key is now widely suporrted.\n      // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n\n      var key = ev.key;\n\n      switch (key) {\n        case 'Tab':\n        case 'Enter':\n        case 'Spacebar':\n        case ' ':\n        case 'ArrowUp':\n        case 'Up':\n        case 'ArrowDown':\n        case 'Down':\n        case 'ArrowLeft':\n        case 'Left':\n        case 'ArrowRight':\n        case 'Right':\n          if (_this.state.inKeytipMode) {\n            _this._keyHandled = true;\n\n            _this._exitKeytipMode(ev);\n          }\n\n          break;\n\n        default:\n          // Special cases for browser-specific keys that are not at standard\n          // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n          if (key === 'Esc') {\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n            key = 'Escape';\n          } else if (key === 'OS' || key === 'Win') {\n            // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n            // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n            key = 'Meta';\n          }\n\n          var transitionKey = {\n            key: key\n          };\n          transitionKey.modifierKeys = _this._getModifierKey(key, ev);\n\n          _this.processTransitionInput(transitionKey, ev);\n\n          break;\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      if (_this.state.inKeytipMode && !_this._keyHandled) {\n        // Call processInput\n        _this.processInput(ev.key.toLocaleLowerCase(), ev);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    _this._onKeytipAdded = function (eventArgs) {\n      var _a;\n\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.addNode(keytipProps, uniqueID);\n\n      _this._setKeytips(); // Add the keytip to the queue to show later\n\n\n      if (_this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n        // Ensure existing children are still shown.\n        _this._delayedKeytipQueue = _this._delayedKeytipQueue.concat(((_a = _this._keytipTree.currentKeytip) === null || _a === void 0 ? void 0 : _a.children) || []);\n\n        _this._addKeytipToQueue(sequencesToID(keytipProps.keySequences)); // Ensure the child of currentKeytip is successfully added to currentKeytip's children and update it if not.\n        // Note: Added this condition because KeytipTree.addNode was not always reflecting updates made to a parent node\n        // in currentKeytip when that parent is the currentKeytip.\n\n\n        if (_this._keytipTree.currentKeytip && _this._keytipTree.currentKeytip.hasDynamicChildren && _this._keytipTree.currentKeytip.children.indexOf(keytipProps.id) < 0) {\n          var currNode = _this._keytipTree.getNode(_this._keytipTree.currentKeytip.id);\n\n          if (currNode) {\n            _this._keytipTree.currentKeytip = currNode;\n          }\n        }\n      }\n\n      if (_this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, _this._newCurrentKeytipSequences)) {\n        _this._triggerKeytipImmediately(keytipProps);\n      }\n\n      if (_this._isCurrentKeytipAnAlias(keytipProps)) {\n        var keytipSequence = keytipProps.keySequences;\n\n        if (keytipProps.overflowSetSequence) {\n          keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n        }\n\n        _this._keytipTree.currentKeytip = _this._keytipTree.getNode(sequencesToID(keytipSequence));\n      }\n    };\n\n    _this._onKeytipUpdated = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.updateNode(keytipProps, uniqueID);\n\n      _this._setKeytips();\n\n      if (_this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n        _this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n      }\n    };\n\n    _this._onKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID; // Remove keytip from the delayed queue\n\n      _this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences)); // Remove the node from the Tree\n\n\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n\n      _this._setKeytips();\n    };\n\n    _this._onPersistedKeytipAdded = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.addNode(keytipProps, uniqueID, true);\n    };\n\n    _this._onPersistedKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n    };\n\n    _this._onPersistedKeytipExecute = function (eventArgs) {\n      _this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n    };\n    /**\n     * Sets if we are in keytip mode.\n     * Note, this sets both the state for the layer as well as\n     * the value that the manager will expose externally.\n     * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\n     */\n\n\n    _this._setInKeytipMode = function (inKeytipMode) {\n      _this.setState({\n        inKeytipMode: inKeytipMode\n      });\n\n      _this._keytipManager.inKeytipMode = inKeytipMode;\n    };\n    /**\n     * Emits a warning if duplicate keytips are found for the children of the current keytip\n     */\n\n\n    _this._warnIfDuplicateKeytips = function () {\n      var duplicateKeytips = _this._getDuplicateIds(_this._keytipTree.getChildren());\n\n      if (duplicateKeytips.length) {\n        warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n      }\n    };\n    /**\n     * Returns duplicates among keytip IDs.\n     * If the returned array is empty, no duplicates were found.\n     *\n     * @param keytipIds - Array of keytip IDs to find duplicates for\n     * @returns - Array of duplicates that were found. Each duplicate will only be added once to this array.\n     */\n\n\n    _this._getDuplicateIds = function (keytipIds) {\n      var seenIds = {};\n      return keytipIds.filter(function (keytipId) {\n        seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1; // Only add the first duplicate keytip seen\n\n        return seenIds[keytipId] === 2;\n      });\n    };\n\n    initializeComponentRef(_this);\n    _this._events = new EventGroup(_this);\n    _this._async = new Async(_this);\n\n    var managerKeytips = __spreadArrays(_this._keytipManager.getKeytips());\n\n    _this.state = {\n      inKeytipMode: false,\n      // Get the initial set of keytips\n      keytips: managerKeytips,\n      visibleKeytips: _this._getVisibleKeytips(managerKeytips)\n    };\n\n    _this._buildTree();\n\n    _this._currentSequence = ''; // Add keytip listeners\n\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_ADDED, _this._onKeytipAdded);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_UPDATED, _this._onKeytipUpdated);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_REMOVED, _this._onKeytipRemoved);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, _this._onPersistedKeytipAdded);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, _this._onPersistedKeytipRemoved);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, _this._onPersistedKeytipExecute);\n\n    return _this;\n  }\n\n  KeytipLayerBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        content = _a.content,\n        styles = _a.styles;\n    var _b = this.state,\n        keytips = _b.keytips,\n        visibleKeytips = _b.visibleKeytips;\n    this._classNames = getClassNames(styles, {});\n    return React.createElement(Layer, {\n      styles: getLayerStyles\n    }, React.createElement(\"span\", {\n      id: KTP_LAYER_ID,\n      className: this._classNames.innerContent\n    }, \"\" + content + KTP_ARIA_SEPARATOR), keytips && keytips.map(function (keytipProps, index) {\n      return React.createElement(\"span\", {\n        key: index,\n        id: sequencesToID(keytipProps.keySequences),\n        className: _this._classNames.innerContent\n      }, keytipProps.keySequences.join(KTP_ARIA_SEPARATOR));\n    }), visibleKeytips && visibleKeytips.map(function (visibleKeytipProps) {\n      return React.createElement(Keytip, __assign({\n        key: sequencesToID(visibleKeytipProps.keySequences)\n      }, visibleKeytipProps));\n    }));\n  };\n\n  KeytipLayerBase.prototype.componentDidMount = function () {\n    // Add window listeners\n    this._events.on(window, 'mouseup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'pointerup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'resize', this._onDismiss);\n\n    this._events.on(window, 'keydown', this._onKeyDown, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'keypress', this._onKeyPress, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'scroll', this._onDismiss, true\n    /* useCapture */\n    ); // Add keytip listeners\n\n\n    this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n\n    this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  };\n\n  KeytipLayerBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  }; // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n\n\n  KeytipLayerBase.prototype.getCurrentSequence = function () {\n    return this._currentSequence;\n  };\n\n  KeytipLayerBase.prototype.getKeytipTree = function () {\n    return this._keytipTree;\n  };\n  /**\n   * Processes an IKeytipTransitionKey entered by the user\n   *\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\n   */\n\n\n  KeytipLayerBase.prototype.processTransitionInput = function (transitionKey, ev) {\n    var currKtp = this._keytipTree.currentKeytip;\n\n    if (transitionKeysContain(this.props.keytipExitSequences, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n\n      this._exitKeytipMode(ev);\n    } else if (transitionKeysContain(this.props.keytipReturnSequences, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          } // Reset currentSequence\n\n\n          this._currentSequence = ''; // Return pointer to its parent\n\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent); // Show children keytips of the new currentKeytip\n\n          this.showKeytips(this._keytipTree.getChildren());\n\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (transitionKeysContain(this.props.keytipStartSequences, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n\n      this._enterKeytipMode();\n\n      this._warnIfDuplicateKeytips();\n    }\n  };\n  /**\n   * Processes inputs from the document listener and traverse the keytip tree\n   *\n   * @param key - Key pressed by the user\n   */\n\n\n  KeytipLayerBase.prototype.processInput = function (key, ev) {\n    // Concat the input key with the current sequence\n    var currSequence = this._currentSequence + key;\n    var currKtp = this._keytipTree.currentKeytip; // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n\n    if (currKtp) {\n      var node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n\n        var currKtpChildren = this._keytipTree.getChildren(); // Execute this node's onExecute if defined\n\n\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp)); // Reset currKtp, this might have changed from the onExecute\n\n          currKtp = this._keytipTree.currentKeytip;\n        } // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n\n\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n\n          this._warnIfDuplicateKeytips();\n        } // Clear currentSequence\n\n\n        this._currentSequence = '';\n        return;\n      }\n\n      var partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        var ids = partialNodes.filter(function (partialNode) {\n          return !partialNode.persisted;\n        }).map(function (partialNode) {\n          return partialNode.id;\n        });\n        this.showKeytips(ids); // Save currentSequence\n\n        this._currentSequence = currSequence;\n      }\n    }\n  };\n  /**\n   * Show the given keytips and hide all others\n   *\n   * @param ids - Keytip IDs to show\n   */\n\n\n  KeytipLayerBase.prototype.showKeytips = function (ids) {\n    // Update the visible prop in the manager\n    for (var _i = 0, _a = this._keytipManager.getKeytips(); _i < _a.length; _i++) {\n      var keytip = _a[_i];\n      var keytipId = sequencesToID(keytip.keySequences);\n\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else if (keytip.overflowSetSequence && ids.indexOf(sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence))) >= 0) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    } // Apply the manager changes to the Layer state\n\n\n    this._setKeytips();\n  };\n  /**\n   * Enters keytip mode for this layer\n   */\n\n\n  KeytipLayerBase.prototype._enterKeytipMode = function () {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      if (this._keytipManager.delayUpdatingKeytipChange) {\n        this._buildTree();\n\n        this._setKeytips();\n      }\n\n      this._keytipTree.currentKeytip = this._keytipTree.root; // Show children of root\n\n      this.showKeytips(this._keytipTree.getChildren());\n\n      this._setInKeytipMode(true\n      /* inKeytipMode */\n      );\n\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode();\n      }\n    }\n  };\n\n  KeytipLayerBase.prototype._buildTree = function () {\n    this._keytipTree = new KeytipTree(); // Add regular and persisted keytips to the tree\n\n    for (var _i = 0, _a = Object.keys(this._keytipManager.keytips); _i < _a.length; _i++) {\n      var id = _a[_i];\n      var uniqueKeytip = this._keytipManager.keytips[id];\n\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n\n    for (var _b = 0, _c = Object.keys(this._keytipManager.persistedKeytips); _b < _c.length; _b++) {\n      var id = _c[_b];\n      var uniqueKeytip = this._keytipManager.persistedKeytips[id];\n\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n  };\n  /**\n   * Exits keytip mode for this layer\n   */\n\n\n  KeytipLayerBase.prototype._exitKeytipMode = function (ev) {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = ''; // Hide all keytips\n\n    this.showKeytips([]); // Reset the delayed keytips if any\n\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n\n    this._setInKeytipMode(false\n    /* inKeytipMode */\n    );\n\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  };\n  /**\n   * Sets the keytips state property\n   *\n   * @param keytipProps - Keytips to set in this layer\n   */\n\n\n  KeytipLayerBase.prototype._setKeytips = function (keytipProps) {\n    if (keytipProps === void 0) {\n      keytipProps = this._keytipManager.getKeytips();\n    }\n\n    this.setState({\n      keytips: keytipProps,\n      visibleKeytips: this._getVisibleKeytips(keytipProps)\n    });\n  };\n  /**\n   * Callback function to use for persisted keytips\n   *\n   * @param overflowButtonSequences - The overflow button sequence to execute\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\n   */\n\n\n  KeytipLayerBase.prototype._persistedKeytipExecute = function (overflowButtonSequences, keytipSequences) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences; // Execute the overflow button's onExecute\n\n    var overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));\n\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(this._getKtpExecuteTarget(overflowKeytipNode), this._getKtpTarget(overflowKeytipNode));\n    }\n  };\n\n  KeytipLayerBase.prototype._getVisibleKeytips = function (keytips) {\n    // Filter out non-visible keytips and duplicates\n    var seenIds = {};\n    return keytips.filter(function (keytip) {\n      var keytipId = sequencesToID(keytip.keySequences);\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      return keytip.visible && seenIds[keytipId] === 1;\n    });\n  };\n  /**\n   * Gets the ModifierKeyCodes based on the keyboard event\n   *\n   * @param ev - React.KeyboardEvent\n   * @returns List of ModifierKeyCodes that were pressed\n   */\n\n\n  KeytipLayerBase.prototype._getModifierKey = function (key, ev) {\n    var modifierKeys = [];\n\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(KeyCodes.alt);\n    }\n\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(KeyCodes.ctrl);\n    }\n\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(KeyCodes.shift);\n    }\n\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(KeyCodes.leftWindow);\n    }\n\n    return modifierKeys.length ? modifierKeys : undefined;\n  };\n  /**\n   * Trigger a keytip immediately and set it as the current keytip\n   *\n   * @param keytipProps - Keytip to trigger immediately\n   */\n\n\n  KeytipLayerBase.prototype._triggerKeytipImmediately = function (keytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    var keytipSequence = __spreadArrays(keytipProps.keySequences);\n\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    } // Set currentKeytip\n\n\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      var children = this._keytipTree.getChildren();\n\n      if (children.length) {\n        this.showKeytips(children);\n      }\n\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(this._getKtpExecuteTarget(this._keytipTree.currentKeytip), this._getKtpTarget(this._keytipTree.currentKeytip));\n      }\n    } // Unset _newCurrKtpSequences\n\n\n    this._newCurrentKeytipSequences = undefined;\n  };\n\n  KeytipLayerBase.prototype._addKeytipToQueue = function (keytipID) {\n    var _this = this; // Add keytip\n\n\n    this._delayedKeytipQueue.push(keytipID); // Clear timeout\n\n\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout); // Reset timeout\n\n    this._delayedQueueTimeout = this._async.setTimeout(function () {\n      if (_this._delayedKeytipQueue.length) {\n        _this.showKeytips(_this._delayedKeytipQueue);\n\n        _this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  };\n\n  KeytipLayerBase.prototype._removeKeytipFromQueue = function (keytipID) {\n    var _this = this;\n\n    var index = this._delayedKeytipQueue.indexOf(keytipID);\n\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1); // Clear timeout\n\n\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout); // Reset timeout\n\n      this._delayedQueueTimeout = this._async.setTimeout(function () {\n        if (_this._delayedKeytipQueue.length) {\n          _this.showKeytips(_this._delayedKeytipQueue);\n\n          _this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  };\n\n  KeytipLayerBase.prototype._getKtpExecuteTarget = function (currKtp) {\n    return getDocument().querySelector(ktpTargetFromId(currKtp.id));\n  };\n\n  KeytipLayerBase.prototype._getKtpTarget = function (currKtp) {\n    return getDocument().querySelector(ktpTargetFromSequences(currKtp.keySequences));\n  };\n  /**\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\n   * This will make 'keytipProps' the new currentKeytip\n   *\n   * @param keytipProps - Keytip props to check\n   * @returns - T/F if this keytip should become the currentKeytip\n   */\n\n\n  KeytipLayerBase.prototype._isCurrentKeytipAnAlias = function (keytipProps) {\n    var currKtp = this._keytipTree.currentKeytip;\n\n    if (currKtp && (currKtp.overflowSetSequence || currKtp.persisted) && arraysEqual(keytipProps.keySequences, currKtp.keySequences)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  KeytipLayerBase.defaultProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: ''\n  };\n  return KeytipLayerBase;\n}(React.Component);\n\nexport { KeytipLayerBase };","map":{"version":3,"mappings":"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","names":["React","getLayerStyles","Keytip","Layer","classNamesFunction","getDocument","arraysEqual","warn","isMac","EventGroup","Async","initializeComponentRef","KeyCodes","KeytipManager","KeytipTree","ktpTargetFromId","ktpTargetFromSequences","sequencesToID","mergeOverflows","transitionKeysContain","KeytipEvents","KTP_LAYER_ID","KTP_ARIA_SEPARATOR","defaultStartSequence","key","modifierKeys","alt","defaultExitSequence","defaultReturnSequence","getClassNames","__extends","props","context","_super","_this","getInstance","ev","state","inKeytipMode","_exitKeytipMode","_keyHandled","transitionKey","_getModifierKey","processTransitionInput","processInput","toLocaleLowerCase","preventDefault","stopPropagation","eventArgs","keytipProps","keytip","uniqueID","_keytipTree","addNode","_setKeytips","isCurrentKeytipParent","_delayedKeytipQueue","concat","currentKeytip","_a","children","_addKeytipToQueue","keySequences","hasDynamicChildren","indexOf","id","currNode","getNode","_newCurrentKeytipSequences","_triggerKeytipImmediately","_isCurrentKeytipAnAlias","keytipSequence","overflowSetSequence","updateNode","_removeKeytipFromQueue","removeNode","_persistedKeytipExecute","overflowButtonSequences","keytipSequences","setState","_keytipManager","duplicateKeytips","_getDuplicateIds","getChildren","length","join","keytipIds","seenIds","filter","keytipId","_events","_async","managerKeytips","getKeytips","keytips","visibleKeytips","_getVisibleKeytips","_buildTree","_currentSequence","on","KEYTIP_ADDED","_onKeytipAdded","KEYTIP_UPDATED","_onKeytipUpdated","KEYTIP_REMOVED","_onKeytipRemoved","PERSISTED_KEYTIP_ADDED","_onPersistedKeytipAdded","PERSISTED_KEYTIP_REMOVED","_onPersistedKeytipRemoved","PERSISTED_KEYTIP_EXECUTE","_onPersistedKeytipExecute","KeytipLayerBase","content","styles","_classNames","className","innerContent","map","index","visibleKeytipProps","__assign","window","_onDismiss","_onKeyDown","_onKeyPress","ENTER_KEYTIP_MODE","_enterKeytipMode","EXIT_KEYTIP_MODE","dispose","currKtp","keytipExitSequences","keytipReturnSequences","root","onReturn","_getKtpExecuteTarget","_getKtpTarget","parent","showKeytips","_warnIfDuplicateKeytips","keytipStartSequences","currSequence","node","getExactMatchedNode","currKtpChildren","onExecute","hasMenu","partialNodes","getPartiallyMatchedNodes","ids","partialNode","persisted","_i","visible","shouldEnterKeytipMode","delayUpdatingKeytipChange","_setInKeytipMode","onEnterKeytipMode","keys","uniqueKeytip","persistedKeytips","_b","undefined","_delayedQueueTimeout","clearTimeout","onExitKeytipMode","overflowKeytipNode","altKey","push","ctrlKey","ctrl","shiftKey","shift","metaKey","leftWindow","keytipID","setTimeout","splice","querySelector","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\KeytipLayer\\KeytipLayer.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { IKeytipLayerProps, IKeytipLayerStyles, IKeytipLayerStyleProps } from './KeytipLayer.types';\nimport { getLayerStyles } from './KeytipLayer.styles';\nimport { Keytip, IKeytipProps } from '../../Keytip';\nimport { Layer } from '../../Layer';\nimport {\n  classNamesFunction,\n  getDocument,\n  arraysEqual,\n  warn,\n  isMac,\n  EventGroup,\n  Async,\n  initializeComponentRef,\n  KeyCodes,\n} from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { KeytipTree } from './KeytipTree';\nimport { IKeytipTreeNode } from './IKeytipTreeNode';\nimport {\n  ktpTargetFromId,\n  ktpTargetFromSequences,\n  sequencesToID,\n  mergeOverflows,\n} from '../../utilities/keytips/KeytipUtils';\nimport {\n  transitionKeysContain,\n  KeytipTransitionModifier,\n  IKeytipTransitionKey,\n} from '../../utilities/keytips/IKeytipTransitionKey';\nimport { KeytipEvents, KTP_LAYER_ID, KTP_ARIA_SEPARATOR } from '../../utilities/keytips/KeytipConstants';\n\nexport interface IKeytipLayerState {\n  inKeytipMode: boolean;\n  keytips: IKeytipProps[];\n  visibleKeytips: IKeytipProps[];\n}\n\n// Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\nconst defaultStartSequence: IKeytipTransitionKey = {\n  key: isMac() ? 'Control' : 'Meta',\n  modifierKeys: [KeyCodes.alt],\n};\n\n// Default exit sequence is the same as the start sequence\nconst defaultExitSequence: IKeytipTransitionKey = defaultStartSequence;\n\n// Default return sequence is Escape\nconst defaultReturnSequence: IKeytipTransitionKey = {\n  key: 'Escape',\n};\n\nconst getClassNames = classNamesFunction<IKeytipLayerStyleProps, IKeytipLayerStyles>();\n\n/**\n * A layer that holds all keytip items\n * {@docCategory Keytips}\n */\nexport class KeytipLayerBase extends React.Component<IKeytipLayerProps, IKeytipLayerState> {\n  public static defaultProps: IKeytipLayerProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: '',\n  };\n\n  private _events: EventGroup;\n  private _async: Async;\n\n  private _keytipTree: KeytipTree;\n\n  private _keytipManager: KeytipManager = KeytipManager.getInstance();\n  private _classNames: { [key in keyof IKeytipLayerStyles]: string };\n  private _currentSequence: string;\n  private _newCurrentKeytipSequences?: string[];\n\n  private _delayedKeytipQueue: string[] = [];\n  private _delayedQueueTimeout: number;\n\n  private _keyHandled = false;\n\n  constructor(props: IKeytipLayerProps, context: any) {\n    super(props, context);\n\n    initializeComponentRef(this);\n    this._events = new EventGroup(this);\n    this._async = new Async(this);\n\n    const managerKeytips = [...this._keytipManager.getKeytips()];\n    this.state = {\n      inKeytipMode: false,\n      // Get the initial set of keytips\n      keytips: managerKeytips,\n      visibleKeytips: this._getVisibleKeytips(managerKeytips),\n    };\n\n    this._buildTree();\n\n    this._currentSequence = '';\n\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);\n  }\n\n  public render(): JSX.Element {\n    const { content, styles } = this.props;\n\n    const { keytips, visibleKeytips } = this.state;\n\n    this._classNames = getClassNames(styles, {});\n\n    return (\n      <Layer styles={getLayerStyles}>\n        <span id={KTP_LAYER_ID} className={this._classNames.innerContent}>{`${content}${KTP_ARIA_SEPARATOR}`}</span>\n        {keytips &&\n          keytips.map((keytipProps: IKeytipProps, index: number) => {\n            return (\n              <span key={index} id={sequencesToID(keytipProps.keySequences)} className={this._classNames.innerContent}>\n                {keytipProps.keySequences.join(KTP_ARIA_SEPARATOR)}\n              </span>\n            );\n          })}\n        {visibleKeytips &&\n          visibleKeytips.map((visibleKeytipProps: IKeytipProps) => {\n            return <Keytip key={sequencesToID(visibleKeytipProps.keySequences)} {...visibleKeytipProps} />;\n          })}\n      </Layer>\n    );\n  }\n\n  public componentDidMount(): void {\n    // Add window listeners\n    this._events.on(window, 'mouseup', this._onDismiss, true /* useCapture */);\n    this._events.on(window, 'pointerup', this._onDismiss, true /* useCapture */);\n    this._events.on(window, 'resize', this._onDismiss);\n    this._events.on(window, 'keydown', this._onKeyDown, true /* useCapture */);\n    this._events.on(window, 'keypress', this._onKeyPress, true /* useCapture */);\n    this._events.on(window, 'scroll', this._onDismiss, true /* useCapture */);\n\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n    this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n\n  public getCurrentSequence(): string {\n    return this._currentSequence;\n  }\n\n  public getKeytipTree(): KeytipTree {\n    return this._keytipTree;\n  }\n\n  /**\n   * Processes an IKeytipTransitionKey entered by the user\n   *\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\n   */\n  public processTransitionInput(transitionKey: IKeytipTransitionKey, ev?: React.KeyboardEvent<HTMLElement>): void {\n    const currKtp = this._keytipTree.currentKeytip;\n    if (transitionKeysContain(this.props.keytipExitSequences!, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n      this._exitKeytipMode(ev);\n    } else if (transitionKeysContain(this.props.keytipReturnSequences!, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          }\n\n          // Reset currentSequence\n          this._currentSequence = '';\n          // Return pointer to its parent\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent);\n          // Show children keytips of the new currentKeytip\n          this.showKeytips(this._keytipTree.getChildren());\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (transitionKeysContain(this.props.keytipStartSequences!, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n      this._enterKeytipMode();\n      this._warnIfDuplicateKeytips();\n    }\n  }\n\n  /**\n   * Processes inputs from the document listener and traverse the keytip tree\n   *\n   * @param key - Key pressed by the user\n   */\n  public processInput(key: string, ev?: React.KeyboardEvent<HTMLElement>): void {\n    // Concat the input key with the current sequence\n    const currSequence: string = this._currentSequence + key;\n    let currKtp = this._keytipTree.currentKeytip;\n\n    // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n    if (currKtp) {\n      const node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n        const currKtpChildren = this._keytipTree.getChildren();\n\n        // Execute this node's onExecute if defined\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          // Reset currKtp, this might have changed from the onExecute\n          currKtp = this._keytipTree.currentKeytip;\n        }\n\n        // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n          this._warnIfDuplicateKeytips();\n        }\n\n        // Clear currentSequence\n        this._currentSequence = '';\n        return;\n      }\n\n      const partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        const ids = partialNodes\n          .filter((partialNode: IKeytipTreeNode) => {\n            return !partialNode.persisted;\n          })\n          .map((partialNode: IKeytipTreeNode) => {\n            return partialNode.id;\n          });\n        this.showKeytips(ids);\n\n        // Save currentSequence\n        this._currentSequence = currSequence;\n      }\n    }\n  }\n\n  /**\n   * Show the given keytips and hide all others\n   *\n   * @param ids - Keytip IDs to show\n   */\n  public showKeytips(ids: string[]): void {\n    // Update the visible prop in the manager\n    for (const keytip of this._keytipManager.getKeytips()) {\n      const keytipId = sequencesToID(keytip.keySequences);\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else if (\n        keytip.overflowSetSequence &&\n        ids.indexOf(sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence))) >= 0\n      ) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    }\n    // Apply the manager changes to the Layer state\n    this._setKeytips();\n  }\n\n  /**\n   * Enters keytip mode for this layer\n   */\n  private _enterKeytipMode(): void {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      if (this._keytipManager.delayUpdatingKeytipChange) {\n        this._buildTree();\n        this._setKeytips();\n      }\n      this._keytipTree.currentKeytip = this._keytipTree.root;\n      // Show children of root\n      this.showKeytips(this._keytipTree.getChildren());\n\n      this._setInKeytipMode(true /* inKeytipMode */);\n\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode();\n      }\n    }\n  }\n\n  private _buildTree(): void {\n    this._keytipTree = new KeytipTree();\n    // Add regular and persisted keytips to the tree\n    for (const id of Object.keys(this._keytipManager.keytips)) {\n      const uniqueKeytip = this._keytipManager.keytips[id];\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n\n    for (const id of Object.keys(this._keytipManager.persistedKeytips)) {\n      const uniqueKeytip = this._keytipManager.persistedKeytips[id];\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n  }\n\n  /**\n   * Exits keytip mode for this layer\n   */\n  private _exitKeytipMode(ev?: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = '';\n    // Hide all keytips\n    this.showKeytips([]);\n\n    // Reset the delayed keytips if any\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n\n    this._setInKeytipMode(false /* inKeytipMode */);\n\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  }\n\n  /**\n   * Sets the keytips state property\n   *\n   * @param keytipProps - Keytips to set in this layer\n   */\n  private _setKeytips(keytipProps: IKeytipProps[] = this._keytipManager.getKeytips()) {\n    this.setState({ keytips: keytipProps, visibleKeytips: this._getVisibleKeytips(keytipProps) });\n  }\n\n  /**\n   * Callback function to use for persisted keytips\n   *\n   * @param overflowButtonSequences - The overflow button sequence to execute\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\n   */\n  private _persistedKeytipExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences;\n\n    // Execute the overflow button's onExecute\n    const overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(\n        this._getKtpExecuteTarget(overflowKeytipNode),\n        this._getKtpTarget(overflowKeytipNode),\n      );\n    }\n  }\n\n  private _getVisibleKeytips(keytips: IKeytipProps[]): IKeytipProps[] {\n    // Filter out non-visible keytips and duplicates\n    const seenIds: { [childSequence: string]: number } = {};\n    return keytips.filter(keytip => {\n      const keytipId = sequencesToID(keytip.keySequences);\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      return keytip.visible && seenIds[keytipId] === 1;\n    });\n  }\n\n  private _onDismiss = (ev?: React.MouseEvent<HTMLElement>): void => {\n    // if we are in keytip mode, then exit keytip mode\n    if (this.state.inKeytipMode) {\n      this._exitKeytipMode(ev);\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._keyHandled = false;\n    // using key since which has been deprecated and key is now widely suporrted.\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n    let key = ev.key;\n    switch (key) {\n      case 'Tab':\n      case 'Enter':\n      case 'Spacebar':\n      case ' ':\n      case 'ArrowUp':\n      case 'Up':\n      case 'ArrowDown':\n      case 'Down':\n      case 'ArrowLeft':\n      case 'Left':\n      case 'ArrowRight':\n      case 'Right':\n        if (this.state.inKeytipMode) {\n          this._keyHandled = true;\n          this._exitKeytipMode(ev);\n        }\n        break;\n      default:\n        // Special cases for browser-specific keys that are not at standard\n        // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n        if (key === 'Esc') {\n          // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n          key = 'Escape';\n        } else if (key === 'OS' || key === 'Win') {\n          // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n          // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n          // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n          key = 'Meta';\n        }\n        const transitionKey: IKeytipTransitionKey = { key };\n        transitionKey.modifierKeys = this._getModifierKey(key, ev);\n        this.processTransitionInput(transitionKey, ev);\n        break;\n    }\n  };\n\n  /**\n   * Gets the ModifierKeyCodes based on the keyboard event\n   *\n   * @param ev - React.KeyboardEvent\n   * @returns List of ModifierKeyCodes that were pressed\n   */\n  private _getModifierKey(key: string, ev: React.KeyboardEvent<HTMLElement>): KeytipTransitionModifier[] | undefined {\n    const modifierKeys: KeytipTransitionModifier[] = [];\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(KeyCodes.alt);\n    }\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(KeyCodes.ctrl);\n    }\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(KeyCodes.shift);\n    }\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(KeyCodes.leftWindow);\n    }\n    return modifierKeys.length ? modifierKeys : undefined;\n  }\n\n  private _onKeyPress = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.state.inKeytipMode && !this._keyHandled) {\n      // Call processInput\n      this.processInput(ev.key.toLocaleLowerCase(), ev);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  private _onKeytipAdded = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n\n    this._keytipTree.addNode(keytipProps, uniqueID);\n    this._setKeytips();\n\n    // Add the keytip to the queue to show later\n    if (this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n      // Ensure existing children are still shown.\n      this._delayedKeytipQueue = this._delayedKeytipQueue.concat(this._keytipTree.currentKeytip?.children || []);\n\n      this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n\n      // Ensure the child of currentKeytip is successfully added to currentKeytip's children and update it if not.\n      // Note: Added this condition because KeytipTree.addNode was not always reflecting updates made to a parent node\n      // in currentKeytip when that parent is the currentKeytip.\n      if (\n        this._keytipTree.currentKeytip &&\n        this._keytipTree.currentKeytip.hasDynamicChildren &&\n        this._keytipTree.currentKeytip.children.indexOf(keytipProps.id) < 0\n      ) {\n        const currNode = this._keytipTree.getNode(this._keytipTree.currentKeytip.id);\n        if (currNode) {\n          this._keytipTree.currentKeytip = currNode;\n        }\n      }\n    }\n\n    if (this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, this._newCurrentKeytipSequences)) {\n      this._triggerKeytipImmediately(keytipProps);\n    }\n\n    if (this._isCurrentKeytipAnAlias(keytipProps)) {\n      let keytipSequence = keytipProps.keySequences;\n      if (keytipProps.overflowSetSequence) {\n        keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n      }\n      this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    }\n  };\n\n  private _onKeytipUpdated = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.updateNode(keytipProps, uniqueID);\n    this._setKeytips();\n    if (this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n      this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n    }\n  };\n\n  private _onKeytipRemoved = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n\n    // Remove keytip from the delayed queue\n    this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences));\n\n    // Remove the node from the Tree\n    this._keytipTree.removeNode(keytipProps, uniqueID);\n    this._setKeytips();\n  };\n\n  private _onPersistedKeytipAdded = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.addNode(keytipProps, uniqueID, true);\n  };\n\n  private _onPersistedKeytipRemoved = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.removeNode(keytipProps, uniqueID);\n  };\n\n  private _onPersistedKeytipExecute = (eventArgs: any) => {\n    this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n  };\n\n  /**\n   * Trigger a keytip immediately and set it as the current keytip\n   *\n   * @param keytipProps - Keytip to trigger immediately\n   */\n  private _triggerKeytipImmediately(keytipProps: IKeytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    let keytipSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    }\n\n    // Set currentKeytip\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      const children = this._keytipTree.getChildren();\n      if (children.length) {\n        this.showKeytips(children);\n      }\n\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(\n          this._getKtpExecuteTarget(this._keytipTree.currentKeytip),\n          this._getKtpTarget(this._keytipTree.currentKeytip),\n        );\n      }\n    }\n\n    // Unset _newCurrKtpSequences\n    this._newCurrentKeytipSequences = undefined;\n  }\n\n  private _addKeytipToQueue(keytipID: string) {\n    // Add keytip\n    this._delayedKeytipQueue.push(keytipID);\n    // Clear timeout\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    // Reset timeout\n    this._delayedQueueTimeout = this._async.setTimeout(() => {\n      if (this._delayedKeytipQueue.length) {\n        this.showKeytips(this._delayedKeytipQueue);\n        this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  }\n\n  private _removeKeytipFromQueue(keytipID: string) {\n    const index = this._delayedKeytipQueue.indexOf(keytipID);\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1);\n      // Clear timeout\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n      // Reset timeout\n      this._delayedQueueTimeout = this._async.setTimeout(() => {\n        if (this._delayedKeytipQueue.length) {\n          this.showKeytips(this._delayedKeytipQueue);\n          this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  }\n\n  private _getKtpExecuteTarget(currKtp: IKeytipTreeNode): HTMLElement | null {\n    return getDocument()!.querySelector(ktpTargetFromId(currKtp.id));\n  }\n\n  private _getKtpTarget(currKtp: IKeytipTreeNode): HTMLElement | null {\n    return getDocument()!.querySelector(ktpTargetFromSequences(currKtp.keySequences));\n  }\n\n  /**\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\n   * This will make 'keytipProps' the new currentKeytip\n   *\n   * @param keytipProps - Keytip props to check\n   * @returns - T/F if this keytip should become the currentKeytip\n   */\n  private _isCurrentKeytipAnAlias(keytipProps: IKeytipProps): boolean {\n    const currKtp = this._keytipTree.currentKeytip;\n    if (\n      currKtp &&\n      (currKtp.overflowSetSequence || currKtp.persisted) &&\n      arraysEqual(keytipProps.keySequences, currKtp.keySequences)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Sets if we are in keytip mode.\n   * Note, this sets both the state for the layer as well as\n   * the value that the manager will expose externally.\n   * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\n   */\n  private _setInKeytipMode = (inKeytipMode: boolean): void => {\n    this.setState({ inKeytipMode: inKeytipMode });\n    this._keytipManager.inKeytipMode = inKeytipMode;\n  };\n\n  /**\n   * Emits a warning if duplicate keytips are found for the children of the current keytip\n   */\n  private _warnIfDuplicateKeytips = (): void => {\n    const duplicateKeytips = this._getDuplicateIds(this._keytipTree.getChildren());\n    if (duplicateKeytips.length) {\n      warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n    }\n  };\n\n  /**\n   * Returns duplicates among keytip IDs.\n   * If the returned array is empty, no duplicates were found.\n   *\n   * @param keytipIds - Array of keytip IDs to find duplicates for\n   * @returns - Array of duplicates that were found. Each duplicate will only be added once to this array.\n   */\n  private _getDuplicateIds = (keytipIds: string[]): string[] => {\n    const seenIds: { [id: string]: number } = {};\n    return keytipIds.filter(keytipId => {\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      // Only add the first duplicate keytip seen\n      return seenIds[keytipId] === 2;\n    });\n  };\n}\n"]},"metadata":{},"sourceType":"module"}