{"ast":null,"code":"import { arraysEqual } from './array';\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\n\nvar createResolver = function (local) {\n  return function (newValue) {\n    for (var _i = 0, _a = local.refs; _i < _a.length; _i++) {\n      var ref = _a[_i];\n\n      if (typeof ref === 'function') {\n        ref(newValue);\n      } else if (ref) {\n        // work around the immutability of the React.Ref type\n        ref.current = newValue;\n      }\n    }\n  };\n};\n/**\n * Helper to merge refs from within class components.\n */\n\n\nexport var createMergedRef = function (value) {\n  var local = {\n    refs: []\n  };\n  return function () {\n    var newRefs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newRefs[_i] = arguments[_i];\n    }\n\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver(local);\n    }\n\n    local.refs = newRefs;\n    return local.resolver;\n  };\n};","map":{"version":3,"mappings":"AACA,SAASA,WAAT,QAA4B,SAA5B;AAUA;;;;;AAIA,IAAMC,cAAc,GAAG,UAAgBC,KAAhB,EAAgD;AAAK,mBAACC,QAAD,EAAgC;AAC1G,SAAkB,sBAAK,CAACC,IAAxB,EAAkBC,cAAlB,EAAkBA,IAAlB,EAA8B;AAAzB,UAAMC,GAAG,SAAT;;AACH,UAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7BA,WAAG,CAACH,QAAD,CAAH;AACD,OAFD,MAEO,IAAIG,GAAJ,EAAS;AACd;AACEA,WAA6E,CAACC,OAA9E,GAAwFJ,QAAxF;AACH;AACF;AACF,GAT2E;AAS3E,CATD;AAWA;;;;;AAGA,OAAO,IAAMK,eAAe,GAAG,UAAuBC,KAAvB,EAAqC;AAClE,MAAMP,KAAK,GAA8B;AACvCE,QAAI,EAAE;AADiC,GAAzC;AAIA,SAAO;AACL;;SAAA,yCAA4D;AAA5DM;;;AAEA,QAAI,CAACR,KAAK,CAACS,QAAP,IAAmB,CAACX,WAAW,CAACE,KAAK,CAACE,IAAP,EAAaM,OAAb,CAAnC,EAA0D;AACxDR,WAAK,CAACS,QAAN,GAAiBV,cAAc,CAAgBC,KAAhB,CAA/B;AACD;;AAEDA,SAAK,CAACE,IAAN,GAAaM,OAAb;AAEA,WAAOR,KAAK,CAACS,QAAb;AACD,GAVD;AAWD,CAhBM","names":["arraysEqual","createResolver","local","newValue","refs","_i","ref","current","createMergedRef","value","newRefs","resolver"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\src\\createMergedRef.ts"],"sourcesContent":["import * as React from 'react';\nimport { arraysEqual } from './array';\n\n/**\n * Internal state type for the ref.\n */\ntype LocalState<TType, TValue> = {\n  refs: (React.Ref<TType | null | TValue> | undefined)[];\n  resolver?: (newValue: TType | TValue | null) => void;\n};\n\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\nconst createResolver = <TType, TValue>(local: LocalState<TType, TValue>) => (newValue: TType | TValue | null) => {\n  for (const ref of local.refs) {\n    if (typeof ref === 'function') {\n      ref(newValue);\n    } else if (ref) {\n      // work around the immutability of the React.Ref type\n      ((ref as unknown) as React.MutableRefObject<TType | TValue | null | undefined>).current = newValue;\n    }\n  }\n};\n\n/**\n * Helper to merge refs from within class components.\n */\nexport const createMergedRef = <TType, TValue = null>(value?: TValue) => {\n  const local: LocalState<TType, TValue> = {\n    refs: [] as LocalState<TType, TValue>['refs'],\n  };\n\n  return (\n    ...newRefs: (React.Ref<TType | null | TValue> | undefined)[]\n  ): ((newValue: TType | TValue | null) => void) => {\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver<TType, TValue>(local);\n    }\n\n    local.refs = newRefs;\n\n    return local.resolver!;\n  };\n};\n"]},"metadata":{},"sourceType":"module"}