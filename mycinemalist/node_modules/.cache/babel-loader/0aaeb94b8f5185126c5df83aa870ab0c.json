{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, classNamesFunction, findIndex, KeyCodes, getId, warnMutuallyExclusive, warnConditionallyRequiredProps } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { memoizeFunction, warnDeprecations } from '@uifabric/utilities';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\n\nvar SwatchColorPickerBase =\n/** @class */\nfunction (_super) {\n  __extends(SwatchColorPickerBase, _super);\n\n  function SwatchColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.navigationIdleDelay = 250\n    /* ms */\n    ; // Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n\n    _this._getItemsWithIndex = memoizeFunction(function (items) {\n      return items.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      });\n    });\n\n    _this._onRenderItem = function (item, index) {\n      var _a = _this.props.onRenderColorCell,\n          onRenderColorCell = _a === void 0 ? _this._renderOption : _a;\n      return onRenderColorCell(item, _this._renderOption);\n    };\n    /**\n     * When the whole swatchColorPicker is blurred,\n     * make sure to clear the pending focused stated\n     */\n\n\n    _this._onSwatchColorPickerBlur = function () {\n      if (_this.props.onCellFocused) {\n        _this._cellFocused = false;\n\n        _this.props.onCellFocused();\n      }\n    };\n    /**\n     * Render a color cell\n     * @param item - The item to render\n     * @returns - Element representing the item\n     */\n\n\n    _this._renderOption = function (item) {\n      var props = _this.props;\n      var id = _this._id;\n      return React.createElement(ColorPickerGridCell, {\n        item: item,\n        idPrefix: id,\n        color: item.color,\n        styles: props.getColorGridCellStyles,\n        disabled: props.disabled,\n        onClick: _this._onCellClick,\n        onHover: _this._onGridCellHovered,\n        onFocus: _this._onGridCellFocused,\n        selected: _this.state.selectedIndex !== undefined && _this.state.selectedIndex === item.index,\n        circle: props.cellShape === 'circle',\n        label: item.label,\n        onMouseEnter: _this._onMouseEnter,\n        onMouseMove: _this._onMouseMove,\n        onMouseLeave: _this._onMouseLeave,\n        onWheel: _this._onWheel,\n        onKeyDown: _this._onKeyDown,\n        height: props.cellHeight,\n        width: props.cellWidth,\n        borderWidth: props.cellBorderWidth\n      });\n    };\n    /**\n     * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n     */\n\n\n    _this._onMouseEnter = function (ev) {\n      if (!_this.props.focusOnHover) {\n        return !_this.isNavigationIdle || !!_this.props.disabled;\n      }\n\n      if (_this.isNavigationIdle && !_this.props.disabled) {\n        ev.currentTarget.focus();\n      }\n\n      return true;\n    };\n    /**\n     * Callback passed to the GridCell that will manage Hover/Focus updates\n     */\n\n\n    _this._onMouseMove = function (ev) {\n      if (!_this.props.focusOnHover) {\n        return !_this.isNavigationIdle || !!_this.props.disabled;\n      }\n\n      var targetElement = ev.currentTarget; // If navigation is idle and the targetElement is the focused element bail out\n      // if (!this.isNavigationIdle || (document && targetElement === (document.activeElement as HTMLElement))) {\n\n      if (_this.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n        targetElement.focus();\n      }\n\n      return true;\n    };\n    /**\n     * Callback passed to the GridCell that will manage Hover/Focus updates\n     */\n\n\n    _this._onMouseLeave = function (ev) {\n      var parentSelector = _this.props.mouseLeaveParentSelector;\n\n      if (!_this.props.focusOnHover || !parentSelector || !_this.isNavigationIdle || _this.props.disabled) {\n        return;\n      } // Get the elements that math the given selector\n\n\n      var elements = document.querySelectorAll(parentSelector); // iterate over the elements return to make sure it is a parent of the target and focus it\n\n      for (var index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if (elements[index].setActive) {\n            try {\n              elements[index].setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            elements[index].focus();\n          }\n\n          break;\n        }\n      }\n    };\n    /**\n     * Callback to make sure we don't update the hovered element during mouse wheel\n     */\n\n\n    _this._onWheel = function () {\n      _this._setNavigationTimeout();\n    };\n    /**\n     * Callback that\n     */\n\n\n    _this._onKeyDown = function (ev) {\n      if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.left || ev.which === KeyCodes.right) {\n        _this._setNavigationTimeout();\n      }\n    };\n    /**\n     * Sets a timeout so we won't process any mouse \"hover\" events\n     * while navigating (via mouseWheel or arrowKeys)\n     */\n\n\n    _this._setNavigationTimeout = function () {\n      if (!_this.isNavigationIdle && _this.navigationIdleTimeoutId !== undefined) {\n        _this.async.clearTimeout(_this.navigationIdleTimeoutId);\n\n        _this.navigationIdleTimeoutId = undefined;\n      } else {\n        _this.isNavigationIdle = false;\n      }\n\n      _this.navigationIdleTimeoutId = _this.async.setTimeout(function () {\n        _this.isNavigationIdle = true;\n      }, _this.navigationIdleDelay);\n    };\n    /**\n     * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n     * NOTE: This will not be triggered if shouldFocusOnHover === true\n     */\n\n\n    _this._onGridCellHovered = function (item) {\n      var onCellHovered = _this.props.onCellHovered;\n\n      if (onCellHovered) {\n        return item ? onCellHovered(item.id, item.color) : onCellHovered();\n      }\n    };\n    /**\n     * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n     */\n\n\n    _this._onGridCellFocused = function (item) {\n      var onCellFocused = _this.props.onCellFocused;\n\n      if (onCellFocused) {\n        if (item) {\n          _this._cellFocused = true;\n          return onCellFocused(item.id, item.color);\n        } else {\n          _this._cellFocused = false;\n          return onCellFocused();\n        }\n      }\n    };\n    /**\n     * Handle the click on a cell\n     * @param item - The cell that the click was fired against\n     */\n\n\n    _this._onCellClick = function (item) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      var index = item.index; // If we have a valid index and it is not already\n      // selected, select it\n\n      if (index >= 0 && index !== _this.state.selectedIndex) {\n        if (_this.props.onCellFocused && _this._cellFocused) {\n          _this._cellFocused = false;\n\n          _this.props.onCellFocused();\n        }\n\n        if (_this.props.onColorChanged) {\n          _this.props.onColorChanged(item.id, item.color);\n        } // Update internal state only if the component is uncontrolled\n\n\n        if (_this.props.isControlled !== true) {\n          _this.setState({\n            selectedIndex: index\n          });\n        }\n      }\n    };\n\n    _this._id = props.id || getId('swatchColorPicker');\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnMutuallyExclusive(COMPONENT_NAME, props, {\n        focusOnHover: 'onHover'\n      });\n      warnConditionallyRequiredProps(COMPONENT_NAME, props, ['focusOnHover'], 'mouseLeaveParentSelector', !!props.mouseLeaveParentSelector);\n      warnDeprecations(COMPONENT_NAME, props, {\n        positionInSet: 'ariaPosInSet',\n        setSize: 'ariaSetSize'\n      });\n    }\n\n    _this.isNavigationIdle = true;\n    _this.async = new Async(_this);\n    var selectedIndex;\n\n    if (props.selectedId) {\n      selectedIndex = _this._getSelectedIndex(props.colorCells, props.selectedId);\n    }\n\n    _this.state = {\n      selectedIndex: selectedIndex\n    };\n    return _this;\n  }\n\n  SwatchColorPickerBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.selectedId !== undefined) {\n      this.setState({\n        selectedIndex: this._getSelectedIndex(newProps.colorCells, newProps.selectedId)\n      });\n    }\n  };\n\n  SwatchColorPickerBase.prototype.componentWillUnmount = function () {\n    if (this.props.onCellFocused && this._cellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n\n    this.async.dispose();\n  };\n\n  SwatchColorPickerBase.prototype.render = function () {\n    var _a = this.props,\n        colorCells = _a.colorCells,\n        columnCount = _a.columnCount,\n\n    /* eslint-disable deprecation/deprecation */\n    _b = _a.ariaPosInSet,\n\n    /* eslint-disable deprecation/deprecation */\n    ariaPosInSet = _b === void 0 ? this.props.positionInSet : _b,\n        _c = _a.ariaSetSize,\n        ariaSetSize = _c === void 0 ? this.props.setSize : _c,\n\n    /* eslint-enable deprecation/deprecation */\n    shouldFocusCircularNavigate = _a.shouldFocusCircularNavigate,\n        className = _a.className,\n        doNotContainWithinFocusZone = _a.doNotContainWithinFocusZone,\n        styles = _a.styles,\n        cellMargin = _a.cellMargin;\n    var classNames = getClassNames(styles, {\n      theme: this.props.theme,\n      className: className,\n      cellMargin: cellMargin\n    });\n\n    if (colorCells.length < 1 || columnCount < 1) {\n      return null;\n    }\n\n    return React.createElement(ButtonGrid, __assign({}, this.props, {\n      id: this._id,\n      items: this._getItemsWithIndex(colorCells),\n      columnCount: columnCount,\n      onRenderItem: this._onRenderItem,\n      ariaPosInSet: ariaPosInSet,\n      ariaSetSize: ariaSetSize,\n      shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n      doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n      onBlur: this._onSwatchColorPickerBlur,\n      theme: this.props.theme,\n      styles: {\n        root: classNames.root,\n        tableCell: classNames.tableCell,\n        focusedContainer: classNames.focusedContainer\n      }\n    }));\n  };\n  /**\n   * Get the selected item's index\n   * @param items - The items to search\n   * @param selectedId - The selected item's id to find\n   * @returns - The index of the selected item's id, -1 if there was no match\n   */\n\n\n  SwatchColorPickerBase.prototype._getSelectedIndex = function (items, selectedId) {\n    var selectedIndex = findIndex(items, function (item) {\n      return item.id === selectedId;\n    });\n    return selectedIndex >= 0 ? selectedIndex : undefined;\n  };\n\n  SwatchColorPickerBase.defaultProps = {\n    cellShape: 'circle',\n    disabled: false,\n    shouldFocusCircularNavigate: true,\n    cellMargin: 10\n  };\n  return SwatchColorPickerBase;\n}(React.Component);\n\nexport { SwatchColorPickerBase };","map":{"version":3,"mappings":"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","names":["React","Async","classNamesFunction","findIndex","KeyCodes","getId","warnMutuallyExclusive","warnConditionallyRequiredProps","ButtonGrid","ColorPickerGridCell","memoizeFunction","warnDeprecations","getClassNames","COMPONENT_NAME","__extends","props","_super","_this","items","map","item","index","onRenderColorCell","_renderOption","onCellFocused","_cellFocused","id","_id","idPrefix","color","styles","getColorGridCellStyles","disabled","onClick","_onCellClick","onHover","_onGridCellHovered","onFocus","_onGridCellFocused","selected","state","selectedIndex","undefined","circle","cellShape","label","onMouseEnter","_onMouseEnter","onMouseMove","_onMouseMove","onMouseLeave","_onMouseLeave","onWheel","_onWheel","onKeyDown","_onKeyDown","height","cellHeight","width","cellWidth","borderWidth","cellBorderWidth","ev","focusOnHover","isNavigationIdle","currentTarget","focus","targetElement","document","activeElement","parentSelector","mouseLeaveParentSelector","elements","querySelectorAll","length","contains","setActive","e","_setNavigationTimeout","which","up","down","left","right","navigationIdleTimeoutId","async","clearTimeout","setTimeout","navigationIdleDelay","onCellHovered","onColorChanged","isControlled","setState","process","env","NODE_ENV","positionInSet","setSize","selectedId","_getSelectedIndex","colorCells","SwatchColorPickerBase","newProps","dispose","columnCount","_b","ariaPosInSet","_c","ariaSetSize","shouldFocusCircularNavigate","className","doNotContainWithinFocusZone","cellMargin","classNames","theme","__assign","_getItemsWithIndex","onRenderItem","_onRenderItem","onBlur","_onSwatchColorPickerBlur","root","tableCell","focusedContainer","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\SwatchColorPicker\\SwatchColorPicker.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  classNamesFunction,\n  findIndex,\n  KeyCodes,\n  getId,\n  warnMutuallyExclusive,\n  warnConditionallyRequiredProps,\n} from '../../Utilities';\nimport {\n  ISwatchColorPickerProps,\n  ISwatchColorPickerStyleProps,\n  ISwatchColorPickerStyles,\n} from './SwatchColorPicker.types';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { IColorCellProps } from './ColorPickerGridCell.types';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { memoizeFunction, warnDeprecations } from '@uifabric/utilities';\n\nexport interface ISwatchColorPickerState {\n  selectedIndex?: number;\n}\n\nconst getClassNames = classNamesFunction<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>();\n\nconst COMPONENT_NAME = 'SwatchColorPicker';\n\nexport class SwatchColorPickerBase extends React.Component<ISwatchColorPickerProps, ISwatchColorPickerState> {\n  public static defaultProps = {\n    cellShape: 'circle',\n    disabled: false,\n    shouldFocusCircularNavigate: true,\n    cellMargin: 10,\n  } as ISwatchColorPickerProps;\n\n  private _id: string;\n  private _cellFocused: boolean;\n\n  private navigationIdleTimeoutId: number | undefined;\n  private isNavigationIdle: boolean;\n  private readonly navigationIdleDelay: number = 250 /* ms */;\n  private async: Async;\n\n  // Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n  private _getItemsWithIndex = memoizeFunction((items: IColorCellProps[]) => {\n    return items.map((item, index) => {\n      return { ...item, index: index };\n    });\n  });\n\n  constructor(props: ISwatchColorPickerProps) {\n    super(props);\n\n    this._id = props.id || getId('swatchColorPicker');\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnMutuallyExclusive(COMPONENT_NAME, props, {\n        focusOnHover: 'onHover',\n      });\n\n      warnConditionallyRequiredProps(\n        COMPONENT_NAME,\n        props,\n        ['focusOnHover'],\n        'mouseLeaveParentSelector',\n        !!props.mouseLeaveParentSelector,\n      );\n\n      warnDeprecations(COMPONENT_NAME, props, {\n        positionInSet: 'ariaPosInSet',\n        setSize: 'ariaSetSize',\n      });\n    }\n\n    this.isNavigationIdle = true;\n    this.async = new Async(this);\n\n    let selectedIndex: number | undefined;\n    if (props.selectedId) {\n      selectedIndex = this._getSelectedIndex(props.colorCells, props.selectedId);\n    }\n\n    this.state = {\n      selectedIndex,\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: ISwatchColorPickerProps): void {\n    if (newProps.selectedId !== undefined) {\n      this.setState({\n        selectedIndex: this._getSelectedIndex(newProps.colorCells, newProps.selectedId),\n      });\n    }\n  }\n\n  public componentWillUnmount() {\n    if (this.props.onCellFocused && this._cellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n    this.async.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    const {\n      colorCells,\n      columnCount,\n      /* eslint-disable deprecation/deprecation */\n      ariaPosInSet = this.props.positionInSet,\n      ariaSetSize = this.props.setSize,\n      /* eslint-enable deprecation/deprecation */\n      shouldFocusCircularNavigate,\n      className,\n      doNotContainWithinFocusZone,\n      styles,\n      cellMargin,\n    } = this.props;\n\n    const classNames = getClassNames(styles!, {\n      theme: this.props.theme!,\n      className,\n      cellMargin,\n    });\n\n    if (colorCells.length < 1 || columnCount < 1) {\n      return null;\n    }\n    return (\n      <ButtonGrid\n        {...this.props}\n        id={this._id}\n        items={this._getItemsWithIndex(colorCells)}\n        columnCount={columnCount}\n        onRenderItem={this._onRenderItem}\n        ariaPosInSet={ariaPosInSet}\n        ariaSetSize={ariaSetSize}\n        shouldFocusCircularNavigate={shouldFocusCircularNavigate}\n        doNotContainWithinFocusZone={doNotContainWithinFocusZone}\n        onBlur={this._onSwatchColorPickerBlur}\n        theme={this.props.theme!}\n        styles={{\n          root: classNames.root,\n          tableCell: classNames.tableCell,\n          focusedContainer: classNames.focusedContainer,\n        }}\n      />\n    );\n  }\n\n  private _onRenderItem = (item: IColorCellProps, index: number): JSX.Element => {\n    const { onRenderColorCell = this._renderOption } = this.props;\n    return onRenderColorCell(item, this._renderOption) as JSX.Element;\n  };\n\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  private _onSwatchColorPickerBlur = (): void => {\n    if (this.props.onCellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n  };\n\n  /**\n   * Get the selected item's index\n   * @param items - The items to search\n   * @param selectedId - The selected item's id to find\n   * @returns - The index of the selected item's id, -1 if there was no match\n   */\n  private _getSelectedIndex(items: IColorCellProps[], selectedId: string): number | undefined {\n    const selectedIndex = findIndex(items, item => item.id === selectedId);\n    return selectedIndex >= 0 ? selectedIndex : undefined;\n  }\n\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  private _renderOption = (item: IColorCellProps): JSX.Element => {\n    const props = this.props;\n    const id = this._id;\n\n    return (\n      <ColorPickerGridCell\n        item={item}\n        idPrefix={id}\n        color={item.color}\n        styles={props.getColorGridCellStyles}\n        disabled={props.disabled}\n        onClick={this._onCellClick}\n        onHover={this._onGridCellHovered}\n        onFocus={this._onGridCellFocused}\n        selected={this.state.selectedIndex !== undefined && this.state.selectedIndex === item.index}\n        circle={props.cellShape === 'circle'}\n        label={item.label}\n        onMouseEnter={this._onMouseEnter}\n        onMouseMove={this._onMouseMove}\n        onMouseLeave={this._onMouseLeave}\n        onWheel={this._onWheel}\n        onKeyDown={this._onKeyDown}\n        height={props.cellHeight}\n        width={props.cellWidth}\n        borderWidth={props.cellBorderWidth}\n      />\n    );\n  };\n\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  private _onMouseEnter = (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n    if (!this.props.focusOnHover) {\n      return !this.isNavigationIdle || !!this.props.disabled;\n    }\n\n    if (this.isNavigationIdle && !this.props.disabled) {\n      ev.currentTarget.focus();\n    }\n\n    return true;\n  };\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  private _onMouseMove = (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n    if (!this.props.focusOnHover) {\n      return !this.isNavigationIdle || !!this.props.disabled;\n    }\n\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // If navigation is idle and the targetElement is the focused element bail out\n    // if (!this.isNavigationIdle || (document && targetElement === (document.activeElement as HTMLElement))) {\n    if (this.isNavigationIdle && !(document && targetElement === (document.activeElement as HTMLElement))) {\n      targetElement.focus();\n    }\n\n    return true;\n  };\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  private _onMouseLeave = (ev: React.MouseEvent<HTMLButtonElement>): void => {\n    const parentSelector = this.props.mouseLeaveParentSelector;\n\n    if (!this.props.focusOnHover || !parentSelector || !this.isNavigationIdle || this.props.disabled) {\n      return;\n    }\n\n    // Get the elements that math the given selector\n    const elements = document.querySelectorAll(parentSelector);\n\n    // iterate over the elements return to make sure it is a parent of the target and focus it\n    for (let index = 0; index < elements.length; index += 1) {\n      if (elements[index].contains(ev.currentTarget)) {\n        /**\n         * IE11 focus() method forces parents to scroll to top of element.\n         * Edge and IE expose a setActive() function for focusable divs that\n         * sets the page focus but does not scroll the parent element.\n         */\n        if ((elements[index] as any).setActive) {\n          try {\n            (elements[index] as any).setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          (elements[index] as HTMLElement).focus();\n        }\n\n        break;\n      }\n    }\n  };\n\n  /**\n   * Callback to make sure we don't update the hovered element during mouse wheel\n   */\n  private _onWheel = (): void => {\n    this._setNavigationTimeout();\n  };\n\n  /**\n   * Callback that\n   */\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLButtonElement>): void => {\n    if (\n      ev.which === KeyCodes.up ||\n      ev.which === KeyCodes.down ||\n      ev.which === KeyCodes.left ||\n      ev.which === KeyCodes.right\n    ) {\n      this._setNavigationTimeout();\n    }\n  };\n\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  private _setNavigationTimeout = () => {\n    if (!this.isNavigationIdle && this.navigationIdleTimeoutId !== undefined) {\n      this.async.clearTimeout(this.navigationIdleTimeoutId);\n      this.navigationIdleTimeoutId = undefined;\n    } else {\n      this.isNavigationIdle = false;\n    }\n\n    this.navigationIdleTimeoutId = this.async.setTimeout(() => {\n      this.isNavigationIdle = true;\n    }, this.navigationIdleDelay);\n  };\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  private _onGridCellHovered = (item?: IColorCellProps): void => {\n    const { onCellHovered } = this.props;\n\n    if (onCellHovered) {\n      return item ? onCellHovered(item.id, item.color) : onCellHovered();\n    }\n  };\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  private _onGridCellFocused = (item?: IColorCellProps): void => {\n    const { onCellFocused } = this.props;\n    if (onCellFocused) {\n      if (item) {\n        this._cellFocused = true;\n        return onCellFocused(item.id, item.color);\n      } else {\n        this._cellFocused = false;\n        return onCellFocused();\n      }\n    }\n  };\n\n  /**\n   * Handle the click on a cell\n   * @param item - The cell that the click was fired against\n   */\n  private _onCellClick = (item: IColorCellProps): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const index = item.index as number;\n\n    // If we have a valid index and it is not already\n    // selected, select it\n    if (index >= 0 && index !== this.state.selectedIndex) {\n      if (this.props.onCellFocused && this._cellFocused) {\n        this._cellFocused = false;\n        this.props.onCellFocused();\n      }\n\n      if (this.props.onColorChanged) {\n        this.props.onColorChanged(item.id, item.color);\n      }\n\n      // Update internal state only if the component is uncontrolled\n      if (this.props.isControlled !== true) {\n        this.setState({\n          selectedIndex: index,\n        });\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}