{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nvar getClassNames = classNamesFunction();\nvar KEY_PREFIX = 'fabricImage';\n\nvar ImageBase =\n/** @class */\nfunction (_super) {\n  __extends(ImageBase, _super);\n\n  function ImageBase(props) {\n    var _this = _super.call(this, props) || this; // Make an initial assumption about the image layout until we can\n    // check the rendered element. The value here only takes effect when\n    // shouldStartVisible is true.\n\n\n    _this._coverStyle = ImageCoverStyle.portrait;\n    _this._imageElement = React.createRef();\n    _this._frameElement = React.createRef();\n\n    _this._onImageLoaded = function (ev) {\n      var _a = _this.props,\n          src = _a.src,\n          onLoad = _a.onLoad;\n\n      if (onLoad) {\n        onLoad(ev);\n      }\n\n      _this._computeCoverStyle(_this.props);\n\n      if (src) {\n        _this.setState({\n          loadState: ImageLoadState.loaded\n        });\n      }\n    };\n\n    _this._onImageError = function (ev) {\n      if (_this.props.onError) {\n        _this.props.onError(ev);\n      }\n\n      _this.setState({\n        loadState: ImageLoadState.error\n      });\n    };\n\n    _this.state = {\n      loadState: ImageLoadState.notLoaded\n    };\n    return _this;\n  }\n\n  ImageBase.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    if (nextProps.src !== this.props.src) {\n      this.setState({\n        loadState: ImageLoadState.notLoaded\n      });\n    } else if (this.state.loadState === ImageLoadState.loaded) {\n      this._computeCoverStyle(nextProps);\n    }\n  };\n\n  ImageBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this._checkImageLoaded();\n\n    if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {\n      this.props.onLoadingStateChange(this.state.loadState);\n    }\n  };\n\n  ImageBase.prototype.render = function () {\n    var imageProps = getNativeProps(this.props, imgProperties, ['width', 'height']);\n    var _a = this.props,\n        src = _a.src,\n        alt = _a.alt,\n        width = _a.width,\n        height = _a.height,\n        shouldFadeIn = _a.shouldFadeIn,\n        shouldStartVisible = _a.shouldStartVisible,\n        className = _a.className,\n        imageFit = _a.imageFit,\n        role = _a.role,\n        maximizeFrame = _a.maximizeFrame,\n        styles = _a.styles,\n        theme = _a.theme;\n    var loadState = this.state.loadState;\n    var coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      width: width,\n      height: height,\n      maximizeFrame: maximizeFrame,\n      shouldFadeIn: shouldFadeIn,\n      shouldStartVisible: shouldStartVisible,\n      isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && this.props.shouldStartVisible,\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined\n    }); // If image dimensions aren't specified, the natural size of the image is used.\n\n    return React.createElement(\"div\", {\n      className: classNames.root,\n      style: {\n        width: width,\n        height: height\n      },\n      ref: this._frameElement\n    }, React.createElement(\"img\", __assign({}, imageProps, {\n      onLoad: this._onImageLoaded,\n      onError: this._onImageError,\n      key: KEY_PREFIX + this.props.src || '',\n      className: classNames.image,\n      ref: this._imageElement,\n      src: src,\n      alt: alt,\n      role: role\n    })));\n  };\n\n  ImageBase.prototype._checkImageLoaded = function () {\n    var src = this.props.src;\n    var loadState = this.state.loadState;\n\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      var isLoaded = this._imageElement.current ? src && this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0 || this._imageElement.current.complete && ImageBase._svgRegex.test(src) : false;\n\n      if (isLoaded) {\n        this._computeCoverStyle(this.props);\n\n        this.setState({\n          loadState: ImageLoadState.loaded\n        });\n      }\n    }\n  };\n\n  ImageBase.prototype._computeCoverStyle = function (props) {\n    var imageFit = props.imageFit,\n        width = props.width,\n        height = props.height; // Do not compute cover style if it was already specified in props\n\n    if ((imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && this.props.coverStyle === undefined && this._imageElement.current && this._frameElement.current) {\n      // Determine the desired ratio using the width and height props.\n      // If those props aren't available, measure measure the frame.\n      var desiredRatio = void 0;\n\n      if (typeof width === 'number' && typeof height === 'number' && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {\n        desiredRatio = width / height;\n      } else {\n        desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;\n      } // Examine the source image to determine its original ratio.\n\n\n      var naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight; // Should we crop from the top or the sides?\n\n      if (naturalRatio > desiredRatio) {\n        this._coverStyle = ImageCoverStyle.landscape;\n      } else {\n        this._coverStyle = ImageCoverStyle.portrait;\n      }\n    }\n  };\n\n  ImageBase.defaultProps = {\n    shouldFadeIn: true\n  };\n  ImageBase._svgRegex = /\\.svg$/i;\n  return ImageBase;\n}(React.Component);\n\nexport { ImageBase };","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","getNativeProps","imgProperties","ImageCoverStyle","ImageFit","ImageLoadState","getClassNames","KEY_PREFIX","__extends","props","_super","_this","portrait","createRef","ev","src","onLoad","_computeCoverStyle","setState","loadState","loaded","onError","error","state","notLoaded","ImageBase","nextProps","prevProps","prevState","_checkImageLoaded","onLoadingStateChange","imageProps","alt","width","height","shouldFadeIn","shouldStartVisible","className","imageFit","role","maximizeFrame","styles","theme","coverStyle","undefined","_coverStyle","classNames","isLoaded","isLandscape","landscape","isCenter","center","isCenterContain","centerContain","isCenterCover","centerCover","isContain","contain","isCover","cover","isNone","none","isError","isNotImageFit","root","style","ref","_frameElement","_onImageLoaded","_onImageError","key","image","_imageElement","current","naturalWidth","naturalHeight","complete","_svgRegex","test","desiredRatio","clientWidth","clientHeight","naturalRatio","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\Image\\Image.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { IImageProps, IImageStyleProps, IImageStyles, ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\n\nconst getClassNames = classNamesFunction<IImageStyleProps, IImageStyles>();\n\nexport interface IImageState {\n  loadState?: ImageLoadState;\n}\n\nconst KEY_PREFIX = 'fabricImage';\n\nexport class ImageBase extends React.Component<IImageProps, IImageState> {\n  public static defaultProps = {\n    shouldFadeIn: true,\n  };\n\n  private static _svgRegex = /\\.svg$/i;\n\n  // Make an initial assumption about the image layout until we can\n  // check the rendered element. The value here only takes effect when\n  // shouldStartVisible is true.\n  private _coverStyle: ImageCoverStyle = ImageCoverStyle.portrait;\n  private _imageElement = React.createRef<HTMLImageElement>();\n  private _frameElement = React.createRef<HTMLDivElement>();\n\n  constructor(props: IImageProps) {\n    super(props);\n\n    this.state = {\n      loadState: ImageLoadState.notLoaded,\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IImageProps): void {\n    if (nextProps.src !== this.props.src) {\n      this.setState({\n        loadState: ImageLoadState.notLoaded,\n      });\n    } else if (this.state.loadState === ImageLoadState.loaded) {\n      this._computeCoverStyle(nextProps);\n    }\n  }\n\n  public componentDidUpdate(prevProps: IImageProps, prevState: IImageState) {\n    this._checkImageLoaded();\n    if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {\n      this.props.onLoadingStateChange(this.state.loadState!);\n    }\n  }\n\n  public render(): JSX.Element {\n    const imageProps = getNativeProps<React.ImgHTMLAttributes<HTMLImageElement>>(this.props, imgProperties, [\n      'width',\n      'height',\n    ]);\n    const {\n      src,\n      alt,\n      width,\n      height,\n      shouldFadeIn,\n      shouldStartVisible,\n      className,\n      imageFit,\n      role,\n      maximizeFrame,\n      styles,\n      theme,\n    } = this.props;\n    const { loadState } = this.state;\n    const coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      width,\n      height,\n      maximizeFrame,\n      shouldFadeIn,\n      shouldStartVisible,\n      isLoaded:\n        loadState === ImageLoadState.loaded ||\n        (loadState === ImageLoadState.notLoaded && this.props.shouldStartVisible),\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined,\n    });\n\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return (\n      <div className={classNames.root} style={{ width: width, height: height }} ref={this._frameElement}>\n        <img\n          {...imageProps}\n          onLoad={this._onImageLoaded}\n          onError={this._onImageError}\n          key={KEY_PREFIX + this.props.src || ''}\n          className={classNames.image}\n          ref={this._imageElement}\n          src={src}\n          alt={alt}\n          role={role}\n        />\n      </div>\n    );\n  }\n\n  private _onImageLoaded = (ev: React.SyntheticEvent<HTMLImageElement>): void => {\n    const { src, onLoad } = this.props;\n    if (onLoad) {\n      onLoad(ev);\n    }\n\n    this._computeCoverStyle(this.props);\n\n    if (src) {\n      this.setState({\n        loadState: ImageLoadState.loaded,\n      });\n    }\n  };\n\n  private _checkImageLoaded(): void {\n    const { src } = this.props;\n    const { loadState } = this.state;\n\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      const isLoaded: boolean = this._imageElement.current\n        ? (src && this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0) ||\n          (this._imageElement.current.complete && ImageBase._svgRegex.test(src!))\n        : false;\n\n      if (isLoaded) {\n        this._computeCoverStyle(this.props);\n        this.setState({\n          loadState: ImageLoadState.loaded,\n        });\n      }\n    }\n  }\n\n  private _computeCoverStyle(props: IImageProps): void {\n    const { imageFit, width, height } = props;\n\n    // Do not compute cover style if it was already specified in props\n    if (\n      (imageFit === ImageFit.cover ||\n        imageFit === ImageFit.contain ||\n        imageFit === ImageFit.centerContain ||\n        imageFit === ImageFit.centerCover) &&\n      this.props.coverStyle === undefined &&\n      this._imageElement.current &&\n      this._frameElement.current\n    ) {\n      // Determine the desired ratio using the width and height props.\n      // If those props aren't available, measure measure the frame.\n      let desiredRatio;\n      if (\n        typeof width === 'number' &&\n        typeof height === 'number' &&\n        imageFit !== ImageFit.centerContain &&\n        imageFit !== ImageFit.centerCover\n      ) {\n        desiredRatio = width / height;\n      } else {\n        desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;\n      }\n\n      // Examine the source image to determine its original ratio.\n      const naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight;\n\n      // Should we crop from the top or the sides?\n      if (naturalRatio > desiredRatio) {\n        this._coverStyle = ImageCoverStyle.landscape;\n      } else {\n        this._coverStyle = ImageCoverStyle.portrait;\n      }\n    }\n  }\n\n  private _onImageError = (ev: React.SyntheticEvent<HTMLImageElement>): void => {\n    if (this.props.onError) {\n      this.props.onError(ev);\n    }\n    this.setState({\n      loadState: ImageLoadState.error,\n    });\n  };\n}\n"]},"metadata":{},"sourceType":"module"}