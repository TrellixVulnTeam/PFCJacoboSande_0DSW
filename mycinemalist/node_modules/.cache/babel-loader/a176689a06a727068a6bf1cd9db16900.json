{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { anchorProperties, assign, buttonProperties, getId, getNativeProps, KeyCodes, css, mergeAriaAttributeValues, portalContainsElement, memoizeFunction, nullRender, warnConditionallyRequiredProps, warnDeprecations, EventGroup, initializeComponentRef, Async, FocusRects } from '../../Utilities';\nimport { createMergedRef } from '@uifabric/utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getSplitButtonClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nvar TouchIdleDelay = 500;\n/* ms */\n\nvar COMPONENT_NAME = 'BaseButton';\n/**\n * {@docCategory Button}\n */\n\nvar BaseButton =\n/** @class */\nfunction (_super) {\n  __extends(BaseButton, _super);\n\n  function BaseButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._buttonElement = React.createRef();\n    _this._splitButtonContainer = React.createRef();\n    _this._mergedRef = createMergedRef();\n    _this._renderedVisibleMenu = false;\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return __assign(__assign({}, keytipProps), {\n        hasMenu: true\n      });\n    });\n\n    _this._onRenderIcon = function (buttonProps, defaultRender) {\n      var iconProps = _this.props.iconProps;\n\n      if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n        var className = iconProps.className,\n            imageProps = iconProps.imageProps,\n            rest = __rest(iconProps, [\"className\", \"imageProps\"]); // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n        // do not have this prop.\n\n\n        if (iconProps.styles) {\n          return React.createElement(Icon, __assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n\n        if (iconProps.iconName) {\n          return React.createElement(FontIcon, __assign({\n            className: css(_this._classNames.icon, className)\n          }, rest));\n        }\n\n        if (imageProps) {\n          return React.createElement(ImageIcon, __assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n      }\n\n      return null;\n    };\n\n    _this._onRenderTextContents = function () {\n      var _a = _this.props,\n          text = _a.text,\n          children = _a.children,\n          // eslint-disable-next-line deprecation/deprecation\n      _b = _a.secondaryText,\n          // eslint-disable-next-line deprecation/deprecation\n      secondaryText = _b === void 0 ? _this.props.description : _b,\n          _c = _a.onRenderText,\n          onRenderText = _c === void 0 ? _this._onRenderText : _c,\n          _d = _a.onRenderDescription,\n          onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;\n\n      if (text || typeof children === 'string' || secondaryText) {\n        return React.createElement(\"span\", {\n          className: _this._classNames.textContainer\n        }, onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription));\n      }\n\n      return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];\n    };\n\n    _this._onRenderText = function () {\n      var text = _this.props.text;\n      var children = _this.props.children; // For backwards compat, we should continue to take in the text content from children.\n\n      if (text === undefined && typeof children === 'string') {\n        text = children;\n      }\n\n      if (_this._hasText()) {\n        return React.createElement(\"span\", {\n          key: _this._labelId,\n          className: _this._classNames.label,\n          id: _this._labelId\n        }, text);\n      }\n\n      return null;\n    };\n\n    _this._onRenderChildren = function () {\n      var children = _this.props.children; // If children is just a string, either it or the text will be rendered via onRenderLabel\n      // If children is another component, it will be rendered after text\n\n      if (typeof children === 'string') {\n        return null;\n      }\n\n      return children;\n    };\n\n    _this._onRenderDescription = function (props) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = props.secondaryText,\n          secondaryText = _a === void 0 ? _this.props.description : _a; // ms-Button-description is only shown when the button type is compound.\n      // In other cases it will not be displayed.\n\n      return secondaryText ? React.createElement(\"span\", {\n        key: _this._descriptionId,\n        className: _this._classNames.description,\n        id: _this._descriptionId\n      }, secondaryText) : null;\n    };\n\n    _this._onRenderAriaDescription = function () {\n      var ariaDescription = _this.props.ariaDescription; // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n      // otherwise it will be assigned to descriptionSpan.\n\n      return ariaDescription ? React.createElement(\"span\", {\n        className: _this._classNames.screenReaderText,\n        id: _this._ariaDescriptionId\n      }, ariaDescription) : null;\n    };\n\n    _this._onRenderMenuIcon = function (props) {\n      var menuIconProps = _this.props.menuIconProps;\n      return React.createElement(FontIcon, __assign({\n        iconName: \"ChevronDown\"\n      }, menuIconProps, {\n        className: _this._classNames.menuIcon\n      }));\n    };\n\n    _this._onRenderMenu = function (menuProps) {\n      var persistMenu = _this.props.persistMenu;\n      var menuHidden = _this.state.menuHidden;\n      var MenuType = _this.props.menuAs || ContextualMenu; // the accessible menu label (accessible name) has a relationship to the button.\n      // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n      // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n\n      if (!menuProps.ariaLabel && !menuProps.labelElementId && _this._hasText()) {\n        menuProps = __assign(__assign({}, menuProps), {\n          labelElementId: _this._labelId\n        });\n      }\n\n      return React.createElement(MenuType, __assign({\n        id: _this._labelId + '-menu',\n        directionalHint: DirectionalHint.bottomLeftEdge\n      }, menuProps, {\n        shouldFocusOnContainer: _this._menuShouldFocusOnContainer,\n        shouldFocusOnMount: _this._menuShouldFocusOnMount,\n        hidden: persistMenu ? menuHidden : undefined,\n        className: css('ms-BaseButton-menuhost', menuProps.className),\n        target: _this._isSplitButton ? _this._splitButtonContainer.current : _this._buttonElement.current,\n        onDismiss: _this._onDismissMenu\n      }));\n    };\n\n    _this._onDismissMenu = function (ev) {\n      var menuProps = _this.props.menuProps;\n\n      if (menuProps && menuProps.onDismiss) {\n        menuProps.onDismiss(ev);\n      }\n\n      if (!ev || !ev.defaultPrevented) {\n        _this._dismissMenu();\n      }\n    };\n\n    _this._dismissMenu = function () {\n      _this._menuShouldFocusOnMount = undefined;\n      _this._menuShouldFocusOnContainer = undefined;\n\n      _this.setState({\n        menuHidden: true\n      });\n    };\n\n    _this._openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n      if (shouldFocusOnMount === void 0) {\n        shouldFocusOnMount = true;\n      }\n\n      if (_this.props.menuProps) {\n        _this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n        _this._menuShouldFocusOnMount = shouldFocusOnMount;\n        _this._renderedVisibleMenu = true;\n\n        _this.setState({\n          menuHidden: false\n        });\n      }\n    };\n\n    _this._onToggleMenu = function (shouldFocusOnContainer) {\n      var shouldFocusOnMount = true;\n\n      if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {\n        shouldFocusOnMount = false;\n      }\n\n      _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();\n    };\n\n    _this._onSplitContainerFocusCapture = function (ev) {\n      var container = _this._splitButtonContainer.current; // If the target is coming from the portal we do not need to set focus on the container.\n\n      if (!container || ev.target && portalContainsElement(ev.target, container)) {\n        return;\n      } // We should never be able to focus the individual buttons in a split button. Focus\n      // should always remain on the container.\n\n\n      container.focus();\n    };\n\n    _this._onSplitButtonPrimaryClick = function (ev) {\n      if (!_this.state.menuHidden) {\n        _this._dismissMenu();\n      }\n\n      if (!_this._processingTouch && _this.props.onClick) {\n        _this.props.onClick(ev);\n      } else if (_this._processingTouch) {\n        _this._onMenuClick(ev);\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      // explicity cancelling event so click won't fire after this\n      if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      } else if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuKeyDown(ev);\n        } else if (_this.props.onKeyDown !== undefined) {\n          _this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n\n        }\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyUp !== undefined) {\n        _this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyPress !== undefined) {\n        _this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onMouseUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseUp !== undefined) {\n        _this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onMouseDown = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseDown !== undefined) {\n        _this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onClick = function (ev) {\n      if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuClick(ev);\n        } else if (_this.props.onClick !== undefined) {\n          _this.props.onClick(ev); // not cancelling event because it's not disabled\n\n        }\n      }\n    };\n\n    _this._onSplitButtonContainerKeyDown = function (ev) {\n      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n        if (_this._buttonElement.current) {\n          _this._buttonElement.current.click();\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      } else {\n        _this._onMenuKeyDown(ev);\n      }\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {\n        var onMenuClick = _this.props.onMenuClick;\n\n        if (onMenuClick) {\n          onMenuClick(ev, _this.props);\n        }\n\n        _this._onToggleMenu(false);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n        // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n        // We need to re-render the menu with shouldFocusOnMount as true.\n        if (!_this.state.menuHidden && _this.props.menuProps) {\n          var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== undefined ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;\n\n          if (!currentShouldFocusOnMount) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            _this._menuShouldFocusOnMount = true;\n\n            _this.forceUpdate();\n          }\n        }\n      }\n    };\n\n    _this._onTouchStart = function () {\n      if (_this._isSplitButton && _this._splitButtonContainer.current && !('onpointerdown' in _this._splitButtonContainer.current)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n\n    _this._onMenuClick = function (ev) {\n      var onMenuClick = _this.props.onMenuClick;\n\n      if (onMenuClick) {\n        onMenuClick(ev, _this.props);\n      }\n\n      if (!ev.defaultPrevented) {\n        // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n        // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n        // between a real click event and a keypress event (detail should be the number of mouse clicks).\n        // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n        // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n        // and \"\" for pressing \"Enter\" with Narrator on.\n        var shouldFocusOnContainer = ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse';\n\n        _this._onToggleMenu(shouldFocusOnContainer);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', _this.props.split);\n    warnDeprecations(COMPONENT_NAME, props, {\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked'\n    });\n    _this._labelId = getId();\n    _this._descriptionId = getId();\n    _this._ariaDescriptionId = getId();\n    _this.state = {\n      menuHidden: true\n    };\n    return _this;\n  }\n\n  Object.defineProperty(BaseButton.prototype, \"_isSplitButton\", {\n    get: function () {\n      return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseButton.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        ariaDescription = _b.ariaDescription,\n        ariaLabel = _b.ariaLabel,\n        ariaHidden = _b.ariaHidden,\n        className = _b.className,\n        disabled = _b.disabled,\n        allowDisabledFocus = _b.allowDisabledFocus,\n        primaryDisabled = _b.primaryDisabled,\n        // eslint-disable-next-line deprecation/deprecation\n    _c = _b.secondaryText,\n        // eslint-disable-next-line deprecation/deprecation\n    secondaryText = _c === void 0 ? this.props.description : _c,\n        href = _b.href,\n        iconProps = _b.iconProps,\n        menuIconProps = _b.menuIconProps,\n        styles = _b.styles,\n        checked = _b.checked,\n        variantClassName = _b.variantClassName,\n        theme = _b.theme,\n        toggle = _b.toggle,\n        getClassNames = _b.getClassNames,\n        role = _b.role;\n    var menuHidden = this.state.menuHidden; // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n\n    var isPrimaryButtonDisabled = disabled || primaryDisabled;\n    this._classNames = getClassNames ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);\n\n    var _d = this,\n        _ariaDescriptionId = _d._ariaDescriptionId,\n        _labelId = _d._labelId,\n        _descriptionId = _d._descriptionId; // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n\n\n    var renderAsAnchor = !isPrimaryButtonDisabled && !!href;\n    var tag = renderAsAnchor ? 'a' : 'button';\n    var nativeProps = getNativeProps( // eslint-disable-next-line deprecation/deprecation\n    assign(renderAsAnchor ? {} : {\n      type: 'button'\n    }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, ['disabled']); // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n\n    var resolvedAriaLabel = ariaLabel || nativeProps['aria-label']; // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n    // aria-describedby. Otherwise default to undefined so property does not appear in output.\n\n    var ariaDescribedBy = undefined;\n\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if (nativeProps['aria-describedby']) {\n      ariaDescribedBy = nativeProps['aria-describedby'];\n    } // If an explicit ariaLabel is given, use that as the label and we're done.\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute),\n    // set the labelledby element. Otherwise, the button is labeled implicitly by the descendent\n    // text on the button (if it exists). Never set both aria-label and aria-labelledby.\n\n\n    var ariaLabelledBy = undefined;\n\n    if (!resolvedAriaLabel) {\n      if (nativeProps['aria-labelledby']) {\n        ariaLabelledBy = nativeProps['aria-labelledby'];\n      } else if (ariaDescribedBy) {\n        ariaLabelledBy = this._hasText() ? _labelId : undefined;\n      }\n    }\n\n    var dataIsFocusable = this.props['data-is-focusable'] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;\n    var isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox'; // if isCheckboxTypeRole, always return a checked value.\n    // Otherwise only return checked value if toggle is set to true.\n    // This is because role=\"checkbox\" always needs to have an aria-checked value\n    // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n\n    var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n    var buttonProps = assign(nativeProps, (_a = {\n      className: this._classNames.root,\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable\n    }, // aria-pressed attribute should only be present for toggle buttons\n    // aria-checked attribute should only be present for toggle buttons with checkbox type role\n    _a[isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed'] = checkedOrPressedValue, _a));\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      assign(buttonProps, {\n        'aria-expanded': !menuHidden,\n        'aria-owns': !menuHidden ? this._labelId + '-menu' : null,\n        'aria-haspopup': true\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  };\n\n  BaseButton.prototype.componentDidMount = function () {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n    // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n    // because React does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      if ('onpointerdown' in this._splitButtonContainer.current) {\n        this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n      }\n\n      if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n        this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n      }\n    }\n  };\n\n  BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // If Button's menu was closed, run onAfterMenuDismiss.\n    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n      this.props.onAfterMenuDismiss();\n    }\n  };\n\n  BaseButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  BaseButton.prototype.focus = function () {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      this._buttonElement.current.focus();\n    }\n  };\n\n  BaseButton.prototype.dismissMenu = function () {\n    this._dismissMenu();\n  };\n\n  BaseButton.prototype.openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  };\n\n  BaseButton.prototype._onRenderContent = function (tag, buttonProps) {\n    var _this = this;\n\n    var props = this.props;\n    var Tag = tag;\n    var menuIconProps = props.menuIconProps,\n        menuProps = props.menuProps,\n        _a = props.onRenderIcon,\n        onRenderIcon = _a === void 0 ? this._onRenderIcon : _a,\n        _b = props.onRenderAriaDescription,\n        onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b,\n        _c = props.onRenderChildren,\n        onRenderChildren = _c === void 0 ? this._onRenderChildren : _c,\n        // eslint-disable-next-line deprecation/deprecation\n    _d = props.onRenderMenu,\n        // eslint-disable-next-line deprecation/deprecation\n    onRenderMenu = _d === void 0 ? this._onRenderMenu : _d,\n        _e = props.onRenderMenuIcon,\n        onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e,\n        disabled = props.disabled;\n    var keytipProps = props.keytipProps;\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    var Button = function (keytipAttributes) {\n      return React.createElement(Tag, __assign({}, buttonProps, keytipAttributes), React.createElement(\"span\", {\n        className: _this._classNames.flexContainer,\n        \"data-automationid\": \"splitbuttonprimary\"\n      }, onRenderIcon(props, _this._onRenderIcon), _this._onRenderTextContents(), onRenderAriaDescription(props, _this._onRenderAriaDescription), onRenderChildren(props, _this._onRenderChildren), !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon), menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(menuProps, _this._onRenderMenu)));\n    };\n\n    var Content = keytipProps ? // If we're making a split button, we won't put the keytip here\n    React.createElement(KeytipData, {\n      keytipProps: !this._isSplitButton ? keytipProps : undefined,\n      ariaDescribedBy: buttonProps['aria-describedby'],\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return Button(keytipAttributes);\n    }) : Button();\n\n    if (menuProps && menuProps.doNotLayer) {\n      return React.createElement(\"span\", {\n        style: {\n          display: 'inline-block'\n        }\n      }, Content, this._shouldRenderMenu() && onRenderMenu(menuProps, this._onRenderMenu));\n    }\n\n    return React.createElement(React.Fragment, null, Content, React.createElement(FocusRects, null));\n  };\n  /**\n   * Method to help determine if the menu's component tree should\n   * be rendered. It takes into account whether the menu is expanded,\n   * whether it is a persisted menu and whether it has been shown to the user.\n   */\n\n\n  BaseButton.prototype._shouldRenderMenu = function () {\n    var menuHidden = this.state.menuHidden; // eslint-disable-next-line deprecation/deprecation\n\n    var _a = this.props,\n        persistMenu = _a.persistMenu,\n        renderPersistedMenuHiddenOnMount = _a.renderPersistedMenuHiddenOnMount;\n\n    if (!menuHidden) {\n      // Always should render a menu when it is expanded\n      return true;\n    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n      // _renderedVisibleMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n      return true;\n    }\n\n    return false;\n  };\n\n  BaseButton.prototype._hasText = function () {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n    // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n    // text to be undefined in order for props.children to be used as a fallback.\n    // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  };\n\n  BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {\n    var _this = this;\n\n    var _a = this.props,\n        _b = _a.styles,\n        styles = _b === void 0 ? {} : _b,\n        disabled = _a.disabled,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        checked = _a.checked,\n        getSplitButtonClassNames = _a.getSplitButtonClassNames,\n        primaryDisabled = _a.primaryDisabled,\n        menuProps = _a.menuProps,\n        toggle = _a.toggle,\n        role = _a.role,\n        primaryActionButtonProps = _a.primaryActionButtonProps;\n    var keytipProps = this.props.keytipProps;\n    var menuHidden = this.state.menuHidden;\n    var classNames = getSplitButtonClassNames ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getBaseSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n    assign(buttonProps, {\n      onClick: undefined,\n      onPointerDown: undefined,\n      onPointerUp: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false\n    });\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    var containerProps = getNativeProps(buttonProps, [], ['disabled']); // Add additional props to apply on primary action button\n\n    if (primaryActionButtonProps) {\n      assign(buttonProps, primaryActionButtonProps);\n    }\n\n    var SplitButton = function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, containerProps, {\n        \"data-ktp-target\": keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined,\n        role: role ? role : 'button',\n        \"aria-disabled\": disabled,\n        \"aria-haspopup\": true,\n        \"aria-expanded\": !menuHidden,\n        \"aria-pressed\": toggle ? !!checked : undefined,\n        \"aria-describedby\": mergeAriaAttributeValues(buttonProps['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined),\n        className: classNames && classNames.splitButtonContainer,\n        onKeyDown: _this._onSplitButtonContainerKeyDown,\n        onTouchStart: _this._onTouchStart,\n        ref: _this._splitButtonContainer,\n        \"data-is-focusable\": true,\n        onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : undefined,\n        tabIndex: !disabled || allowDisabledFocus ? 0 : undefined,\n        \"aria-roledescription\": buttonProps['aria-roledescription'],\n        onFocusCapture: _this._onSplitContainerFocusCapture\n      }), React.createElement(\"span\", {\n        style: {\n          display: 'flex'\n        }\n      }, _this._onRenderContent(tag, buttonProps), _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes), _this._onRenderSplitButtonDivider(classNames)));\n    };\n\n    return keytipProps ? React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return SplitButton(keytipAttributes);\n    }) : SplitButton();\n  };\n\n  BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {\n    if (classNames && classNames.divider) {\n      var onClick = function (ev) {\n        ev.stopPropagation();\n      };\n\n      return React.createElement(\"span\", {\n        className: classNames.divider,\n        \"aria-hidden\": true,\n        onClick: onClick\n      });\n    }\n\n    return null;\n  };\n\n  BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames, keytipAttributes) {\n    var _a = this.props,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        checked = _a.checked,\n        disabled = _a.disabled,\n        splitButtonMenuProps = _a.splitButtonMenuProps,\n        splitButtonAriaLabel = _a.splitButtonAriaLabel;\n    var menuHidden = this.state.menuHidden;\n    var menuIconProps = this.props.menuIconProps;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown'\n      };\n    }\n\n    var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), {\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: __assign(__assign({}, menuIconProps), {\n        className: this._classNames.menuIcon\n      }),\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': !menuHidden,\n      'data-is-focusable': false\n    }); // Add data-ktp-execute-target to the split button if the keytip is defined\n\n\n    return React.createElement(BaseButton, __assign({}, splitButtonProps, {\n      \"data-ktp-execute-target\": keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes,\n      onMouseDown: this._onMouseDown,\n      tabIndex: -1\n    }));\n  };\n\n  BaseButton.prototype._onPointerDown = function (ev) {\n    var onPointerDown = this.props.onPointerDown;\n\n    if (onPointerDown) {\n      onPointerDown(ev);\n    }\n\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  BaseButton.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this; // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a new one.\n\n\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined; // Touch and pointer events don't focus the button naturally,\n      // so adding an imperative focus call to guarantee this behavior.\n\n      _this.focus();\n    }, TouchIdleDelay);\n  };\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n\n\n  BaseButton.prototype._isValidMenuOpenKey = function (ev) {\n    if (this.props.menuTriggerKeyCode) {\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    } // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n\n\n    return false;\n  };\n\n  BaseButton.defaultProps = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false\n  };\n  return BaseButton;\n}(React.Component);\n\nexport { BaseButton };","map":{"version":3,"mappings":"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","names":["React","anchorProperties","assign","buttonProperties","getId","getNativeProps","KeyCodes","css","mergeAriaAttributeValues","portalContainsElement","memoizeFunction","nullRender","warnConditionallyRequiredProps","warnDeprecations","EventGroup","initializeComponentRef","Async","FocusRects","createMergedRef","Icon","FontIcon","ImageIcon","DirectionalHint","ContextualMenu","getBaseButtonClassNames","getSplitButtonClassNames","getBaseSplitButtonClassNames","KeytipData","TouchIdleDelay","COMPONENT_NAME","__extends","props","_super","_this","createRef","keytipProps","hasMenu","buttonProps","defaultRender","iconProps","iconName","undefined","imageProps","rest","styles","__assign","className","_classNames","icon","text","children","_b","secondaryText","_c","onRenderText","_d","onRenderDescription","textContainer","_onRenderText","_onRenderDescription","_hasText","key","_labelId","label","id","_descriptionId","description","ariaDescription","screenReaderText","_ariaDescriptionId","menuIconProps","menuIcon","menuProps","MenuType","menuAs","ariaLabel","labelElementId","directionalHint","bottomLeftEdge","shouldFocusOnContainer","_menuShouldFocusOnContainer","shouldFocusOnMount","_menuShouldFocusOnMount","hidden","persistMenu","menuHidden","target","_isSplitButton","_splitButtonContainer","current","_buttonElement","onDismiss","_onDismissMenu","ev","defaultPrevented","_dismissMenu","setState","_renderedVisibleMenu","state","_openMenu","container","focus","_processingTouch","onClick","_onMenuClick","disabled","which","enter","space","preventDefault","stopPropagation","_onMenuKeyDown","onKeyDown","onKeyUp","onKeyPress","onMouseUp","onMouseDown","click","isUp","up","isDown","down","_isValidMenuOpenKey","onMenuClick","_onToggleMenu","altKey","metaKey","currentShouldFocusOnMount","forceUpdate","_handleTouchAndPointerEvent","nativeEvent","detail","pointerType","_async","_events","split","rootProps","toggled","Object","BaseButton","ariaHidden","allowDisabledFocus","primaryDisabled","href","checked","variantClassName","theme","toggle","getClassNames","role","isPrimaryButtonDisabled","renderAsAnchor","tag","nativeProps","type","resolvedAriaLabel","ariaDescribedBy","ariaLabelledBy","dataIsFocusable","isCheckboxTypeRole","checkedOrPressedValue","_a","root","ref","_mergedRef","elementRef","_onKeyDown","_onKeyPress","_onKeyUp","_onMouseDown","_onMouseUp","_onClick","_onRenderSplitButtonContent","_onRenderContent","on","_onPointerDown","onPointerUp","prevProps","prevState","onAfterMenuDismiss","dispose","Tag","onRenderIcon","onRenderAriaDescription","onRenderChildren","onRenderMenu","_e","onRenderMenuIcon","_getMemoizedMenuButtonKeytipProps","Button","keytipAttributes","flexContainer","_onRenderIcon","_onRenderTextContents","_onRenderAriaDescription","_onRenderChildren","_onRenderMenuIcon","doNotLayer","_shouldRenderMenu","_onRenderMenu","Content","style","display","renderPersistedMenuHiddenOnMount","primaryActionButtonProps","classNames","onPointerDown","tabIndex","containerProps","SplitButton","splitButtonContainer","_onSplitButtonContainerKeyDown","onTouchStart","_onTouchStart","_onSplitButtonPrimaryClick","onFocusCapture","_onSplitContainerFocusCapture","_onRenderSplitButtonMenuButton","_onRenderSplitButtonDivider","divider","splitButtonMenuProps","splitButtonAriaLabel","splitButtonProps","stopImmediatePropagation","_lastTouchTimeoutId","clearTimeout","setTimeout","menuTriggerKeyCode","baseClassName","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\Button\\BaseButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  IRenderFunction,\n  anchorProperties,\n  assign,\n  buttonProperties,\n  getId,\n  getNativeProps,\n  KeyCodes,\n  css,\n  mergeAriaAttributeValues,\n  portalContainsElement,\n  memoizeFunction,\n  nullRender,\n  warnConditionallyRequiredProps,\n  warnDeprecations,\n  EventGroup,\n  initializeComponentRef,\n  Async,\n  FocusRects,\n} from '../../Utilities';\nimport { createMergedRef } from '@uifabric/utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu, IContextualMenuProps } from '../../ContextualMenu';\nimport { IButtonProps, IButton } from './Button.types';\nimport { IButtonClassNames, getBaseButtonClassNames } from './BaseButton.classNames';\nimport {\n  getSplitButtonClassNames as getBaseSplitButtonClassNames,\n  ISplitButtonClassNames,\n} from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { IKeytipProps } from '../Keytip/Keytip.types';\n\n/**\n * {@docCategory Button}\n */\nexport interface IBaseButtonProps extends IButtonProps {\n  baseClassName?: string;\n  variantClassName?: string;\n}\n\nexport interface IBaseButtonState {\n  menuHidden: boolean;\n}\n\nconst TouchIdleDelay = 500; /* ms */\nconst COMPONENT_NAME = 'BaseButton';\n\n/**\n * {@docCategory Button}\n */\nexport class BaseButton extends React.Component<IBaseButtonProps, IBaseButtonState> implements IButton {\n  private get _isSplitButton(): boolean {\n    return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n  }\n\n  public static defaultProps: Partial<IBaseButtonProps> = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _buttonElement = React.createRef<HTMLElement>();\n  private _splitButtonContainer = React.createRef<HTMLDivElement>();\n  private _mergedRef = createMergedRef<HTMLElement>();\n  private _labelId: string;\n  private _descriptionId: string;\n  private _ariaDescriptionId: string;\n  private _classNames: IButtonClassNames;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  private _renderedVisibleMenu: boolean = false;\n\n  // These fields will be used to set corresponding props on the menu.\n  private _menuShouldFocusOnContainer: boolean | undefined;\n  private _menuShouldFocusOnMount: boolean | undefined;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true,\n    };\n  });\n\n  constructor(props: IBaseButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', this.props.split!);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked',\n    });\n    this._labelId = getId();\n    this._descriptionId = getId();\n    this._ariaDescriptionId = getId();\n\n    this.state = {\n      menuHidden: true,\n    };\n  }\n\n  public render(): JSX.Element {\n    const {\n      ariaDescription,\n      ariaLabel,\n      ariaHidden,\n      className,\n      disabled,\n      allowDisabledFocus,\n      primaryDisabled,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = this.props.description,\n      href,\n      iconProps,\n      menuIconProps,\n      styles,\n      checked,\n      variantClassName,\n      theme,\n      toggle,\n      getClassNames,\n      role,\n    } = this.props;\n\n    const { menuHidden } = this.state;\n\n    // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n    const isPrimaryButtonDisabled = disabled || primaryDisabled;\n\n    this._classNames = getClassNames\n      ? getClassNames(\n          theme!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          checked!,\n          !menuHidden,\n          !!this.props.menuProps,\n          this.props.split,\n          !!allowDisabledFocus,\n        )\n      : getBaseButtonClassNames(\n          theme!,\n          styles!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          !!this.props.menuProps,\n          checked!,\n          !menuHidden,\n          this.props.split,\n        );\n\n    const { _ariaDescriptionId, _labelId, _descriptionId } = this;\n    // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n    const renderAsAnchor: boolean = !isPrimaryButtonDisabled && !!href;\n    const tag = renderAsAnchor ? 'a' : 'button';\n\n    const nativeProps = getNativeProps(\n      // eslint-disable-next-line deprecation/deprecation\n      assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props),\n      renderAsAnchor ? anchorProperties : buttonProperties,\n      [\n        'disabled', // let disabled buttons be focused and styled as disabled.\n      ],\n    );\n\n    // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n    const resolvedAriaLabel = ariaLabel || (nativeProps as any)['aria-label'];\n\n    // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n    // aria-describedby. Otherwise default to undefined so property does not appear in output.\n    let ariaDescribedBy = undefined;\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if ((nativeProps as any)['aria-describedby']) {\n      ariaDescribedBy = (nativeProps as any)['aria-describedby'];\n    }\n\n    // If an explicit ariaLabel is given, use that as the label and we're done.\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute),\n    // set the labelledby element. Otherwise, the button is labeled implicitly by the descendent\n    // text on the button (if it exists). Never set both aria-label and aria-labelledby.\n    let ariaLabelledBy = undefined;\n    if (!resolvedAriaLabel) {\n      if ((nativeProps as any)['aria-labelledby']) {\n        ariaLabelledBy = (nativeProps as any)['aria-labelledby'];\n      } else if (ariaDescribedBy) {\n        ariaLabelledBy = this._hasText() ? _labelId : undefined;\n      }\n    }\n\n    const dataIsFocusable =\n      (this.props as any)['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton\n        ? false\n        : true;\n\n    const isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox';\n    // if isCheckboxTypeRole, always return a checked value.\n    // Otherwise only return checked value if toggle is set to true.\n    // This is because role=\"checkbox\" always needs to have an aria-checked value\n    // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n    const checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n\n    const buttonProps = assign(nativeProps, {\n      className: this._classNames.root,\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable,\n      // aria-pressed attribute should only be present for toggle buttons\n      // aria-checked attribute should only be present for toggle buttons with checkbox type role\n      [isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed']: checkedOrPressedValue,\n    });\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      assign(buttonProps, {\n        'aria-expanded': !menuHidden,\n        'aria-owns': !menuHidden ? this._labelId + '-menu' : null,\n        'aria-haspopup': true,\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  }\n\n  public componentDidMount() {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n    // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n    // because React does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      if ('onpointerdown' in this._splitButtonContainer.current) {\n        this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n      }\n      if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n        this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IBaseButtonProps, prevState: IBaseButtonState) {\n    // If Button's menu was closed, run onAfterMenuDismiss.\n    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n      this.props.onAfterMenuDismiss();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public focus(): void {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      this._buttonElement.current.focus();\n    }\n  }\n\n  public dismissMenu(): void {\n    this._dismissMenu();\n  }\n\n  public openMenu(shouldFocusOnContainer?: boolean, shouldFocusOnMount?: boolean): void {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  }\n\n  private _onRenderContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const props = this.props;\n    const Tag = tag;\n    const {\n      menuIconProps,\n      menuProps,\n      onRenderIcon = this._onRenderIcon,\n      onRenderAriaDescription = this._onRenderAriaDescription,\n      onRenderChildren = this._onRenderChildren,\n      // eslint-disable-next-line deprecation/deprecation\n      onRenderMenu = this._onRenderMenu,\n      onRenderMenuIcon = this._onRenderMenuIcon,\n      disabled,\n    } = props;\n    let { keytipProps } = props;\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const Button = (keytipAttributes?: any): JSX.Element => (\n      <Tag {...buttonProps} {...keytipAttributes}>\n        <span className={this._classNames.flexContainer} data-automationid=\"splitbuttonprimary\">\n          {onRenderIcon(props, this._onRenderIcon)}\n          {this._onRenderTextContents()}\n          {onRenderAriaDescription(props, this._onRenderAriaDescription)}\n          {onRenderChildren(props, this._onRenderChildren)}\n          {!this._isSplitButton &&\n            (menuProps || menuIconProps || this.props.onRenderMenuIcon) &&\n            onRenderMenuIcon(this.props, this._onRenderMenuIcon)}\n          {menuProps &&\n            !menuProps.doNotLayer &&\n            this._shouldRenderMenu() &&\n            onRenderMenu(menuProps, this._onRenderMenu)}\n        </span>\n      </Tag>\n    );\n\n    const Content = keytipProps ? (\n      // If we're making a split button, we won't put the keytip here\n      <KeytipData\n        keytipProps={!this._isSplitButton ? keytipProps : undefined}\n        ariaDescribedBy={(buttonProps as any)['aria-describedby']}\n        disabled={disabled}\n      >\n        {(keytipAttributes: any): JSX.Element => Button(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      Button()\n    );\n\n    if (menuProps && menuProps.doNotLayer) {\n      return (\n        <span style={{ display: 'inline-block' }}>\n          {Content}\n          {this._shouldRenderMenu() && onRenderMenu(menuProps, this._onRenderMenu)}\n        </span>\n      );\n    }\n\n    return (\n      <>\n        {Content}\n        <FocusRects />\n      </>\n    );\n  }\n\n  /**\n   * Method to help determine if the menu's component tree should\n   * be rendered. It takes into account whether the menu is expanded,\n   * whether it is a persisted menu and whether it has been shown to the user.\n   */\n  private _shouldRenderMenu() {\n    const { menuHidden } = this.state;\n    // eslint-disable-next-line deprecation/deprecation\n    const { persistMenu, renderPersistedMenuHiddenOnMount } = this.props;\n\n    if (!menuHidden) {\n      // Always should render a menu when it is expanded\n      return true;\n    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n      // _renderedVisibleMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n      return true;\n    }\n\n    return false;\n  }\n\n  private _onRenderIcon = (\n    buttonProps?: IButtonProps,\n    defaultRender?: IRenderFunction<IButtonProps>,\n  ): JSX.Element | null => {\n    const { iconProps } = this.props;\n\n    if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n      const { className, imageProps, ...rest } = iconProps;\n\n      // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n      // do not have this prop.\n      if (iconProps.styles) {\n        return <Icon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n      if (iconProps.iconName) {\n        return <FontIcon className={css(this._classNames.icon, className)} {...rest} />;\n      }\n      if (imageProps) {\n        return <ImageIcon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n    }\n    return null;\n  };\n\n  private _onRenderTextContents = (): JSX.Element | (JSX.Element | null)[] => {\n    const {\n      text,\n      children,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = this.props.description,\n      onRenderText = this._onRenderText,\n      onRenderDescription = this._onRenderDescription,\n    } = this.props;\n\n    if (text || typeof children === 'string' || secondaryText) {\n      return (\n        <span className={this._classNames.textContainer}>\n          {onRenderText(this.props, this._onRenderText)}\n          {onRenderDescription(this.props, this._onRenderDescription)}\n        </span>\n      );\n    }\n    return [onRenderText(this.props, this._onRenderText), onRenderDescription(this.props, this._onRenderDescription)];\n  };\n\n  private _onRenderText = (): JSX.Element | null => {\n    let { text } = this.props;\n    const { children } = this.props;\n\n    // For backwards compat, we should continue to take in the text content from children.\n    if (text === undefined && typeof children === 'string') {\n      text = children;\n    }\n\n    if (this._hasText()) {\n      return (\n        <span key={this._labelId} className={this._classNames.label} id={this._labelId}>\n          {text}\n        </span>\n      );\n    }\n\n    return null;\n  };\n\n  private _hasText(): boolean {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n    // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n    // text to be undefined in order for props.children to be used as a fallback.\n    // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  }\n\n  private _onRenderChildren = (): JSX.Element | null => {\n    const { children } = this.props;\n\n    // If children is just a string, either it or the text will be rendered via onRenderLabel\n    // If children is another component, it will be rendered after text\n    if (typeof children === 'string') {\n      return null;\n    }\n\n    return children as any;\n  };\n\n  private _onRenderDescription = (props: IButtonProps) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { secondaryText = this.props.description } = props;\n\n    // ms-Button-description is only shown when the button type is compound.\n    // In other cases it will not be displayed.\n    return secondaryText ? (\n      <span key={this._descriptionId} className={this._classNames.description} id={this._descriptionId}>\n        {secondaryText}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderAriaDescription = () => {\n    const { ariaDescription } = this.props;\n\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n    // otherwise it will be assigned to descriptionSpan.\n    return ariaDescription ? (\n      <span className={this._classNames.screenReaderText} id={this._ariaDescriptionId}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderMenuIcon = (props: IButtonProps): JSX.Element | null => {\n    const { menuIconProps } = this.props;\n\n    return <FontIcon iconName=\"ChevronDown\" {...menuIconProps} className={this._classNames.menuIcon} />;\n  };\n\n  private _onRenderMenu = (menuProps: IContextualMenuProps): JSX.Element => {\n    const { persistMenu } = this.props;\n    const { menuHidden } = this.state;\n    const MenuType = this.props.menuAs || (ContextualMenu as React.ElementType<IContextualMenuProps>);\n\n    // the accessible menu label (accessible name) has a relationship to the button.\n    // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n    // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n      menuProps = { ...menuProps, labelElementId: this._labelId };\n    }\n\n    return (\n      <MenuType\n        id={this._labelId + '-menu'}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        {...menuProps}\n        shouldFocusOnContainer={this._menuShouldFocusOnContainer}\n        shouldFocusOnMount={this._menuShouldFocusOnMount}\n        hidden={persistMenu ? menuHidden : undefined}\n        className={css('ms-BaseButton-menuhost', menuProps.className)}\n        target={this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current}\n        onDismiss={this._onDismissMenu}\n      />\n    );\n  };\n\n  private _onDismissMenu: IContextualMenuProps['onDismiss'] = ev => {\n    const { menuProps } = this.props;\n\n    if (menuProps && menuProps.onDismiss) {\n      menuProps.onDismiss(ev);\n    }\n    if (!ev || !ev.defaultPrevented) {\n      this._dismissMenu();\n    }\n  };\n\n  private _dismissMenu = (): void => {\n    this._menuShouldFocusOnMount = undefined;\n    this._menuShouldFocusOnContainer = undefined;\n    this.setState({ menuHidden: true });\n  };\n\n  private _openMenu = (shouldFocusOnContainer?: boolean, shouldFocusOnMount: boolean = true): void => {\n    if (this.props.menuProps) {\n      this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n      this._menuShouldFocusOnMount = shouldFocusOnMount;\n      this._renderedVisibleMenu = true;\n      this.setState({ menuHidden: false });\n    }\n  };\n\n  private _onToggleMenu = (shouldFocusOnContainer: boolean): void => {\n    let shouldFocusOnMount = true;\n    if (this.props.menuProps && this.props.menuProps.shouldFocusOnMount === false) {\n      shouldFocusOnMount = false;\n    }\n\n    this.state.menuHidden ? this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : this._dismissMenu();\n  };\n\n  private _onRenderSplitButtonContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const {\n      styles = {},\n      disabled,\n      allowDisabledFocus,\n      checked,\n      getSplitButtonClassNames,\n      primaryDisabled,\n      menuProps,\n      toggle,\n      role,\n      primaryActionButtonProps,\n    } = this.props;\n    let { keytipProps } = this.props;\n    const { menuHidden } = this.state;\n\n    const classNames = getSplitButtonClassNames\n      ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus)\n      : styles && getBaseSplitButtonClassNames(styles!, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n\n    assign(buttonProps, {\n      onClick: undefined,\n      onPointerDown: undefined,\n      onPointerUp: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false,\n    });\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const containerProps = getNativeProps<React.HTMLAttributes<HTMLSpanElement>>(buttonProps, [], ['disabled']);\n\n    // Add additional props to apply on primary action button\n    if (primaryActionButtonProps) {\n      assign(buttonProps, primaryActionButtonProps);\n    }\n\n    const SplitButton = (keytipAttributes?: any): JSX.Element => (\n      <div\n        {...containerProps}\n        data-ktp-target={keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined}\n        role={role ? role : 'button'}\n        aria-disabled={disabled}\n        aria-haspopup={true}\n        aria-expanded={!menuHidden}\n        aria-pressed={toggle ? !!checked : undefined} // should only be present for toggle buttons\n        aria-describedby={mergeAriaAttributeValues(\n          buttonProps['aria-describedby'],\n          keytipAttributes ? keytipAttributes['aria-describedby'] : undefined,\n        )}\n        className={classNames && classNames.splitButtonContainer}\n        onKeyDown={this._onSplitButtonContainerKeyDown}\n        onTouchStart={this._onTouchStart}\n        ref={this._splitButtonContainer}\n        data-is-focusable={true}\n        onClick={!disabled && !primaryDisabled ? this._onSplitButtonPrimaryClick : undefined}\n        tabIndex={!disabled || allowDisabledFocus ? 0 : undefined}\n        aria-roledescription={buttonProps['aria-roledescription']}\n        onFocusCapture={this._onSplitContainerFocusCapture}\n      >\n        <span style={{ display: 'flex' }}>\n          {this._onRenderContent(tag, buttonProps)}\n          {this._onRenderSplitButtonMenuButton(classNames, keytipAttributes)}\n          {this._onRenderSplitButtonDivider(classNames)}\n        </span>\n      </div>\n    );\n\n    return keytipProps ? (\n      <KeytipData keytipProps={keytipProps} disabled={disabled}>\n        {(keytipAttributes: any): JSX.Element => SplitButton(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      SplitButton()\n    );\n  }\n\n  private _onSplitContainerFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    const container = this._splitButtonContainer.current;\n\n    // If the target is coming from the portal we do not need to set focus on the container.\n    if (!container || (ev.target && portalContainsElement(ev.target, container))) {\n      return;\n    }\n\n    // We should never be able to focus the individual buttons in a split button. Focus\n    // should always remain on the container.\n    container.focus();\n  };\n\n  private _onSplitButtonPrimaryClick = (ev: React.MouseEvent<HTMLDivElement>) => {\n    if (!this.state.menuHidden) {\n      this._dismissMenu();\n    }\n\n    if (!this._processingTouch && this.props.onClick) {\n      this.props.onClick(ev);\n    } else if (this._processingTouch) {\n      this._onMenuClick(ev);\n    }\n  };\n\n  private _onRenderSplitButtonDivider(classNames: ISplitButtonClassNames | undefined): JSX.Element | null {\n    if (classNames && classNames.divider) {\n      const onClick = (ev: React.MouseEvent<HTMLSpanElement, MouseEvent>) => {\n        ev.stopPropagation();\n      };\n      return <span className={classNames.divider} aria-hidden={true} onClick={onClick} />;\n    }\n    return null;\n  }\n\n  private _onRenderSplitButtonMenuButton(\n    classNames: ISplitButtonClassNames | undefined,\n    keytipAttributes: any,\n  ): JSX.Element {\n    const { allowDisabledFocus, checked, disabled, splitButtonMenuProps, splitButtonAriaLabel } = this.props;\n    const { menuHidden } = this.state;\n    let menuIconProps = this.props.menuIconProps;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown',\n      };\n    }\n\n    const splitButtonProps = {\n      ...splitButtonMenuProps,\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: { ...menuIconProps, className: this._classNames.menuIcon },\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': !menuHidden,\n      'data-is-focusable': false,\n    };\n\n    // Add data-ktp-execute-target to the split button if the keytip is defined\n    return (\n      <BaseButton\n        {...splitButtonProps}\n        data-ktp-execute-target={keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes}\n        onMouseDown={this._onMouseDown}\n        tabIndex={-1}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    // explicity cancelling event so click won't fire after this\n    if (this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    } else if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuKeyDown(ev);\n      } else if (this.props.onKeyDown !== undefined) {\n        this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onKeyUp = (\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onKeyUp !== undefined) {\n      this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onKeyPress = (\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onKeyPress !== undefined) {\n      this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseUp = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onMouseUp !== undefined) {\n      this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseDown = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onMouseDown !== undefined) {\n      this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onClick = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuClick(ev);\n      } else if (this.props.onClick !== undefined) {\n        this.props.onClick(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onSplitButtonContainerKeyDown = (ev: React.KeyboardEvent<HTMLDivElement>) => {\n    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n      if (this._buttonElement.current) {\n        this._buttonElement.current.click();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    } else {\n      this._onMenuKeyDown(ev);\n    }\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n\n    if (!ev.defaultPrevented && this._isValidMenuOpenKey(ev)) {\n      const { onMenuClick } = this.props;\n      if (onMenuClick) {\n        onMenuClick(ev, this.props);\n      }\n\n      this._onToggleMenu(false);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n      // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n      // We need to re-render the menu with shouldFocusOnMount as true.\n\n      if (!this.state.menuHidden && this.props.menuProps) {\n        const currentShouldFocusOnMount =\n          this._menuShouldFocusOnMount !== undefined\n            ? this._menuShouldFocusOnMount\n            : this.props.menuProps.shouldFocusOnMount;\n        if (!currentShouldFocusOnMount) {\n          ev.preventDefault();\n          ev.stopPropagation();\n          this._menuShouldFocusOnMount = true;\n          this.forceUpdate();\n        }\n      }\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (\n      this._isSplitButton &&\n      this._splitButtonContainer.current &&\n      !('onpointerdown' in this._splitButtonContainer.current)\n    ) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown(\n    ev: PointerEvent &\n      React.PointerEvent<HTMLAnchorElement | HTMLButtonElement | HTMLDivElement | BaseButton | HTMLSpanElement>,\n  ) {\n    const { onPointerDown } = this.props;\n    if (onPointerDown) {\n      onPointerDown(ev);\n    }\n\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  }\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a new one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n\n      // Touch and pointer events don't focus the button naturally,\n      // so adding an imperative focus call to guarantee this behavior.\n      this.focus();\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n  private _isValidMenuOpenKey(\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>,\n  ): boolean {\n    if (this.props.menuTriggerKeyCode) {\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    }\n\n    // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n    return false;\n  }\n\n  private _onMenuClick = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLButtonElement | HTMLAnchorElement | HTMLSpanElement>,\n  ) => {\n    const { onMenuClick } = this.props;\n    if (onMenuClick) {\n      onMenuClick(ev, this.props);\n    }\n\n    if (!ev.defaultPrevented) {\n      // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n      // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n      // between a real click event and a keypress event (detail should be the number of mouse clicks).\n      // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n      // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n      // and \"\" for pressing \"Enter\" with Narrator on.\n      const shouldFocusOnContainer =\n        ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse';\n      this._onToggleMenu(shouldFocusOnContainer);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}