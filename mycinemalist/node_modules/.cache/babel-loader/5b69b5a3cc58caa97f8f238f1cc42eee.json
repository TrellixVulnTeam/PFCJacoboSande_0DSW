{"ast":null,"code":"import { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, warnDeprecations, Async, EventGroup, assign, classNamesFunction, css, getDocument, getFirstFocusable, getId, getLastFocusable, getRTL, getWindow, KeyCodes, shouldWrapFocus, isIOS, isMac, initializeComponentRef, memoizeFunction } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction();\nexport function getSubmenuItems(item) {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250\n/* ms */\n;\nvar COMPONENT_NAME = 'ContextualMenu';\n\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArrays([styleProps, getItemStyles], styles));\n  };\n});\n\nvar ContextualMenuBase =\n/** @class */\nfunction (_super) {\n  __extends(ContextualMenuBase, _super);\n\n  function ContextualMenuBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._mounted = false;\n\n    _this.dismiss = function (ev, dismissAll) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev, dismissAll);\n      }\n    };\n\n    _this._tryFocusPreviousActiveElement = function (options) {\n      if (_this.props.onRestoreFocus) {\n        _this.props.onRestoreFocus(options);\n      } else {\n        if (options && options.containsFocus && _this._previousActiveElement) {\n          // Make sure that the focus method actually exists\n          // In some cases the object might exist but not be a real element.\n          // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n          if (_this._previousActiveElement.focus) {\n            _this._previousActiveElement.focus();\n          }\n        }\n      }\n    };\n\n    _this._onRenderMenuList = function (menuListProps, defaultRender) {\n      var indexCorrection = 0;\n      var items = menuListProps.items,\n          totalItemCount = menuListProps.totalItemCount,\n          hasCheckmarks = menuListProps.hasCheckmarks,\n          hasIcons = menuListProps.hasIcons,\n          role = menuListProps.role;\n      return React.createElement(\"ul\", {\n        className: _this._classNames.list,\n        onKeyDown: _this._onKeyDown,\n        onKeyUp: _this._onKeyUp,\n        role: role !== null && role !== void 0 ? role : 'menu'\n      }, items.map(function (item, index) {\n        var menuItem = _this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          indexCorrection += indexIncrease;\n        }\n\n        return menuItem;\n      }));\n    };\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n\n\n    _this._renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n      var _a;\n\n      var renderedItems = [];\n      var iconProps = item.iconProps || {\n        iconName: 'None'\n      };\n      var getItemClassNames = item.getItemClassNames,\n          // eslint-disable-line deprecation/deprecation\n      itemProps = item.itemProps;\n      var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n\n      var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : ''; // eslint-disable-next-line deprecation/deprecation\n\n      var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(_this.props.theme, isItemDisabled(item), _this.state.expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n      } else {\n        var itemStyleProps = {\n          theme: _this.props.theme,\n          disabled: isItemDisabled(item),\n          expanded: _this.state.expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName: dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled\n        }; // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n\n        itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = _this._classNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n          break;\n\n        case ContextualMenuItemType.Header:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n\n          var headerItem = _this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n\n          renderedItems.push(_this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n\n        case ContextualMenuItemType.Section:\n          renderedItems.push(_this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n          break;\n\n        default:\n          var menuItem = _this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n\n          renderedItems.push(_this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      } // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n\n\n      return React.createElement(React.Fragment, {\n        key: item.key\n      }, renderedItems);\n    };\n\n    _this._defaultMenuItemRenderer = function (item) {\n      var index = item.index,\n          focusableElementIndex = item.focusableElementIndex,\n          totalItemCount = item.totalItemCount,\n          hasCheckmarks = item.hasCheckmarks,\n          hasIcons = item.hasIcons;\n      return _this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    };\n\n    _this._onKeyDown = function (ev) {\n      // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n\n      var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n      return _this._keyHandler(ev, _this._shouldHandleKeyDown, dismissAllMenus);\n    };\n\n    _this._shouldHandleKeyDown = function (ev) {\n      return ev.which === KeyCodes.escape || _this._shouldCloseSubMenu(ev) || ev.which === KeyCodes.up && (ev.altKey || ev.metaKey);\n    };\n\n    _this._onMenuFocusCapture = function (ev) {\n      if (_this.props.delayUpdateFocusOnHover) {\n        _this._shouldUpdateFocusOnMouseEvent = true;\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      return _this._keyHandler(ev, _this._shouldHandleKeyUp, true\n      /* dismissAllMenus */\n      );\n    };\n    /**\n     * We close the menu on key up only if ALL of the following are true:\n     * - Most recent key down was alt or meta (command)\n     * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n     *   expand/collapse the menu)\n     * - We're not on a Mac (or iOS)\n     *\n     * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n     * closing any open context menus. There is not a similar behavior on Macs.\n     */\n\n\n    _this._shouldHandleKeyUp = function (ev) {\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n\n      _this._lastKeyDownWasAltOrMeta = false;\n      return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n    };\n    /**\n     * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n     * if so, stops event propagation and dismisses menu(s).\n     * @param ev - The keyboard event.\n     * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n     * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n     * Only does anything if `shouldHandleKey` returns true.\n     * @returns Whether the event was handled.\n     */\n\n\n    _this._keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n      var handled = false;\n\n      if (shouldHandleKey(ev)) {\n        _this._focusingPreviousElement = true;\n\n        _this.dismiss(ev, dismissAllMenus);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n        handled = true;\n      }\n\n      return handled;\n    };\n    /**\n     * Checks if the submenu should be closed\n     */\n\n\n    _this._shouldCloseSubMenu = function (ev) {\n      var submenuCloseKey = getRTL(_this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n      if (ev.which !== submenuCloseKey || !_this.props.isSubMenu) {\n        return false;\n      }\n\n      return _this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical || !!_this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap');\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      // Mark as handled if onKeyDown returns true (for handling collapse cases)\n      // or if we are attempting to expand a submenu\n      var handled = _this._onKeyDown(ev);\n\n      if (handled || !_this._host) {\n        return;\n      } // If we have a modifier key being pressed, we do not want to move focus.\n      // Otherwise, handle up and down keys.\n\n\n      var hasModifier = !!(ev.altKey || ev.metaKey);\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!hasModifier && (isUp || isDown)) {\n        var elementToFocus = isUp ? getLastFocusable(_this._host, _this._host.lastChild, true) : getFirstFocusable(_this._host, _this._host.firstChild, true);\n\n        if (elementToFocus) {\n          elementToFocus.focus();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, NavigationIdleDelay);\n    };\n\n    _this._onItemMouseEnterBase = function (item, ev, target) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onItemMouseMoveBase = function (item, ev, target) {\n      var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n      if (_this._shouldUpdateFocusOnMouseEvent) {\n        _this._gotMouseMove = true;\n      } else {\n        return;\n      }\n\n      if (!_this._isScrollIdle || _this._enterTimerId !== undefined || targetElement === _this._targetWindow.document.activeElement) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n\n      if (_this.state.expandedMenuItemKey !== undefined) {\n        return;\n      }\n      /**\n       * IE11 focus() method forces parents to scroll to top of element.\n       * Edge and IE expose a setActive() function for focusable divs that\n       * sets the page focus but does not scroll the parent element.\n       */\n\n\n      if (_this._host.setActive) {\n        try {\n          _this._host.setActive();\n        } catch (e) {\n          /* no-op */\n        }\n      } else {\n        _this._host.focus();\n      }\n    };\n\n    _this._onItemMouseDown = function (item, ev) {\n      if (item.onMouseDown) {\n        item.onMouseDown(item, ev);\n      }\n    };\n\n    _this._onItemClick = function (item, ev) {\n      _this._onItemClickBase(item, ev, ev.currentTarget);\n    };\n\n    _this._onItemClickBase = function (item, ev, target) {\n      var items = getSubmenuItems(item); // Cancel a async menu item hover timeout action from being taken and instead\n      // just trigger the click event instead.\n\n      _this._cancelSubMenuTimer();\n\n      if (!hasSubmenu(item) && (!items || !items.length)) {\n        // This is an item without a menu. Click it.\n        _this._executeItemClick(item, ev);\n      } else {\n        if (item.key !== _this.state.expandedMenuItemKey) {\n          // This has a collapsed sub menu. Expand it.\n          _this.setState({\n            // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n            // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n            // between a real click event and a keypress event (detail should be the number of mouse clicks).\n            // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n            // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n            // and \"\" for pressing \"Enter\" with Narrator on.\n            expandedByMouseClick: ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse'\n          });\n\n          _this._onItemSubMenuExpand(item, target);\n        }\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onAnchorClick = function (item, ev) {\n      _this._executeItemClick(item, ev);\n\n      ev.stopPropagation();\n    };\n\n    _this._executeItemClick = function (item, ev) {\n      if (item.disabled || item.isDisabled) {\n        return;\n      }\n\n      var dismiss = false;\n\n      if (item.onClick) {\n        dismiss = !!item.onClick(ev, item);\n      } else if (_this.props.onItemClick) {\n        dismiss = !!_this.props.onItemClick(ev, item);\n      }\n\n      if (dismiss || !ev.defaultPrevented) {\n        _this.dismiss(ev, true); // This should be removed whenever possible.\n        // This ensures that the hidden dismissal action maintains the same behavior.\n        // If the menu is being dismissed then the previously focused element should\n        // get focused since the dismiss was triggered by a user click on an item\n        // Rather than focus being lost.\n\n\n        _this._focusingPreviousElement = true;\n      }\n    };\n\n    _this._onItemKeyDown = function (item, ev) {\n      var openKey = getRTL(_this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n      if (!item.disabled && (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n        _this.setState({\n          expandedByMouseClick: false\n        });\n\n        _this._onItemSubMenuExpand(item, ev.currentTarget);\n\n        ev.preventDefault();\n      }\n    }; // Cancel a async menu item hover timeout action from being taken and instead\n    // do new upcoming behavior\n\n\n    _this._cancelSubMenuTimer = function () {\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n    };\n\n    _this._onItemSubMenuExpand = function (item, target) {\n      if (_this.state.expandedMenuItemKey !== item.key) {\n        if (_this.state.expandedMenuItemKey) {\n          _this._onSubMenuDismiss();\n        } // Focus the target to ensure when we close it, we're focusing on the correct element.\n\n\n        target.focus();\n\n        _this.setState({\n          expandedMenuItemKey: item.key,\n          submenuTarget: target\n        });\n      }\n    };\n    /**\n     * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n     * after the component is unmounted. The _mounted property is added to prevent\n     * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n     * code.\n     */\n\n\n    _this._onSubMenuDismiss = function (ev, dismissAll) {\n      if (dismissAll) {\n        _this.dismiss(ev, dismissAll);\n      } else if (_this._mounted) {\n        _this.setState({\n          dismissedMenuItemKey: _this.state.expandedMenuItemKey,\n          expandedMenuItemKey: undefined,\n          submenuTarget: undefined\n        });\n      }\n    };\n\n    _this._getSubMenuId = function (item) {\n      var subMenuId = _this.state.subMenuId;\n\n      if (item.subMenuProps && item.subMenuProps.id) {\n        subMenuId = item.subMenuProps.id;\n      }\n\n      return subMenuId;\n    };\n\n    _this._onPointerAndTouchEvent = function (ev) {\n      _this._cancelSubMenuTimer();\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles'\n    });\n    _this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu')\n    };\n    _this._id = props.id || getId('ContextualMenu');\n    _this._focusingPreviousElement = false;\n    _this._isScrollIdle = true;\n    _this._shouldUpdateFocusOnMouseEvent = !_this.props.delayUpdateFocusOnHover;\n    _this._gotMouseMove = false;\n    return _this;\n  }\n\n  ContextualMenuBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  };\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    if (newProps.target !== this.props.target) {\n      var newTarget = newProps.target;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n\n        this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n      }\n    }\n\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover; // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }; // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillMount = function () {\n    var target = this.props.target;\n\n    this._setTargetWindowAndElement(target);\n\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n    }\n  }; // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }; // Invoked immediately before a component is unmounted from the DOM.\n\n\n  ContextualMenuBase.prototype.componentWillUnmount = function () {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n\n    this._async.dispose();\n\n    this._mounted = false;\n  };\n\n  ContextualMenuBase.prototype.render = function () {\n    var _this = this;\n\n    var isBeakVisible = this.props.isBeakVisible;\n    var _a = this.props,\n        items = _a.items,\n        labelElementId = _a.labelElementId,\n        id = _a.id,\n        className = _a.className,\n        beakWidth = _a.beakWidth,\n        directionalHint = _a.directionalHint,\n        directionalHintForRTL = _a.directionalHintForRTL,\n        alignTargetEdge = _a.alignTargetEdge,\n        gapSpace = _a.gapSpace,\n        coverTarget = _a.coverTarget,\n        ariaLabel = _a.ariaLabel,\n        doNotLayer = _a.doNotLayer,\n        target = _a.target,\n        bounds = _a.bounds,\n        useTargetWidth = _a.useTargetWidth,\n        useTargetAsMinWidth = _a.useTargetAsMinWidth,\n        directionalHintFixed = _a.directionalHintFixed,\n        shouldFocusOnMount = _a.shouldFocusOnMount,\n        shouldFocusOnContainer = _a.shouldFocusOnContainer,\n        title = _a.title,\n        styles = _a.styles,\n        theme = _a.theme,\n        calloutProps = _a.calloutProps,\n        _b = _a.onRenderSubMenu,\n        onRenderSubMenu = _b === void 0 ? this._onRenderSubMenu : _b,\n        _c = _a.onRenderMenuList,\n        onRenderMenuList = _c === void 0 ? this._onRenderMenuList : _c,\n        focusZoneProps = _a.focusZoneProps,\n        // eslint-disable-next-line deprecation/deprecation\n    getMenuClassNames = _a.getMenuClassNames;\n    this._classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems) {\n      for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n        var item = contextualMenuItems_1[_i];\n\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = __assign(__assign({}, focusZoneProps), {\n      direction: this._getFocusZoneDirection()\n    });\n    var hasCheckmarks = canAnyMenuItemsCheck(items);\n    var submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n\n    var contextMenuStyle;\n    var targetAsHtmlElement = this._target;\n\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      var targetWidth = targetBoundingRect.width - 2\n      /* Accounts for 1px border */\n      ;\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth\n        };\n      }\n    } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n    if (items && items.length > 0) {\n      var totalItemCount = 0;\n\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      var calloutStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.callout : undefined;\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles,\n        onRestoreFocus: this._tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: this.props.onDismiss,\n        onScroll: this._onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: this.props.hidden\n      }), React.createElement(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        style: contextMenuStyle,\n        ref: function (host) {\n          return _this._host = host;\n        },\n        id: id,\n        className: this._classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: this._onMenuKeyDown,\n        onKeyUp: this._onKeyUp,\n        onFocusCapture: this._onMenuFocusCapture\n      }, title && React.createElement(\"div\", {\n        className: this._classNames.title\n      }, \" \", title, \" \"), items && items.length ? React.createElement(FocusZone, __assign({\n        className: this._classNames.root,\n        isCircularNavigation: true,\n        handleTabKey: FocusZoneTabbableElements.all\n      }, this._adjustedFocusZoneProps), onRenderMenuList({\n        items: items,\n        totalItemCount: totalItemCount,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: this._defaultMenuItemRenderer\n      }, this._onRenderMenuList)) : null, submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n\n\n  ContextualMenuBase.prototype._isHidden = function (props) {\n    return !!props.hidden;\n  };\n\n  ContextualMenuBase.prototype._onMenuOpened = function () {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  };\n\n  ContextualMenuBase.prototype._onMenuClosed = function () {\n    this._events.off(this._targetWindow, 'resize', this.dismiss); // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n\n\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover; // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined\n    });\n  };\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n\n\n  ContextualMenuBase.prototype._getFocusZoneDirection = function () {\n    var focusZoneProps = this.props.focusZoneProps;\n    return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;\n  };\n\n  ContextualMenuBase.prototype._onRenderSubMenu = function (subMenuProps, defaultRender) {\n    throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n  };\n\n  ContextualMenuBase.prototype._renderSectionItem = function (sectionItem, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _this = this;\n\n    var _a;\n\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n    var groupProps;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabellledby = '';\n\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + ((_a = sectionProps.title.text) === null || _a === void 0 ? void 0 : _a.replace(/\\s/g, ''));\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby\n        };\n        headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: this._classNames.list\n      }, sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true), headerItem && this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return _this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons);\n      }), sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true))));\n    }\n  };\n\n  ContextualMenuBase.prototype._renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  ContextualMenuBase.prototype._renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  ContextualMenuBase.prototype._renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), this.dismiss);\n    }\n\n    if (item.href) {\n      return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  ContextualMenuBase.prototype._renderHeaderMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, hasCheckmarks, hasIcons) {\n    var _a = this.props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n        id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (// eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: this._classNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: classNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? this._onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  };\n\n  ContextualMenuBase.prototype._renderAnchorMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuAnchor, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onAnchorClick,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderButtonItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderSplitButton = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuSplitButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss,\n      expandedMenuItemKey: expandedMenuItemKey,\n      onTap: this._onPointerAndTouchEvent\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n\n\n  ContextualMenuBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n\n  ContextualMenuBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  ContextualMenuBase.prototype._updateFocusOnMouseEvent = function (item, ev, target) {\n    var _this = this;\n\n    var targetElement = target ? target : ev.currentTarget;\n    var _a = this.props.subMenuHoverDelay,\n        timeoutDuration = _a === void 0 ? NavigationIdleDelay : _a;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n\n      this._enterTimerId = undefined;\n    } // If the menu is not expanded we can update focus without any delay\n\n\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(function () {\n        targetElement.focus();\n\n        _this.setState({\n          expandedByMouseClick: true\n        });\n\n        _this._onItemSubMenuExpand(item, targetElement);\n\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(function () {\n        _this._onSubMenuDismiss(ev);\n\n        targetElement.focus();\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  };\n\n  ContextualMenuBase.prototype._getSubmenuProps = function () {\n    var _a = this.state,\n        submenuTarget = _a.submenuTarget,\n        expandedMenuItemKey = _a.expandedMenuItemKey;\n\n    var item = this._findItemByKey(expandedMenuItemKey);\n\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item),\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  ContextualMenuBase.prototype._findItemByKey = function (key) {\n    var items = this.props.items;\n    return this._findItemByKeyFromItems(key, items);\n  };\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n\n\n  ContextualMenuBase.prototype._findItemByKeyFromItems = function (key, items) {\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        var match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  };\n\n  ContextualMenuBase.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement); // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if ( // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && ( // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target);\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  }; // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\n\n  ContextualMenuBase.defaultProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16\n  };\n  ContextualMenuBase = __decorate([withResponsiveMode], ContextualMenuBase);\n  return ContextualMenuBase;\n}(React.Component);\n\nexport { ContextualMenuBase };","map":{"version":3,"mappings":"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","names":["React","ContextualMenuItemType","DirectionalHint","FocusZone","FocusZoneDirection","FocusZoneTabbableElements","divProperties","getNativeProps","shallowCompare","warnDeprecations","Async","EventGroup","assign","classNamesFunction","css","getDocument","getFirstFocusable","getId","getLastFocusable","getRTL","getWindow","KeyCodes","shouldWrapFocus","isIOS","isMac","initializeComponentRef","memoizeFunction","hasSubmenu","getIsChecked","isItemDisabled","withResponsiveMode","ResponsiveMode","Callout","ContextualMenuItem","ContextualMenuSplitButton","ContextualMenuButton","ContextualMenuAnchor","concatStyleSetsWithProps","getItemStyles","getClassNames","getContextualMenuItemClassNames","getSubmenuItems","item","subMenuProps","items","canAnyMenuItemsCheck","some","canCheck","sectionProps","NavigationIdleDelay","COMPONENT_NAME","_getMenuItemStylesFunction","styles","styleProps","__spreadArrays","__extends","props","_super","_this","ev","dismissAll","onDismiss","options","onRestoreFocus","containsFocus","_previousActiveElement","focus","menuListProps","defaultRender","indexCorrection","totalItemCount","hasCheckmarks","hasIcons","role","className","_classNames","list","onKeyDown","_onKeyDown","onKeyUp","_onKeyUp","map","index","menuItem","_renderMenuItem","itemType","Divider","Header","indexIncrease","customOnRenderListLength","focusableElementIndex","renderedItems","iconProps","iconName","itemProps","undefined","dividerClassName","subMenuIconClassName","submenuIconProps","itemClassNames","getItemClassNames","theme","state","expandedMenuItemKey","key","href","primaryDisabled","itemStyleProps","disabled","expanded","checked","isAnchorLink","knownIcon","itemClassName","iconClassName","subMenuClassName","subComponentStyles","_a","text","name","push","_renderSeparator","headerItem","_renderHeaderMenuItem","_renderListItem","title","Section","_renderSectionItem","_renderNormalItem","Fragment","_lastKeyDownWasAltOrMeta","_isAltOrMeta","dismissAllMenus","which","escape","_keyHandler","_shouldHandleKeyDown","_shouldCloseSubMenu","up","altKey","metaKey","delayUpdateFocusOnHover","_shouldUpdateFocusOnMouseEvent","_shouldHandleKeyUp","keyPressIsAltOrMetaAlone","shouldHandleKey","handled","_focusingPreviousElement","dismiss","preventDefault","stopPropagation","submenuCloseKey","right","left","isSubMenu","_adjustedFocusZoneProps","direction","vertical","checkForNoWrap","target","_host","hasModifier","isUp","isDown","down","elementToFocus","lastChild","firstChild","_isScrollIdle","_scrollIdleTimeoutId","_async","clearTimeout","setTimeout","_shouldIgnoreMouseEvent","_updateFocusOnMouseEvent","targetElement","currentTarget","_gotMouseMove","_enterTimerId","_targetWindow","document","activeElement","setActive","e","onMouseDown","_onItemClickBase","_cancelSubMenuTimer","length","_executeItemClick","setState","expandedByMouseClick","nativeEvent","detail","pointerType","_onItemSubMenuExpand","isDisabled","onClick","onItemClick","defaultPrevented","openKey","enter","_onSubMenuDismiss","submenuTarget","_mounted","dismissedMenuItemKey","id","subMenuId","_events","getMenuClassNames","contextualMenuItems","_id","ContextualMenuBase","newProps","newState","shouldUpdateWhenHidden","hidden","newTarget","_setTargetWindowAndElement","_isHidden","_onMenuClosed","_onMenuOpened","onMenuDismissed","dispose","labelElementId","beakWidth","directionalHint","directionalHintForRTL","alignTargetEdge","gapSpace","coverTarget","ariaLabel","doNotLayer","bounds","useTargetWidth","useTargetAsMinWidth","directionalHintFixed","shouldFocusOnMount","shouldFocusOnContainer","calloutProps","_b","onRenderSubMenu","_c","onRenderMenuList","focusZoneProps","itemsHaveIcons","_i","__assign","_getFocusZoneDirection","submenuProps","_getSubmenuProps","isBeakVisible","responsiveMode","medium","contextMenuStyle","targetAsHtmlElement","_target","offsetWidth","targetBoundingRect","getBoundingClientRect","targetWidth","width","minWidth","itemCount","calloutStyles","callout","_tryFocusPreviousActiveElement","setInitialFocus","onScroll","_onScroll","style","ref","host","container","tabIndex","_onMenuKeyDown","onFocusCapture","_onMenuFocusCapture","root","isCircularNavigation","handleTabKey","all","defaultMenuItemRenderer","_defaultMenuItemRenderer","_onRenderMenuList","_onRenderSubMenu","on","onMenuOpened","off","documentContainsFocus","hasFocus","originalElement","Error","sectionItem","menuClassNames","groupProps","headerContextualMenuItem","ariaLabellledby","replace","topDivider","contextualMenuItem","itemsIndex","bottomDivider","content","classNames","top","fromSection","divider","onRender","_renderAnchorMenuItem","split","_renderSplitButton","_renderButtonItem","divHtmlProperties","header","ChildrenRenderer","onCheckmarkClick","_onItemClick","contextualMenuItemAs","onItemMouseEnter","_onItemMouseEnterBase","onItemMouseLeave","_onMouseItemLeave","onItemMouseMove","_onItemMouseMoveBase","onItemMouseDown","_onItemMouseDown","executeItemClick","_onAnchorClick","onItemKeyDown","_onItemKeyDown","getSubMenuId","_getSubMenuId","openSubMenu","dismissSubMenu","dismissMenu","onItemClickBase","onTap","_onPointerAndTouchEvent","alt","timeoutDuration","_findItemByKey","leftTopEdge","rightTopEdge","_findItemByKeyFromItems","match","currentElement","currentDoc","querySelector","x","y","current","bottomAutoEdge","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\ContextualMenu\\ContextualMenu.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  ContextualMenuItemType,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, IFocusZoneProps, FocusZoneTabbableElements } from '../../FocusZone';\nimport { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  warnDeprecations,\n  Async,\n  EventGroup,\n  assign,\n  classNamesFunction,\n  css,\n  getDocument,\n  getFirstFocusable,\n  getId,\n  getLastFocusable,\n  getRTL,\n  getWindow,\n  IRenderFunction,\n  Point,\n  KeyCodes,\n  shouldWrapFocus,\n  IStyleFunctionOrObject,\n  isIOS,\n  isMac,\n  initializeComponentRef,\n  memoizeFunction,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout, ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { IProcessedStyleSet, concatStyleSetsWithProps } from '../../Styling';\nimport { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { Target } from '@uifabric/react-hooks';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\nexport interface IContextualMenuState {\n  expandedMenuItemKey?: string;\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  expandedByMouseClick?: boolean;\n  dismissedMenuItemKey?: string;\n  contextualMenuItems?: IContextualMenuItem[];\n  contextualMenuTarget?: Element;\n  submenuTarget?: Element;\n  positions?: any;\n  slideDirectionalClassName?: string;\n  subMenuId?: string;\n  submenuDirection?: DirectionalHint;\n}\n\nexport function getSubmenuItems(item: IContextualMenuItem): IContextualMenuItem[] | undefined {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250 /* ms */;\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n@withResponsiveMode\nexport class ContextualMenuBase extends React.Component<IContextualMenuProps, IContextualMenuState> {\n  // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n  public static defaultProps: IContextualMenuProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _id: string;\n  private _host: HTMLElement;\n  private _previousActiveElement: HTMLElement | undefined;\n  private _enterTimerId: number | undefined;\n  private _targetWindow: Window;\n  private _target: Element | MouseEvent | Point | null;\n  private _isScrollIdle: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n  private _shouldUpdateFocusOnMouseEvent: boolean;\n  private _gotMouseMove: boolean;\n  private _mounted = false;\n  private _focusingPreviousElement: boolean;\n\n  private _adjustedFocusZoneProps: IFocusZoneProps;\n\n  // eslint-disable-next-line deprecation/deprecation\n  private _classNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames;\n\n  constructor(props: IContextualMenuProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles',\n    });\n\n    this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu'),\n    };\n\n    this._id = props.id || getId('ContextualMenu');\n    this._focusingPreviousElement = false;\n    this._isScrollIdle = true;\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n  }\n\n  public dismiss = (ev?: any, dismissAll?: boolean) => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev, dismissAll);\n    }\n  };\n\n  public shouldComponentUpdate(newProps: IContextualMenuProps, newState: IContextualMenuState): boolean {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: IContextualMenuProps): void {\n    if (newProps.target !== this.props.target) {\n      const newTarget = newProps.target;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n        this._previousActiveElement = this._targetWindow\n          ? (this._targetWindow.document.activeElement as HTMLElement)\n          : undefined;\n      }\n    }\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;\n\n      // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }\n\n  // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  public UNSAFE_componentWillMount() {\n    const target = this.props.target;\n    this._setTargetWindowAndElement(target!);\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow\n        ? (this._targetWindow.document.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }\n\n  // Invoked immediately before a component is unmounted from the DOM.\n  public componentWillUnmount() {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n    this._async.dispose();\n    this._mounted = false;\n  }\n\n  public render(): JSX.Element | null {\n    let { isBeakVisible } = this.props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = this._onRenderSubMenu,\n      onRenderMenuList = this._onRenderMenuList,\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = this.props;\n\n    this._classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = { ...focusZoneProps, direction: this._getFocusZoneDirection() };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle;\n    const targetAsHtmlElement = this._target as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2 /* Accounts for 1px border */;\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles = this._classNames.subComponentStyles\n        ? (this._classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <Callout\n          styles={calloutStyles}\n          onRestoreFocus={this._tryFocusPreviousActiveElement}\n          {...calloutProps}\n          target={target}\n          isBeakVisible={isBeakVisible}\n          beakWidth={beakWidth}\n          directionalHint={directionalHint}\n          directionalHintForRTL={directionalHintForRTL}\n          gapSpace={gapSpace}\n          coverTarget={coverTarget}\n          doNotLayer={doNotLayer}\n          className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n          setInitialFocus={shouldFocusOnMount}\n          onDismiss={this.props.onDismiss}\n          onScroll={this._onScroll}\n          bounds={bounds}\n          directionalHintFixed={directionalHintFixed}\n          alignTargetEdge={alignTargetEdge}\n          hidden={this.props.hidden}\n        >\n          <div\n            aria-label={ariaLabel}\n            aria-labelledby={labelElementId}\n            style={contextMenuStyle}\n            ref={(host: HTMLDivElement) => (this._host = host)}\n            id={id}\n            className={this._classNames.container}\n            tabIndex={shouldFocusOnContainer ? 0 : -1}\n            onKeyDown={this._onMenuKeyDown}\n            onKeyUp={this._onKeyUp}\n            onFocusCapture={this._onMenuFocusCapture}\n          >\n            {title && <div className={this._classNames.title}> {title} </div>}\n            {items && items.length ? (\n              <FocusZone\n                className={this._classNames.root}\n                isCircularNavigation={true}\n                handleTabKey={FocusZoneTabbableElements.all}\n                {...this._adjustedFocusZoneProps}\n              >\n                {onRenderMenuList(\n                  {\n                    items,\n                    totalItemCount,\n                    hasCheckmarks,\n                    hasIcons,\n                    defaultMenuItemRenderer: this._defaultMenuItemRenderer,\n                  },\n                  this._onRenderMenuList,\n                )}\n              </FocusZone>\n            ) : null}\n            {submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)}\n          </div>\n        </Callout>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n  private _isHidden(props: IContextualMenuProps) {\n    return !!props.hidden;\n  }\n\n  private _onMenuOpened() {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  }\n\n  private _onMenuClosed() {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n\n    // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement,\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n\n    // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined,\n    });\n  }\n\n  private _tryFocusPreviousActiveElement = (options: {\n    containsFocus: boolean;\n    documentContainsFocus: boolean;\n    originalElement: HTMLElement | Window | undefined;\n  }) => {\n    if (this.props.onRestoreFocus) {\n      this.props.onRestoreFocus(options);\n    } else {\n      if (options && options.containsFocus && this._previousActiveElement) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n        if (this._previousActiveElement.focus) {\n          this._previousActiveElement.focus();\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n  private _getFocusZoneDirection() {\n    const { focusZoneProps } = this.props;\n    return focusZoneProps && focusZoneProps.direction !== undefined\n      ? focusZoneProps.direction\n      : FocusZoneDirection.vertical;\n  }\n\n  private _onRenderSubMenu(\n    subMenuProps: IContextualMenuProps,\n    defaultRender?: IRenderFunction<IContextualMenuProps>,\n  ): JSX.Element {\n    throw Error(\n      'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n        'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n    );\n  }\n\n  private _onRenderMenuList = (\n    menuListProps: IContextualMenuListProps,\n    defaultRender?: IRenderFunction<IContextualMenuListProps>,\n  ): JSX.Element => {\n    let indexCorrection = 0;\n    const { items, totalItemCount, hasCheckmarks, hasIcons, role } = menuListProps;\n    return (\n      <ul className={this._classNames.list} onKeyDown={this._onKeyDown} onKeyUp={this._onKeyUp} role={role ?? 'menu'}>\n        {items.map((item, index) => {\n          const menuItem = this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n          if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n            const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n            indexCorrection += indexIncrease;\n          }\n          return menuItem;\n        })}\n      </ul>\n    );\n  };\n\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n  private _renderMenuItem = (\n    item: IContextualMenuItem,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): JSX.Element => {\n    const renderedItems: React.ReactNode[] = [];\n    const iconProps = item.iconProps || { iconName: 'None' };\n    const {\n      getItemClassNames, // eslint-disable-line deprecation/deprecation\n      itemProps,\n    } = item;\n    const styles = itemProps ? itemProps.styles : undefined;\n\n    // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n    const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n    // eslint-disable-next-line deprecation/deprecation\n    let itemClassNames: IMenuItemClassNames;\n\n    // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(\n        this.props.theme!,\n        isItemDisabled(item),\n        this.state.expandedMenuItemKey === item.key,\n        !!getIsChecked(item),\n        !!item.href,\n        iconProps.iconName !== 'None',\n        item.className,\n        dividerClassName,\n        iconProps.className,\n        subMenuIconClassName,\n        item.primaryDisabled,\n      );\n    } else {\n      const itemStyleProps: IContextualMenuItemStyleProps = {\n        theme: this.props.theme!,\n        disabled: isItemDisabled(item),\n        expanded: this.state.expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled,\n      };\n\n      // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n      itemClassNames = getContextualMenuItemClassNames(\n        _getMenuItemStylesFunction(this._classNames.subComponentStyles?.menuItem, styles),\n        itemStyleProps,\n      );\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        break;\n      case ContextualMenuItemType.Header:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        const headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n      case ContextualMenuItemType.Section:\n        renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n        break;\n      default:\n        const menuItem = this._renderNormalItem(\n          item,\n          itemClassNames,\n          index,\n          focusableElementIndex,\n          totalItemCount,\n          hasCheckmarks,\n          hasIcons,\n        );\n        renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n\n    // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n    return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n  };\n\n  private _defaultMenuItemRenderer = (item: IContextualMenuItemRenderProps): React.ReactNode => {\n    const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n    return this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  private _renderSectionItem(\n    sectionItem: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    menuClassNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ) {\n    const sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n\n    let headerItem;\n    let groupProps;\n    if (sectionProps.title) {\n      let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n      let ariaLabellledby = '';\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        const id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: `section-${sectionProps.title}-title`,\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id,\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + sectionProps.title.text?.replace(/\\s/g, '');\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby,\n        };\n        headerItem = this._renderHeaderMenuItem(\n          headerContextualMenuItem,\n          menuClassNames,\n          index,\n          hasCheckmarks,\n          hasIcons,\n        );\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return (\n        <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n          <div {...groupProps}>\n            <ul className={this._classNames.list}>\n              {sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true)}\n              {headerItem &&\n                this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title)}\n              {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                this._renderMenuItem(\n                  contextualMenuItem,\n                  itemsIndex,\n                  itemsIndex,\n                  sectionProps.items.length,\n                  hasCheckmarks,\n                  hasIcons,\n                ),\n              )}\n              {sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)}\n            </ul>\n          </div>\n        </li>\n      );\n    }\n  }\n\n  private _renderListItem(\n    content: React.ReactNode,\n    key: string | number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    title?: string,\n  ) {\n    return (\n      <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n        {content}\n      </li>\n    );\n  }\n\n  private _renderSeparator(\n    index: number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    top?: boolean,\n    fromSection?: boolean,\n  ): React.ReactNode {\n    if (fromSection || index > 0) {\n      return (\n        <li\n          role=\"separator\"\n          key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n          className={classNames.divider}\n          aria-hidden=\"true\"\n        />\n      );\n    }\n    return null;\n  }\n\n  private _renderNormalItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    if (item.onRender) {\n      return item.onRender(\n        { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n        this.dismiss,\n      );\n    }\n    if (item.href) {\n      return this._renderAnchorMenuItem(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    return this._renderButtonItem(\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n    );\n  }\n\n  private _renderHeaderMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = this.props;\n    const { itemProps, id } = item;\n    const divHtmlProperties =\n      itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      <div id={id} className={this._classNames.header} {...divHtmlProperties} style={item.style}>\n        <ChildrenRenderer\n          item={item}\n          classNames={classNames}\n          index={index}\n          onCheckmarkClick={hasCheckmarks ? this._onItemClick : undefined}\n          hasIcons={hasIcons}\n          {...itemProps}\n        />\n      </div>\n    );\n  }\n\n  private _renderAnchorMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n    return (\n      <ContextualMenuAnchor\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onAnchorClick}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderButtonItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ) {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderSplitButton(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ): JSX.Element {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuSplitButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n        expandedMenuItemKey={expandedMenuItemKey}\n        onTap={this._onPointerAndTouchEvent}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _shouldHandleKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return this._keyHandler(ev, this._shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  private _shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      ev.which === KeyCodes.escape ||\n      this._shouldCloseSubMenu(ev) ||\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  private _onMenuFocusCapture = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this.props.delayUpdateFocusOnHover) {\n      this._shouldUpdateFocusOnMouseEvent = true;\n    }\n  };\n\n  private _onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return this._keyHandler(ev, this._shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  private _shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  private _keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      this._focusingPreviousElement = true;\n      this.dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  private _shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n    if (ev.which !== submenuCloseKey || !this.props.isSubMenu) {\n      return false;\n    }\n\n    return (\n      this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical ||\n      (!!this._adjustedFocusZoneProps.checkForNoWrap &&\n        !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = this._onKeyDown(ev);\n\n    if (handled || !this._host) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(this._host, this._host.lastChild as HTMLElement, true)\n        : getFirstFocusable(this._host, this._host.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = (): void => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, NavigationIdleDelay);\n  };\n\n  private _onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (this._shouldUpdateFocusOnMouseEvent) {\n      this._gotMouseMove = true;\n    } else {\n      return;\n    }\n\n    if (\n      !this._isScrollIdle ||\n      this._enterTimerId !== undefined ||\n      targetElement === (this._targetWindow.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  private _onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    if (this.state.expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((this._host as any).setActive) {\n      try {\n        (this._host as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      this._host.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  private _updateFocusOnMouseEvent(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement) {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n    const { subMenuHoverDelay: timeoutDuration = NavigationIdleDelay } = this.props;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    // If the menu is not expanded we can update focus without any delay\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(() => {\n        targetElement.focus();\n        this.setState({\n          expandedByMouseClick: true,\n        });\n        this._onItemSubMenuExpand(item, targetElement);\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(() => {\n        this._onSubMenuDismiss(ev);\n        targetElement.focus();\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  }\n\n  private _onItemMouseDown = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void => {\n    if (item.onMouseDown) {\n      item.onMouseDown(item, ev);\n    }\n  };\n\n  private _onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    this._onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  private _onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item);\n\n    // Cancel a async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    this._cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      this._executeItemClick(item, ev);\n    } else {\n      if (item.key !== this.state.expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        this.setState({\n          // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n          // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n          // between a real click event and a keypress event (detail should be the number of mouse clicks).\n          // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n          // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n          // and \"\" for pressing \"Enter\" with Narrator on.\n          expandedByMouseClick: ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse',\n        });\n        this._onItemSubMenuExpand(item, target);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  private _onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    this._executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  private _executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    let dismiss = false;\n    if (item.onClick) {\n      dismiss = !!item.onClick(ev, item);\n    } else if (this.props.onItemClick) {\n      dismiss = !!this.props.onItemClick(ev, item);\n    }\n\n    if (dismiss || !ev.defaultPrevented) {\n      this.dismiss(ev, true);\n\n      // This should be removed whenever possible.\n      // This ensures that the hidden dismissal action maintains the same behavior.\n      // If the menu is being dismissed then the previously focused element should\n      // get focused since the dismiss was triggered by a user click on an item\n      // Rather than focus being lost.\n      this._focusingPreviousElement = true;\n    }\n  };\n\n  private _onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      this.setState({\n        expandedByMouseClick: false,\n      });\n      this._onItemSubMenuExpand(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  // Cancel a async menu item hover timeout action from being taken and instead\n  // do new upcoming behavior\n  private _cancelSubMenuTimer = () => {\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n  };\n\n  private _onItemSubMenuExpand = (item: IContextualMenuItem, target: HTMLElement): void => {\n    if (this.state.expandedMenuItemKey !== item.key) {\n      if (this.state.expandedMenuItemKey) {\n        this._onSubMenuDismiss();\n      }\n\n      // Focus the target to ensure when we close it, we're focusing on the correct element.\n      target.focus();\n      this.setState({\n        expandedMenuItemKey: item.key,\n        submenuTarget: target,\n      });\n    }\n  };\n\n  private _getSubmenuProps() {\n    const { submenuTarget, expandedMenuItemKey } = this.state;\n    const item = this._findItemByKey(expandedMenuItemKey!);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item)!,\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n    return submenuProps;\n  }\n\n  private _findItemByKey(key: string): IContextualMenuItem | undefined {\n    const { items } = this.props;\n    return this._findItemByKeyFromItems(key, items);\n  }\n\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n  private _findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n    for (const item of items) {\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        const match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  }\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The _mounted property is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  private _onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      this.dismiss(ev, dismissAll);\n    } else if (this._mounted) {\n      this.setState({\n        dismissedMenuItemKey: this.state.expandedMenuItemKey,\n        expandedMenuItemKey: undefined,\n        submenuTarget: undefined,\n      });\n    }\n  };\n\n  private _setTargetWindowAndElement(target: Target): void {\n    const currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target as MouseEvent;\n      } else if (\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).left !== undefined || (target as Point).x !== undefined) &&\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).top !== undefined || (target as Point).y !== undefined)\n      ) {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target as Point;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n      } else {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target as Element;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  private _getSubMenuId = (item: IContextualMenuItem): string | undefined => {\n    let { subMenuId } = this.state;\n\n    if (item.subMenuProps && item.subMenuProps.id) {\n      subMenuId = item.subMenuProps.id;\n    }\n\n    return subMenuId;\n  };\n\n  private _onPointerAndTouchEvent = (ev: React.TouchEvent<HTMLElement> | PointerEvent) => {\n    this._cancelSubMenuTimer();\n  };\n}\n"]},"metadata":{},"sourceType":"module"}