{"ast":null,"code":"import { getDocument } from './dom/getDocument';\nimport { mergeStyles } from '@uifabric/merge-styles';\nimport { getWindow } from './dom/getWindow';\n\nvar _scrollbarWidth;\n\nvar _bodyScrollDisabledCount = 0;\nvar DisabledScrollClassName = mergeStyles({\n  overflow: 'hidden !important'\n});\n/**\n * Placing this attribute on scrollable divs optimizes detection to know\n * if the div is scrollable or not (given we can avoid expensive operations\n * like getComputedStyle.)\n *\n * @public\n */\n\nexport var DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';\n/**\n * Allows the user to scroll within a element,\n * while preventing the user from scrolling the body\n */\n\nexport var allowScrollOnElement = function allowScrollOnElement(element, events) {\n  if (!element) {\n    return;\n  }\n\n  var _previousClientY = 0;\n  var _element = null; // remember the clientY for future calls of _preventOverscrolling\n\n  var _saveClientY = function _saveClientY(event) {\n    if (event.targetTouches.length === 1) {\n      _previousClientY = event.targetTouches[0].clientY;\n    }\n  }; // prevent the body from scrolling when the user attempts\n  // to scroll past the top or bottom of the element\n\n\n  var _preventOverscrolling = function _preventOverscrolling(event) {\n    // only respond to a single-finger touch\n    if (event.targetTouches.length !== 1) {\n      return;\n    } // prevent the body touchmove handler from firing\n    // so that scrolling is allowed within the element\n\n\n    event.stopPropagation();\n\n    if (!_element) {\n      return;\n    }\n\n    var clientY = event.targetTouches[0].clientY - _previousClientY;\n    var scrollableParent = findScrollableParent(event.target);\n\n    if (scrollableParent) {\n      _element = scrollableParent;\n    } // if the element is scrolled to the top,\n    // prevent the user from scrolling up\n\n\n    if (_element.scrollTop === 0 && clientY > 0) {\n      event.preventDefault();\n    } // if the element is scrolled to the bottom,\n    // prevent the user from scrolling down\n\n\n    if (_element.scrollHeight - Math.ceil(_element.scrollTop) <= _element.clientHeight && clientY < 0) {\n      event.preventDefault();\n    }\n  };\n\n  events.on(element, 'touchstart', _saveClientY, {\n    passive: false\n  });\n  events.on(element, 'touchmove', _preventOverscrolling, {\n    passive: false\n  });\n  _element = element;\n};\n/**\n * Same as allowScrollOnElement but does not prevent overscrolling.\n */\n\nexport var allowOverscrollOnElement = function allowOverscrollOnElement(element, events) {\n  if (!element) {\n    return;\n  }\n\n  var _allowElementScroll = function _allowElementScroll(event) {\n    event.stopPropagation();\n  };\n\n  events.on(element, 'touchmove', _allowElementScroll, {\n    passive: false\n  });\n};\n\nvar _disableIosBodyScroll = function _disableIosBodyScroll(event) {\n  event.preventDefault();\n};\n/**\n * Disables the body scrolling.\n *\n * @public\n */\n\n\nexport function disableBodyScroll() {\n  var doc = getDocument();\n\n  if (doc && doc.body && !_bodyScrollDisabledCount) {\n    doc.body.classList.add(DisabledScrollClassName);\n    doc.body.addEventListener('touchmove', _disableIosBodyScroll, {\n      passive: false,\n      capture: false\n    });\n  }\n\n  _bodyScrollDisabledCount++;\n}\n/**\n * Enables the body scrolling.\n *\n * @public\n */\n\nexport function enableBodyScroll() {\n  if (_bodyScrollDisabledCount > 0) {\n    var doc = getDocument();\n\n    if (doc && doc.body && _bodyScrollDisabledCount === 1) {\n      doc.body.classList.remove(DisabledScrollClassName);\n      doc.body.removeEventListener('touchmove', _disableIosBodyScroll);\n    }\n\n    _bodyScrollDisabledCount--;\n  }\n}\n/**\n * Calculates the width of a scrollbar for the browser/os.\n *\n * @public\n */\n\nexport function getScrollbarWidth() {\n  if (_scrollbarWidth === undefined) {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.style.setProperty('width', '100px');\n    scrollDiv.style.setProperty('height', '100px');\n    scrollDiv.style.setProperty('overflow', 'scroll');\n    scrollDiv.style.setProperty('position', 'absolute');\n    scrollDiv.style.setProperty('top', '-9999px');\n    document.body.appendChild(scrollDiv); // Get the scrollbar width\n\n    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth; // Delete the DIV\n\n    document.body.removeChild(scrollDiv);\n  }\n\n  return _scrollbarWidth;\n}\n/**\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\n * document.body.\n *\n * @public\n */\n\nexport function findScrollableParent(startingElement) {\n  var el = startingElement;\n  var doc = getDocument(startingElement); // First do a quick scan for the scrollable attribute.\n\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\n      return el;\n    }\n\n    el = el.parentElement;\n  } // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\n\n\n  el = startingElement;\n\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\n      var computedStyles = getComputedStyle(el);\n      var overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';\n\n      if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\n        return el;\n      }\n    }\n\n    el = el.parentElement;\n  } // Fall back to window scroll.\n\n\n  if (!el || el === doc.body) {\n    el = getWindow(startingElement);\n  }\n\n  return el;\n}","map":{"version":3,"mappings":"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","names":["getDocument","mergeStyles","getWindow","_scrollbarWidth","_bodyScrollDisabledCount","DisabledScrollClassName","overflow","DATA_IS_SCROLLABLE_ATTRIBUTE","allowScrollOnElement","element","events","_previousClientY","_element","_saveClientY","event","targetTouches","length","clientY","_preventOverscrolling","stopPropagation","scrollableParent","findScrollableParent","target","scrollTop","preventDefault","scrollHeight","Math","ceil","clientHeight","on","passive","allowOverscrollOnElement","_allowElementScroll","_disableIosBodyScroll","disableBodyScroll","doc","body","classList","add","addEventListener","capture","enableBodyScroll","remove","removeEventListener","getScrollbarWidth","undefined","scrollDiv","document","createElement","style","setProperty","appendChild","offsetWidth","clientWidth","removeChild","startingElement","el","getAttribute","parentElement","computedStyles","getComputedStyle","overflowY","getPropertyValue"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\src\\scroll.ts"],"sourcesContent":["import { getDocument } from './dom/getDocument';\nimport { mergeStyles } from '@uifabric/merge-styles';\nimport { EventGroup } from './EventGroup';\nimport { getWindow } from './dom/getWindow';\n\nlet _scrollbarWidth: number;\nlet _bodyScrollDisabledCount = 0;\n\nconst DisabledScrollClassName = mergeStyles({\n  overflow: 'hidden !important' as 'hidden',\n});\n\n/**\n * Placing this attribute on scrollable divs optimizes detection to know\n * if the div is scrollable or not (given we can avoid expensive operations\n * like getComputedStyle.)\n *\n * @public\n */\nexport const DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';\n\n/**\n * Allows the user to scroll within a element,\n * while preventing the user from scrolling the body\n */\nexport const allowScrollOnElement = (element: HTMLElement | null, events: EventGroup): void => {\n  if (!element) {\n    return;\n  }\n\n  let _previousClientY = 0;\n  let _element: Element | null = null;\n\n  // remember the clientY for future calls of _preventOverscrolling\n  const _saveClientY = (event: TouchEvent): void => {\n    if (event.targetTouches.length === 1) {\n      _previousClientY = event.targetTouches[0].clientY;\n    }\n  };\n\n  // prevent the body from scrolling when the user attempts\n  // to scroll past the top or bottom of the element\n  const _preventOverscrolling = (event: TouchEvent): void => {\n    // only respond to a single-finger touch\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    // prevent the body touchmove handler from firing\n    // so that scrolling is allowed within the element\n    event.stopPropagation();\n\n    if (!_element) {\n      return;\n    }\n\n    const clientY = event.targetTouches[0].clientY - _previousClientY;\n\n    const scrollableParent = findScrollableParent(event.target as HTMLElement) as HTMLElement;\n    if (scrollableParent) {\n      _element = scrollableParent;\n    }\n\n    // if the element is scrolled to the top,\n    // prevent the user from scrolling up\n    if (_element.scrollTop === 0 && clientY > 0) {\n      event.preventDefault();\n    }\n\n    // if the element is scrolled to the bottom,\n    // prevent the user from scrolling down\n    if (_element.scrollHeight - Math.ceil(_element.scrollTop) <= _element.clientHeight && clientY < 0) {\n      event.preventDefault();\n    }\n  };\n\n  events.on(element, 'touchstart', _saveClientY, { passive: false });\n  events.on(element, 'touchmove', _preventOverscrolling, { passive: false });\n\n  _element = element;\n};\n\n/**\n * Same as allowScrollOnElement but does not prevent overscrolling.\n */\nexport const allowOverscrollOnElement = (element: HTMLElement | null, events: EventGroup): void => {\n  if (!element) {\n    return;\n  }\n  const _allowElementScroll = (event: TouchEvent) => {\n    event.stopPropagation();\n  };\n  events.on(element, 'touchmove', _allowElementScroll, { passive: false });\n};\n\nconst _disableIosBodyScroll = (event: TouchEvent) => {\n  event.preventDefault();\n};\n\n/**\n * Disables the body scrolling.\n *\n * @public\n */\nexport function disableBodyScroll(): void {\n  let doc = getDocument();\n\n  if (doc && doc.body && !_bodyScrollDisabledCount) {\n    doc.body.classList.add(DisabledScrollClassName);\n    doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false });\n  }\n\n  _bodyScrollDisabledCount++;\n}\n\n/**\n * Enables the body scrolling.\n *\n * @public\n */\nexport function enableBodyScroll(): void {\n  if (_bodyScrollDisabledCount > 0) {\n    let doc = getDocument();\n\n    if (doc && doc.body && _bodyScrollDisabledCount === 1) {\n      doc.body.classList.remove(DisabledScrollClassName);\n      doc.body.removeEventListener('touchmove', _disableIosBodyScroll);\n    }\n\n    _bodyScrollDisabledCount--;\n  }\n}\n\n/**\n * Calculates the width of a scrollbar for the browser/os.\n *\n * @public\n */\nexport function getScrollbarWidth(): number {\n  if (_scrollbarWidth === undefined) {\n    let scrollDiv: HTMLElement = document.createElement('div');\n    scrollDiv.style.setProperty('width', '100px');\n    scrollDiv.style.setProperty('height', '100px');\n    scrollDiv.style.setProperty('overflow', 'scroll');\n    scrollDiv.style.setProperty('position', 'absolute');\n    scrollDiv.style.setProperty('top', '-9999px');\n    document.body.appendChild(scrollDiv);\n    // Get the scrollbar width\n    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n    // Delete the DIV\n    document.body.removeChild(scrollDiv);\n  }\n\n  return _scrollbarWidth;\n}\n\n/**\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\n * document.body.\n *\n * @public\n */\nexport function findScrollableParent(startingElement: HTMLElement | null): HTMLElement | Window | undefined | null {\n  let el: HTMLElement | Window | undefined | null = startingElement;\n  const doc = getDocument(startingElement)!;\n\n  // First do a quick scan for the scrollable attribute.\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\n      return el;\n    }\n    el = el.parentElement;\n  }\n\n  // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\n  el = startingElement;\n\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\n      const computedStyles = getComputedStyle(el);\n      let overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';\n\n      if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\n        return el;\n      }\n    }\n\n    el = el.parentElement;\n  }\n\n  // Fall back to window scroll.\n  if (!el || el === doc.body) {\n    el = getWindow(startingElement);\n  }\n\n  return el;\n}\n"]},"metadata":{},"sourceType":"module"}