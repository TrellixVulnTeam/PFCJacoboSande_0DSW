{"ast":null,"code":"import { MAX_COLOR_ALPHA } from './consts';\nimport { hsl2rgb } from './hsl2rgb';\n/**\n * Converts a valid CSS color string to an RGB color.\n * Note that hex colors *must* be prefixed with # to be considered valid.\n * Alpha in returned color defaults to 100.\n * Four and eight digit hex values (with alpha) are supported if the current browser supports them.\n */\n\nexport function cssColor(color) {\n  if (!color) {\n    return undefined;\n  } // Need to check the following valid color formats: RGB(A), HSL(A), hex, named color\n  // First check for well formatted RGB(A), HSL(A), and hex formats at the start.\n  // This is for perf (no creating an element) and catches the intentional \"transparent\" color\n  //   case early on.\n\n\n  var easyColor = _rgba(color) || _hex6(color) || _hex3(color) || _hsla(color);\n\n  if (easyColor) {\n    return easyColor;\n  } // if the above fails, do the more expensive catch-all\n\n\n  return _browserCompute(color);\n}\n/**\n * Uses the browser's getComputedStyle() to determine what the passed-in color is.\n * This assumes _rgba, _hex6, _hex3, and _hsla have already been tried and all failed.\n * This works by attaching an element to the DOM, which may fail in server-side rendering\n *   or with headless browsers.\n */\n\nfunction _browserCompute(str) {\n  if (typeof document === 'undefined') {\n    // don't throw an error when used server-side\n    return undefined;\n  }\n\n  var elem = document.createElement('div');\n  elem.style.backgroundColor = str; // This element must be attached to the DOM for getComputedStyle() to have a value\n\n  elem.style.position = 'absolute';\n  elem.style.top = '-9999px';\n  elem.style.left = '-9999px';\n  elem.style.height = '1px';\n  elem.style.width = '1px';\n  document.body.appendChild(elem);\n  var eComputedStyle = getComputedStyle(elem);\n  var computedColor = eComputedStyle && eComputedStyle.backgroundColor;\n  document.body.removeChild(elem); // computedColor is always an RGB(A) string, except for invalid colors in IE/Edge which return 'transparent'\n  // browsers return one of these if the color string is invalid,\n  // so need to differentiate between an actual error and intentionally passing in this color\n\n  if (computedColor === 'rgba(0, 0, 0, 0)' || computedColor === 'transparent') {\n    switch (str.trim()) {\n      // RGB and HSL were already checked at the start of the function\n      case 'transparent':\n      case '#0000':\n      case '#00000000':\n        return {\n          r: 0,\n          g: 0,\n          b: 0,\n          a: 0\n        };\n    }\n\n    return undefined;\n  }\n\n  return _rgba(computedColor);\n}\n/**\n * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\n\n\nfunction _rgba(str) {\n  if (!str) {\n    return undefined;\n  }\n\n  var match = str.match(/^rgb(a?)\\(([\\d., ]+)\\)$/);\n\n  if (match) {\n    var hasAlpha = !!match[1];\n    var expectedPartCount = hasAlpha ? 4 : 3;\n    var parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      return {\n        r: parts[0],\n        g: parts[1],\n        b: parts[2],\n        a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA\n      };\n    }\n  }\n}\n/**\n * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\n\n\nfunction _hsla(str) {\n  var match = str.match(/^hsl(a?)\\(([\\d., ]+)\\)$/);\n\n  if (match) {\n    var hasAlpha = !!match[1];\n    var expectedPartCount = hasAlpha ? 4 : 3;\n    var parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      var rgba = hsl2rgb(parts[0], parts[1], parts[2]);\n      rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;\n      return rgba;\n    }\n  }\n}\n/**\n * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\n\n\nfunction _hex6(str) {\n  if (str[0] === '#' && str.length === 7 && /^#[\\da-fA-F]{6}$/.test(str)) {\n    return {\n      r: parseInt(str.slice(1, 3), 16),\n      g: parseInt(str.slice(3, 5), 16),\n      b: parseInt(str.slice(5, 7), 16),\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}\n/**\n * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\n\n\nfunction _hex3(str) {\n  if (str[0] === '#' && str.length === 4 && /^#[\\da-fA-F]{3}$/.test(str)) {\n    return {\n      r: parseInt(str[1] + str[1], 16),\n      g: parseInt(str[2] + str[2], 16),\n      b: parseInt(str[3] + str[3], 16),\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}","map":{"version":3,"mappings":"AACA,SAASA,eAAT,QAAgC,UAAhC;AACA,SAASC,OAAT,QAAwB,WAAxB;AAEA;;;;;;;AAMA,OAAM,SAAUC,QAAV,CAAmBC,KAAnB,EAAiC;AACrC,MAAI,CAACA,KAAL,EAAY;AACV,WAAOC,SAAP;AACD,GAHoC,CAKrC;AAEA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAqBC,KAAK,CAACH,KAAD,CAAL,IAAgBI,KAAK,CAACJ,KAAD,CAArB,IAAgCK,KAAK,CAACL,KAAD,CAArC,IAAgDM,KAAK,CAACN,KAAD,CAAzF;;AACA,MAAIE,SAAJ,EAAe;AACb,WAAOA,SAAP;AACD,GAboC,CAerC;;;AACA,SAAOK,eAAe,CAACP,KAAD,CAAtB;AACD;AAED;;;;;;;AAMA,SAASO,eAAT,CAAyBC,GAAzB,EAAoC;AAClC,MAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;AACnC;AACA,WAAOR,SAAP;AACD;;AACD,MAAMS,IAAI,GAAGD,QAAQ,CAACE,aAAT,CAAuB,KAAvB,CAAb;AACAD,MAAI,CAACE,KAAL,CAAWC,eAAX,GAA6BL,GAA7B,CANkC,CAOlC;;AACAE,MAAI,CAACE,KAAL,CAAWE,QAAX,GAAsB,UAAtB;AACAJ,MAAI,CAACE,KAAL,CAAWG,GAAX,GAAiB,SAAjB;AACAL,MAAI,CAACE,KAAL,CAAWI,IAAX,GAAkB,SAAlB;AACAN,MAAI,CAACE,KAAL,CAAWK,MAAX,GAAoB,KAApB;AACAP,MAAI,CAACE,KAAL,CAAWM,KAAX,GAAmB,KAAnB;AACAT,UAAQ,CAACU,IAAT,CAAcC,WAAd,CAA0BV,IAA1B;AACA,MAAMW,cAAc,GAAGC,gBAAgB,CAACZ,IAAD,CAAvC;AACA,MAAMa,aAAa,GAAGF,cAAc,IAAIA,cAAc,CAACR,eAAvD;AACAJ,UAAQ,CAACU,IAAT,CAAcK,WAAd,CAA0Bd,IAA1B,EAhBkC,CAiBlC;AAEA;AACA;;AACA,MAAIa,aAAa,KAAK,kBAAlB,IAAwCA,aAAa,KAAK,aAA9D,EAA6E;AAC3E,YAAQf,GAAG,CAACiB,IAAJ,EAAR;AACE;AACA,WAAK,aAAL;AACA,WAAK,OAAL;AACA,WAAK,WAAL;AACE,eAAO;AAAEC,WAAC,EAAE,CAAL;AAAQC,WAAC,EAAE,CAAX;AAAcC,WAAC,EAAE,CAAjB;AAAoBC,WAAC,EAAE;AAAvB,SAAP;AALJ;;AAOA,WAAO5B,SAAP;AACD;;AAED,SAAOE,KAAK,CAACoB,aAAD,CAAZ;AACD;AAED;;;;;;AAIA,SAASpB,KAAT,CAAeK,GAAf,EAAkC;AAChC,MAAI,CAACA,GAAL,EAAU;AACR,WAAOP,SAAP;AACD;;AAED,MAAM6B,KAAK,GAAGtB,GAAG,CAACsB,KAAJ,CAAU,yBAAV,CAAd;;AACA,MAAIA,KAAJ,EAAW;AACT,QAAMC,QAAQ,GAAG,CAAC,CAACD,KAAK,CAAC,CAAD,CAAxB;AACA,QAAME,iBAAiB,GAAGD,QAAQ,GAAG,CAAH,GAAO,CAAzC;AACA,QAAME,KAAK,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASI,KAAT,CAAe,OAAf,EAAwBC,GAAxB,CAA4BC,MAA5B,CAAd;;AAEA,QAAIH,KAAK,CAACI,MAAN,KAAiBL,iBAArB,EAAwC;AACtC,aAAO;AACLN,SAAC,EAAEO,KAAK,CAAC,CAAD,CADH;AAELN,SAAC,EAAEM,KAAK,CAAC,CAAD,CAFH;AAGLL,SAAC,EAAEK,KAAK,CAAC,CAAD,CAHH;AAILJ,SAAC,EAAEE,QAAQ,GAAGE,KAAK,CAAC,CAAD,CAAL,GAAW,GAAd,GAAoBpC;AAJ1B,OAAP;AAMD;AACF;AACF;AAED;;;;;;AAIA,SAASS,KAAT,CAAeE,GAAf,EAA0B;AACxB,MAAMsB,KAAK,GAAGtB,GAAG,CAACsB,KAAJ,CAAU,yBAAV,CAAd;;AACA,MAAIA,KAAJ,EAAW;AACT,QAAMC,QAAQ,GAAG,CAAC,CAACD,KAAK,CAAC,CAAD,CAAxB;AACA,QAAME,iBAAiB,GAAGD,QAAQ,GAAG,CAAH,GAAO,CAAzC;AACA,QAAME,KAAK,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASI,KAAT,CAAe,OAAf,EAAwBC,GAAxB,CAA4BC,MAA5B,CAAd;;AAEA,QAAIH,KAAK,CAACI,MAAN,KAAiBL,iBAArB,EAAwC;AACtC,UAAMM,IAAI,GAAGxC,OAAO,CAACmC,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqBA,KAAK,CAAC,CAAD,CAA1B,CAApB;AACAK,UAAI,CAACT,CAAL,GAASE,QAAQ,GAAGE,KAAK,CAAC,CAAD,CAAL,GAAW,GAAd,GAAoBpC,eAArC;AACA,aAAOyC,IAAP;AACD;AACF;AACF;AAED;;;;;;AAIA,SAASlC,KAAT,CAAeI,GAAf,EAA0B;AACxB,MAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBA,GAAG,CAAC6B,MAAJ,KAAe,CAAjC,IAAsC,mBAAmBE,IAAnB,CAAwB/B,GAAxB,CAA1C,EAAwE;AACtE,WAAO;AACLkB,OAAC,EAAEc,QAAQ,CAAChC,GAAG,CAACiC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAD,EAAkB,EAAlB,CADN;AAELd,OAAC,EAAEa,QAAQ,CAAChC,GAAG,CAACiC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAD,EAAkB,EAAlB,CAFN;AAGLb,OAAC,EAAEY,QAAQ,CAAChC,GAAG,CAACiC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAD,EAAkB,EAAlB,CAHN;AAILZ,OAAC,EAAEhC;AAJE,KAAP;AAMD;AACF;AAED;;;;;;AAIA,SAASQ,KAAT,CAAeG,GAAf,EAA0B;AACxB,MAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBA,GAAG,CAAC6B,MAAJ,KAAe,CAAjC,IAAsC,mBAAmBE,IAAnB,CAAwB/B,GAAxB,CAA1C,EAAwE;AACtE,WAAO;AACLkB,OAAC,EAAEc,QAAQ,CAAChC,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAb,EAAkB,EAAlB,CADN;AAELmB,OAAC,EAAEa,QAAQ,CAAChC,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAb,EAAkB,EAAlB,CAFN;AAGLoB,OAAC,EAAEY,QAAQ,CAAChC,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAb,EAAkB,EAAlB,CAHN;AAILqB,OAAC,EAAEhC;AAJE,KAAP;AAMD;AACF","names":["MAX_COLOR_ALPHA","hsl2rgb","cssColor","color","undefined","easyColor","_rgba","_hex6","_hex3","_hsla","_browserCompute","str","document","elem","createElement","style","backgroundColor","position","top","left","height","width","body","appendChild","eComputedStyle","getComputedStyle","computedColor","removeChild","trim","r","g","b","a","match","hasAlpha","expectedPartCount","parts","split","map","Number","length","rgba","test","parseInt","slice"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\utilities\\src\\utilities\\color\\cssColor.ts"],"sourcesContent":["import { IRGB } from './interfaces';\nimport { MAX_COLOR_ALPHA } from './consts';\nimport { hsl2rgb } from './hsl2rgb';\n\n/**\n * Converts a valid CSS color string to an RGB color.\n * Note that hex colors *must* be prefixed with # to be considered valid.\n * Alpha in returned color defaults to 100.\n * Four and eight digit hex values (with alpha) are supported if the current browser supports them.\n */\nexport function cssColor(color?: string): IRGB | undefined {\n  if (!color) {\n    return undefined;\n  }\n\n  // Need to check the following valid color formats: RGB(A), HSL(A), hex, named color\n\n  // First check for well formatted RGB(A), HSL(A), and hex formats at the start.\n  // This is for perf (no creating an element) and catches the intentional \"transparent\" color\n  //   case early on.\n  const easyColor: IRGB | undefined = _rgba(color) || _hex6(color) || _hex3(color) || _hsla(color);\n  if (easyColor) {\n    return easyColor;\n  }\n\n  // if the above fails, do the more expensive catch-all\n  return _browserCompute(color);\n}\n\n/**\n * Uses the browser's getComputedStyle() to determine what the passed-in color is.\n * This assumes _rgba, _hex6, _hex3, and _hsla have already been tried and all failed.\n * This works by attaching an element to the DOM, which may fail in server-side rendering\n *   or with headless browsers.\n */\nfunction _browserCompute(str: string): IRGB | undefined {\n  if (typeof document === 'undefined') {\n    // don't throw an error when used server-side\n    return undefined;\n  }\n  const elem = document.createElement('div');\n  elem.style.backgroundColor = str;\n  // This element must be attached to the DOM for getComputedStyle() to have a value\n  elem.style.position = 'absolute';\n  elem.style.top = '-9999px';\n  elem.style.left = '-9999px';\n  elem.style.height = '1px';\n  elem.style.width = '1px';\n  document.body.appendChild(elem);\n  const eComputedStyle = getComputedStyle(elem);\n  const computedColor = eComputedStyle && eComputedStyle.backgroundColor;\n  document.body.removeChild(elem);\n  // computedColor is always an RGB(A) string, except for invalid colors in IE/Edge which return 'transparent'\n\n  // browsers return one of these if the color string is invalid,\n  // so need to differentiate between an actual error and intentionally passing in this color\n  if (computedColor === 'rgba(0, 0, 0, 0)' || computedColor === 'transparent') {\n    switch (str.trim()) {\n      // RGB and HSL were already checked at the start of the function\n      case 'transparent':\n      case '#0000':\n      case '#00000000':\n        return { r: 0, g: 0, b: 0, a: 0 };\n    }\n    return undefined;\n  }\n\n  return _rgba(computedColor);\n}\n\n/**\n * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _rgba(str?: string | null): IRGB | undefined {\n  if (!str) {\n    return undefined;\n  }\n\n  const match = str.match(/^rgb(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    const hasAlpha = !!match[1];\n    const expectedPartCount = hasAlpha ? 4 : 3;\n    const parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      return {\n        r: parts[0],\n        g: parts[1],\n        b: parts[2],\n        a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA,\n      };\n    }\n  }\n}\n\n/**\n * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _hsla(str: string): IRGB | undefined {\n  const match = str.match(/^hsl(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    const hasAlpha = !!match[1];\n    const expectedPartCount = hasAlpha ? 4 : 3;\n    const parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      const rgba = hsl2rgb(parts[0], parts[1], parts[2]);\n      rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;\n      return rgba;\n    }\n  }\n}\n\n/**\n * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex6(str: string): IRGB | undefined {\n  if (str[0] === '#' && str.length === 7 && /^#[\\da-fA-F]{6}$/.test(str)) {\n    return {\n      r: parseInt(str.slice(1, 3), 16),\n      g: parseInt(str.slice(3, 5), 16),\n      b: parseInt(str.slice(5, 7), 16),\n      a: MAX_COLOR_ALPHA,\n    };\n  }\n}\n\n/**\n * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex3(str: string): IRGB | undefined {\n  if (str[0] === '#' && str.length === 4 && /^#[\\da-fA-F]{3}$/.test(str)) {\n    return {\n      r: parseInt(str[1] + str[1], 16),\n      g: parseInt(str[2] + str[2], 16),\n      b: parseInt(str[3] + str[3], 16),\n      a: MAX_COLOR_ALPHA,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}