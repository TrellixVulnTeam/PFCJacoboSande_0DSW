{"ast":null,"code":"var _a;\n\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar NO_FLIP = '@noflip';\nvar NAME_REPLACEMENTS = (_a = {}, _a[LEFT] = RIGHT, _a[RIGHT] = LEFT, _a);\nvar VALUE_REPLACEMENTS = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize'\n};\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\n\nexport function rtlifyRules(options, rulePairs, index) {\n  if (options.rtl) {\n    var name_1 = rulePairs[index];\n\n    if (!name_1) {\n      return;\n    }\n\n    var value = rulePairs[index + 1];\n\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name_1.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name_1.replace(LEFT, RIGHT);\n    } else if (name_1.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name_1.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name_1]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name_1];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name_1) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\n\nfunction negateNum(value, partIndex) {\n  var parts = value.split(' ');\n  var numberVal = parseInt(parts[partIndex], 10);\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n  return parts.join(' ');\n}\n/**\n * Given a string quad, flips the left and right values.\n */\n\n\nfunction flipQuad(value) {\n  if (typeof value === 'string') {\n    var parts = value.split(' ');\n\n    if (parts.length === 4) {\n      return parts[0] + \" \" + parts[3] + \" \" + parts[2] + \" \" + parts[1];\n    }\n  }\n\n  return value;\n}","map":{"version":3,"mappings":"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","names":["LEFT","RIGHT","NO_FLIP","NAME_REPLACEMENTS","_a","VALUE_REPLACEMENTS","rtlifyRules","options","rulePairs","index","rtl","name_1","value","indexOf","replace","String","flipQuad","negateNum","partIndex","parts","split","numberVal","parseInt","join","length"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\merge-styles\\lib\\src\\transforms\\rtlifyRules.ts"],"sourcesContent":["import { IStyleOptions } from '../IStyleOptions';\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst NO_FLIP = '@noflip';\nconst NAME_REPLACEMENTS: { [key: string]: string } = {\n  [LEFT]: RIGHT,\n  [RIGHT]: LEFT,\n};\nconst VALUE_REPLACEMENTS: { [key: string]: string } = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize',\n};\n\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options: IStyleOptions, rulePairs: (string | number)[], index: number): void {\n  if (options.rtl) {\n    const name = rulePairs[index] as string;\n\n    if (!name) {\n      return;\n    }\n\n    const value = rulePairs[index + 1] as string;\n\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name.replace(LEFT, RIGHT);\n    } else if (name.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value: string, partIndex: number): string {\n  const parts = value.split(' ');\n  const numberVal = parseInt(parts[partIndex], 10);\n\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n\n  return parts.join(' ');\n}\n\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value: string): string {\n  if (typeof value === 'string') {\n    const parts = value.split(' ');\n\n    if (parts.length === 4) {\n      return `${parts[0]} ${parts[3]} ${parts[2]} ${parts[1]}`;\n    }\n  }\n\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}