{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { css, KeyCodes, initializeComponentRef } from '../../../Utilities';\nimport { SuggestionsCore } from './SuggestionsCore';\nimport * as stylesImport from './SuggestionsControl.scss';\nimport { hiddenContentStyle, mergeStyles } from '../../../Styling';\nvar styles = stylesImport;\nexport var SuggestionItemType;\n\n(function (SuggestionItemType) {\n  SuggestionItemType[SuggestionItemType[\"header\"] = 0] = \"header\";\n  SuggestionItemType[SuggestionItemType[\"suggestion\"] = 1] = \"suggestion\";\n  SuggestionItemType[SuggestionItemType[\"footer\"] = 2] = \"footer\";\n})(SuggestionItemType || (SuggestionItemType = {}));\n\nvar SuggestionsHeaderFooterItem =\n/** @class */\nfunction (_super) {\n  __extends(SuggestionsHeaderFooterItem, _super);\n\n  function SuggestionsHeaderFooterItem(props) {\n    var _this = _super.call(this, props) || this;\n\n    initializeComponentRef(_this);\n    return _this;\n  }\n\n  SuggestionsHeaderFooterItem.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        renderItem = _b.renderItem,\n        onExecute = _b.onExecute,\n        isSelected = _b.isSelected,\n        id = _b.id,\n        className = _b.className;\n    return onExecute ? React.createElement(\"div\", {\n      id: id,\n      onClick: onExecute,\n      className: css('ms-Suggestions-sectionButton', className, styles.actionButton, (_a = {}, _a['is-selected ' + styles.buttonSelected] = isSelected, _a))\n    }, renderItem()) : React.createElement(\"div\", {\n      id: id,\n      className: css('ms-Suggestions-section', className, styles.suggestionsTitle)\n    }, renderItem());\n  };\n\n  return SuggestionsHeaderFooterItem;\n}(React.Component);\n\nexport { SuggestionsHeaderFooterItem };\n/**\n * Class when used with SuggestionsStore, renders a suggestions control with customizable headers and footers\n */\n\nvar SuggestionsControl =\n/** @class */\nfunction (_super) {\n  __extends(SuggestionsControl, _super);\n\n  function SuggestionsControl(suggestionsProps) {\n    var _this = _super.call(this, suggestionsProps) || this;\n\n    _this._selectedElement = React.createRef();\n    _this._suggestions = React.createRef();\n    _this.SuggestionsOfProperType = SuggestionsCore;\n    initializeComponentRef(_this);\n    _this.state = {\n      selectedHeaderIndex: -1,\n      selectedFooterIndex: -1,\n      suggestions: suggestionsProps.suggestions\n    };\n    return _this;\n  }\n\n  SuggestionsControl.prototype.componentDidMount = function () {\n    this.resetSelectedItem();\n  };\n\n  SuggestionsControl.prototype.componentDidUpdate = function () {\n    this.scrollSelected();\n  };\n\n  SuggestionsControl.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    var _this = this;\n\n    if (newProps.suggestions) {\n      this.setState({\n        suggestions: newProps.suggestions\n      }, function () {\n        _this.resetSelectedItem();\n      });\n    }\n  };\n\n  SuggestionsControl.prototype.componentWillUnmount = function () {\n    var _a;\n\n    (_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.deselectAllSuggestions();\n  };\n\n  SuggestionsControl.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        headerItemsProps = _a.headerItemsProps,\n        footerItemsProps = _a.footerItemsProps,\n        suggestionsAvailableAlertText = _a.suggestionsAvailableAlertText;\n    var screenReaderTextStyles = mergeStyles(hiddenContentStyle);\n    var shouldAlertSuggestionsAvailableText = this.state.suggestions && this.state.suggestions.length > 0 && suggestionsAvailableAlertText;\n    return React.createElement(\"div\", {\n      className: css('ms-Suggestions', className ? className : '', styles.root)\n    }, headerItemsProps && this.renderHeaderItems(), this._renderSuggestions(), footerItemsProps && this.renderFooterItems(), shouldAlertSuggestionsAvailableText ? React.createElement(\"span\", {\n      role: \"alert\",\n      \"aria-live\": \"polite\",\n      className: screenReaderTextStyles\n    }, suggestionsAvailableAlertText) : null);\n  };\n\n  Object.defineProperty(SuggestionsControl.prototype, \"currentSuggestion\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.getCurrentItem()) || undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SuggestionsControl.prototype, \"currentSuggestionIndex\", {\n    get: function () {\n      return this._suggestions.current ? this._suggestions.current.currentIndex : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SuggestionsControl.prototype, \"selectedElement\", {\n    get: function () {\n      var _a;\n\n      return this._selectedElement.current ? this._selectedElement.current : (_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.selectedElement;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SuggestionsControl.prototype.hasSuggestionSelected = function () {\n    var _a;\n\n    return ((_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.hasSuggestionSelected()) || false;\n  };\n\n  SuggestionsControl.prototype.hasSelection = function () {\n    var _a = this.state,\n        selectedHeaderIndex = _a.selectedHeaderIndex,\n        selectedFooterIndex = _a.selectedFooterIndex;\n    return selectedHeaderIndex !== -1 || this.hasSuggestionSelected() || selectedFooterIndex !== -1;\n  };\n\n  SuggestionsControl.prototype.executeSelectedAction = function () {\n    var _a;\n\n    var _b = this.props,\n        headerItemsProps = _b.headerItemsProps,\n        footerItemsProps = _b.footerItemsProps;\n    var _c = this.state,\n        selectedHeaderIndex = _c.selectedHeaderIndex,\n        selectedFooterIndex = _c.selectedFooterIndex;\n\n    if (headerItemsProps && selectedHeaderIndex !== -1 && selectedHeaderIndex < headerItemsProps.length) {\n      var selectedHeaderItem = headerItemsProps[selectedHeaderIndex];\n\n      if (selectedHeaderItem.onExecute) {\n        selectedHeaderItem.onExecute();\n      }\n    } else if ((_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.hasSuggestionSelected()) {\n      this.props.completeSuggestion();\n    } else if (footerItemsProps && selectedFooterIndex !== -1 && selectedFooterIndex < footerItemsProps.length) {\n      var selectedFooterItem = footerItemsProps[selectedFooterIndex];\n\n      if (selectedFooterItem.onExecute) {\n        selectedFooterItem.onExecute();\n      }\n    }\n  };\n\n  SuggestionsControl.prototype.removeSuggestion = function (index) {\n    var _a, _b;\n\n    (_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.removeSuggestion(index ? index : (_b = this._suggestions.current) === null || _b === void 0 ? void 0 : _b.currentIndex);\n  };\n  /**\n   * Handles the key down, returns true, if the event was handled, false otherwise\n   * @param keyCode - The keyCode to handle\n   */\n\n\n  SuggestionsControl.prototype.handleKeyDown = function (keyCode) {\n    var _a, _b, _c, _d;\n\n    var _e = this.state,\n        selectedHeaderIndex = _e.selectedHeaderIndex,\n        selectedFooterIndex = _e.selectedFooterIndex;\n    var isKeyDownHandled = false;\n\n    if (keyCode === KeyCodes.down) {\n      if (selectedHeaderIndex === -1 && !((_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.hasSuggestionSelected()) && selectedFooterIndex === -1) {\n        this.selectFirstItem();\n      } else if (selectedHeaderIndex !== -1) {\n        this.selectNextItem(SuggestionItemType.header);\n        isKeyDownHandled = true;\n      } else if ((_b = this._suggestions.current) === null || _b === void 0 ? void 0 : _b.hasSuggestionSelected()) {\n        this.selectNextItem(SuggestionItemType.suggestion);\n        isKeyDownHandled = true;\n      } else if (selectedFooterIndex !== -1) {\n        this.selectNextItem(SuggestionItemType.footer);\n        isKeyDownHandled = true;\n      }\n    } else if (keyCode === KeyCodes.up) {\n      if (selectedHeaderIndex === -1 && !((_c = this._suggestions.current) === null || _c === void 0 ? void 0 : _c.hasSuggestionSelected()) && selectedFooterIndex === -1) {\n        this.selectLastItem();\n      } else if (selectedHeaderIndex !== -1) {\n        this.selectPreviousItem(SuggestionItemType.header);\n        isKeyDownHandled = true;\n      } else if ((_d = this._suggestions.current) === null || _d === void 0 ? void 0 : _d.hasSuggestionSelected()) {\n        this.selectPreviousItem(SuggestionItemType.suggestion);\n        isKeyDownHandled = true;\n      } else if (selectedFooterIndex !== -1) {\n        this.selectPreviousItem(SuggestionItemType.footer);\n        isKeyDownHandled = true;\n      }\n    } else if (keyCode === KeyCodes.enter || keyCode === KeyCodes.tab) {\n      if (this.hasSelection()) {\n        this.executeSelectedAction();\n        isKeyDownHandled = true;\n      }\n    }\n\n    return isKeyDownHandled;\n  }; // TODO get the element to scroll into view properly regardless of direction.\n\n\n  SuggestionsControl.prototype.scrollSelected = function () {\n    if (this._selectedElement.current) {\n      this._selectedElement.current.scrollIntoView(false);\n    }\n  };\n\n  SuggestionsControl.prototype.renderHeaderItems = function () {\n    var _this = this;\n\n    var _a = this.props,\n        headerItemsProps = _a.headerItemsProps,\n        suggestionsHeaderContainerAriaLabel = _a.suggestionsHeaderContainerAriaLabel;\n    var selectedHeaderIndex = this.state.selectedHeaderIndex;\n    return headerItemsProps ? React.createElement(\"div\", {\n      className: css('ms-Suggestions-headerContainer', styles.suggestionsContainer),\n      id: \"suggestionHeader-list\",\n      role: \"list\",\n      \"aria-label\": suggestionsHeaderContainerAriaLabel\n    }, headerItemsProps.map(function (headerItemProps, index) {\n      var isSelected = selectedHeaderIndex !== -1 && selectedHeaderIndex === index;\n      return headerItemProps.shouldShow() ? React.createElement(\"div\", {\n        ref: isSelected ? _this._selectedElement : undefined,\n        id: 'sug-header' + index,\n        key: 'sug-header' + index,\n        role: \"listitem\",\n        \"aria-label\": headerItemProps.ariaLabel\n      }, React.createElement(SuggestionsHeaderFooterItem, {\n        id: 'sug-header-item' + index,\n        isSelected: isSelected,\n        renderItem: headerItemProps.renderItem,\n        onExecute: headerItemProps.onExecute,\n        className: headerItemProps.className\n      })) : null;\n    })) : null;\n  };\n\n  SuggestionsControl.prototype.renderFooterItems = function () {\n    var _this = this;\n\n    var _a = this.props,\n        footerItemsProps = _a.footerItemsProps,\n        suggestionsFooterContainerAriaLabel = _a.suggestionsFooterContainerAriaLabel;\n    var selectedFooterIndex = this.state.selectedFooterIndex;\n    return footerItemsProps ? React.createElement(\"div\", {\n      className: css('ms-Suggestions-footerContainer', styles.suggestionsContainer),\n      id: \"suggestionFooter-list\",\n      role: \"list\",\n      \"aria-label\": suggestionsFooterContainerAriaLabel\n    }, footerItemsProps.map(function (footerItemProps, index) {\n      var isSelected = selectedFooterIndex !== -1 && selectedFooterIndex === index;\n      return footerItemProps.shouldShow() ? React.createElement(\"div\", {\n        ref: isSelected ? _this._selectedElement : undefined,\n        id: 'sug-footer' + index,\n        key: 'sug-footer' + index,\n        role: \"listitem\",\n        \"aria-label\": footerItemProps.ariaLabel\n      }, React.createElement(SuggestionsHeaderFooterItem, {\n        id: 'sug-footer-item' + index,\n        isSelected: isSelected,\n        renderItem: footerItemProps.renderItem,\n        onExecute: footerItemProps.onExecute,\n        className: footerItemProps.className\n      })) : null;\n    })) : null;\n  };\n\n  SuggestionsControl.prototype._renderSuggestions = function () {\n    var TypedSuggestions = this.SuggestionsOfProperType;\n    return React.createElement(TypedSuggestions, __assign({\n      ref: this._suggestions\n    }, this.props, {\n      suggestions: this.state.suggestions\n    }));\n  };\n  /**\n   * Selects the next selectable item\n   */\n\n\n  SuggestionsControl.prototype.selectNextItem = function (itemType, originalItemType) {\n    // If the recursive calling has not found a selectable item in the other suggestion item type groups\n    // And the method is being called again with the original item type,\n    // Select the first selectable item of this suggestion item type group (could be the currently selected item)\n    if (itemType === originalItemType) {\n      this._selectNextItemOfItemType(itemType);\n\n      return;\n    }\n\n    var startedItemType = originalItemType !== undefined ? originalItemType : itemType; // Try to set the selection to the next selectable item, of the same suggestion item type group\n    // If this is the original item type, use the current index\n\n    var selectionChanged = this._selectNextItemOfItemType(itemType, startedItemType === itemType ? this._getCurrentIndexForType(itemType) : undefined); // If the selection did not change, try to select from the next suggestion type group\n\n\n    if (!selectionChanged) {\n      this.selectNextItem(this._getNextItemSectionType(itemType), startedItemType);\n    }\n  };\n  /**\n   * Selects the previous selectable item\n   */\n\n\n  SuggestionsControl.prototype.selectPreviousItem = function (itemType, originalItemType) {\n    // If the recursive calling has not found a selectable item in the other suggestion item type groups\n    // And the method is being called again with the original item type,\n    // Select the last selectable item of this suggestion item type group (could be the currently selected item)\n    if (itemType === originalItemType) {\n      this._selectPreviousItemOfItemType(itemType);\n\n      return;\n    }\n\n    var startedItemType = originalItemType !== undefined ? originalItemType : itemType; // Try to set the selection to the previous selectable item, of the same suggestion item type group\n\n    var selectionChanged = this._selectPreviousItemOfItemType(itemType, startedItemType === itemType ? this._getCurrentIndexForType(itemType) : undefined); // If the selection did not change, try to select from the previous suggestion type group\n\n\n    if (!selectionChanged) {\n      this.selectPreviousItem(this._getPreviousItemSectionType(itemType), startedItemType);\n    }\n  };\n  /**\n   * Resets the selected state and selects the first selectable item\n   */\n\n\n  SuggestionsControl.prototype.resetSelectedItem = function () {\n    var _a;\n\n    this.setState({\n      selectedHeaderIndex: -1,\n      selectedFooterIndex: -1\n    });\n    (_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.deselectAllSuggestions(); // Select the first item if the shouldSelectFirstItem prop is not set or it is set and it returns true\n\n    if (this.props.shouldSelectFirstItem === undefined || this.props.shouldSelectFirstItem()) {\n      this.selectFirstItem();\n    }\n  };\n  /**\n   * Selects the first item\n   */\n\n\n  SuggestionsControl.prototype.selectFirstItem = function () {\n    if (this._selectNextItemOfItemType(SuggestionItemType.header)) {\n      return;\n    }\n\n    if (this._selectNextItemOfItemType(SuggestionItemType.suggestion)) {\n      return;\n    }\n\n    this._selectNextItemOfItemType(SuggestionItemType.footer);\n  };\n  /**\n   * Selects the last item\n   */\n\n\n  SuggestionsControl.prototype.selectLastItem = function () {\n    if (this._selectPreviousItemOfItemType(SuggestionItemType.footer)) {\n      return;\n    }\n\n    if (this._selectPreviousItemOfItemType(SuggestionItemType.suggestion)) {\n      return;\n    }\n\n    this._selectPreviousItemOfItemType(SuggestionItemType.header);\n  };\n  /**\n   * Selects the next item in the suggestion item type group, given the current index\n   * If none is able to be selected, returns false, otherwise returns true\n   * @param itemType - The suggestion item type\n   * @param currentIndex - The current index, default is -1\n   */\n\n\n  SuggestionsControl.prototype._selectNextItemOfItemType = function (itemType, currentIndex) {\n    if (currentIndex === void 0) {\n      currentIndex = -1;\n    }\n\n    var _a, _b;\n\n    if (itemType === SuggestionItemType.suggestion) {\n      if (this.state.suggestions.length > currentIndex + 1) {\n        (_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.setSelectedSuggestion(currentIndex + 1);\n        this.setState({\n          selectedHeaderIndex: -1,\n          selectedFooterIndex: -1\n        });\n        return true;\n      }\n    } else {\n      var isHeader = itemType === SuggestionItemType.header;\n      var itemProps = isHeader ? this.props.headerItemsProps : this.props.footerItemsProps;\n\n      if (itemProps && itemProps.length > currentIndex + 1) {\n        for (var i = currentIndex + 1; i < itemProps.length; i++) {\n          var item = itemProps[i];\n\n          if (item.onExecute && item.shouldShow()) {\n            this.setState({\n              selectedHeaderIndex: isHeader ? i : -1\n            });\n            this.setState({\n              selectedFooterIndex: isHeader ? -1 : i\n            });\n            (_b = this._suggestions.current) === null || _b === void 0 ? void 0 : _b.deselectAllSuggestions();\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Selects the previous item in the suggestion item type group, given the current index\n   * If none is able to be selected, returns false, otherwise returns true\n   * @param itemType - The suggestion item type\n   * @param currentIndex - The current index. If none is provided, the default is the items length of specified type\n   */\n\n\n  SuggestionsControl.prototype._selectPreviousItemOfItemType = function (itemType, currentIndex) {\n    var _a, _b;\n\n    if (itemType === SuggestionItemType.suggestion) {\n      var index = currentIndex !== undefined ? currentIndex : this.state.suggestions.length;\n\n      if (index > 0) {\n        (_a = this._suggestions.current) === null || _a === void 0 ? void 0 : _a.setSelectedSuggestion(index - 1);\n        this.setState({\n          selectedHeaderIndex: -1,\n          selectedFooterIndex: -1\n        });\n        return true;\n      }\n    } else {\n      var isHeader = itemType === SuggestionItemType.header;\n      var itemProps = isHeader ? this.props.headerItemsProps : this.props.footerItemsProps;\n\n      if (itemProps) {\n        var index = currentIndex !== undefined ? currentIndex : itemProps.length;\n\n        if (index > 0) {\n          for (var i = index - 1; i >= 0; i--) {\n            var item = itemProps[i];\n\n            if (item.onExecute && item.shouldShow()) {\n              this.setState({\n                selectedHeaderIndex: isHeader ? i : -1\n              });\n              this.setState({\n                selectedFooterIndex: isHeader ? -1 : i\n              });\n              (_b = this._suggestions.current) === null || _b === void 0 ? void 0 : _b.deselectAllSuggestions();\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  SuggestionsControl.prototype._getCurrentIndexForType = function (itemType) {\n    switch (itemType) {\n      case SuggestionItemType.header:\n        return this.state.selectedHeaderIndex;\n\n      case SuggestionItemType.suggestion:\n        return this._suggestions.current.currentIndex;\n\n      case SuggestionItemType.footer:\n        return this.state.selectedFooterIndex;\n    }\n  };\n\n  SuggestionsControl.prototype._getNextItemSectionType = function (itemType) {\n    switch (itemType) {\n      case SuggestionItemType.header:\n        return SuggestionItemType.suggestion;\n\n      case SuggestionItemType.suggestion:\n        return SuggestionItemType.footer;\n\n      case SuggestionItemType.footer:\n        return SuggestionItemType.header;\n    }\n  };\n\n  SuggestionsControl.prototype._getPreviousItemSectionType = function (itemType) {\n    switch (itemType) {\n      case SuggestionItemType.header:\n        return SuggestionItemType.footer;\n\n      case SuggestionItemType.suggestion:\n        return SuggestionItemType.header;\n\n      case SuggestionItemType.footer:\n        return SuggestionItemType.suggestion;\n    }\n  };\n\n  return SuggestionsControl;\n}(React.Component);\n\nexport { SuggestionsControl };","map":{"version":3,"mappings":"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","names":["React","css","KeyCodes","initializeComponentRef","SuggestionsCore","stylesImport","hiddenContentStyle","mergeStyles","styles","SuggestionItemType","__extends","props","_super","_this","SuggestionsHeaderFooterItem","renderItem","onExecute","isSelected","id","className","onClick","actionButton","_a","buttonSelected","suggestionsTitle","Component","suggestionsProps","createRef","state","selectedHeaderIndex","selectedFooterIndex","suggestions","SuggestionsControl","resetSelectedItem","scrollSelected","newProps","setState","_suggestions","current","deselectAllSuggestions","headerItemsProps","footerItemsProps","suggestionsAvailableAlertText","screenReaderTextStyles","shouldAlertSuggestionsAvailableText","length","root","renderHeaderItems","_renderSuggestions","renderFooterItems","role","Object","getCurrentItem","undefined","currentIndex","_selectedElement","selectedElement","hasSuggestionSelected","selectedHeaderItem","completeSuggestion","selectedFooterItem","index","removeSuggestion","_b","keyCode","isKeyDownHandled","down","selectFirstItem","selectNextItem","header","suggestion","footer","up","_c","selectLastItem","selectPreviousItem","_d","enter","tab","hasSelection","executeSelectedAction","scrollIntoView","suggestionsHeaderContainerAriaLabel","suggestionsContainer","map","headerItemProps","shouldShow","ref","key","ariaLabel","suggestionsFooterContainerAriaLabel","footerItemProps","TypedSuggestions","SuggestionsOfProperType","__assign","itemType","originalItemType","_selectNextItemOfItemType","startedItemType","selectionChanged","_getCurrentIndexForType","_getNextItemSectionType","_selectPreviousItemOfItemType","_getPreviousItemSectionType","shouldSelectFirstItem","setSelectedSuggestion","isHeader","itemProps","i","item"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\FloatingPicker\\src\\components\\FloatingPicker\\Suggestions\\SuggestionsControl.tsx"],"sourcesContent":["import * as React from 'react';\nimport { css, KeyCodes, initializeComponentRef } from '../../../Utilities';\nimport { IButton } from '../../../Button';\nimport { ISuggestionModel } from '../../../Pickers';\nimport {\n  ISuggestionsHeaderFooterItemProps,\n  ISuggestionsControlProps,\n  ISuggestionsCoreProps,\n  ISuggestionsHeaderFooterProps,\n} from './Suggestions.types';\nimport { SuggestionsCore } from './SuggestionsCore';\nimport * as stylesImport from './SuggestionsControl.scss';\nimport { hiddenContentStyle, mergeStyles } from '../../../Styling';\n\nconst styles: any = stylesImport;\n\nexport enum SuggestionItemType {\n  header,\n  suggestion,\n  footer,\n}\n\nexport interface ISuggestionsControlState<T> {\n  selectedHeaderIndex: number;\n  selectedFooterIndex: number;\n  suggestions: ISuggestionModel<T>[];\n}\n\nexport class SuggestionsHeaderFooterItem extends React.Component<ISuggestionsHeaderFooterItemProps, {}> {\n  constructor(props: ISuggestionsHeaderFooterItemProps) {\n    super(props);\n\n    initializeComponentRef(this);\n  }\n\n  public render(): JSX.Element {\n    const { renderItem, onExecute, isSelected, id, className } = this.props;\n    return onExecute ? (\n      <div\n        id={id}\n        onClick={onExecute}\n        className={css('ms-Suggestions-sectionButton', className, styles.actionButton, {\n          ['is-selected ' + styles.buttonSelected]: isSelected,\n        })}\n      >\n        {renderItem()}\n      </div>\n    ) : (\n      <div id={id} className={css('ms-Suggestions-section', className, styles.suggestionsTitle)}>\n        {renderItem()}\n      </div>\n    );\n  }\n}\n\n/**\n * Class when used with SuggestionsStore, renders a suggestions control with customizable headers and footers\n */\nexport class SuggestionsControl<T> extends React.Component<ISuggestionsControlProps<T>, ISuggestionsControlState<T>> {\n  protected _forceResolveButton: IButton;\n  protected _searchForMoreButton: IButton;\n  protected _selectedElement = React.createRef<HTMLDivElement>();\n  protected _suggestions = React.createRef<SuggestionsCore<T>>();\n  private SuggestionsOfProperType: new (props: ISuggestionsCoreProps<T>) => SuggestionsCore<\n    T\n  > = SuggestionsCore as new (props: ISuggestionsCoreProps<T>) => SuggestionsCore<T>;\n\n  constructor(suggestionsProps: ISuggestionsControlProps<T>) {\n    super(suggestionsProps);\n\n    initializeComponentRef(this);\n    this.state = {\n      selectedHeaderIndex: -1,\n      selectedFooterIndex: -1,\n      suggestions: suggestionsProps.suggestions,\n    };\n  }\n\n  public componentDidMount(): void {\n    this.resetSelectedItem();\n  }\n\n  public componentDidUpdate(): void {\n    this.scrollSelected();\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: ISuggestionsControlProps<T>): void {\n    if (newProps.suggestions) {\n      this.setState({ suggestions: newProps.suggestions }, () => {\n        this.resetSelectedItem();\n      });\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._suggestions.current?.deselectAllSuggestions();\n  }\n\n  public render(): JSX.Element {\n    const { className, headerItemsProps, footerItemsProps, suggestionsAvailableAlertText } = this.props;\n\n    const screenReaderTextStyles = mergeStyles(hiddenContentStyle);\n    const shouldAlertSuggestionsAvailableText =\n      this.state.suggestions && this.state.suggestions.length > 0 && suggestionsAvailableAlertText;\n\n    return (\n      <div className={css('ms-Suggestions', className ? className : '', styles.root)}>\n        {headerItemsProps && this.renderHeaderItems()}\n        {this._renderSuggestions()}\n        {footerItemsProps && this.renderFooterItems()}\n        {shouldAlertSuggestionsAvailableText ? (\n          <span role=\"alert\" aria-live=\"polite\" className={screenReaderTextStyles}>\n            {suggestionsAvailableAlertText}\n          </span>\n        ) : null}\n      </div>\n    );\n  }\n\n  public get currentSuggestion(): ISuggestionModel<T> | undefined {\n    return this._suggestions.current?.getCurrentItem() || undefined;\n  }\n\n  public get currentSuggestionIndex(): number {\n    return this._suggestions.current ? this._suggestions.current.currentIndex : -1;\n  }\n\n  public get selectedElement(): HTMLDivElement | undefined {\n    return this._selectedElement.current ? this._selectedElement.current : this._suggestions.current?.selectedElement;\n  }\n\n  public hasSuggestionSelected(): boolean {\n    return this._suggestions.current?.hasSuggestionSelected() || false;\n  }\n\n  public hasSelection(): boolean {\n    const { selectedHeaderIndex, selectedFooterIndex } = this.state;\n    return selectedHeaderIndex !== -1 || this.hasSuggestionSelected() || selectedFooterIndex !== -1;\n  }\n\n  public executeSelectedAction(): void {\n    const { headerItemsProps, footerItemsProps } = this.props;\n    const { selectedHeaderIndex, selectedFooterIndex } = this.state;\n\n    if (headerItemsProps && selectedHeaderIndex !== -1 && selectedHeaderIndex < headerItemsProps.length) {\n      const selectedHeaderItem = headerItemsProps[selectedHeaderIndex];\n      if (selectedHeaderItem.onExecute) {\n        selectedHeaderItem.onExecute();\n      }\n    } else if (this._suggestions.current?.hasSuggestionSelected()) {\n      this.props.completeSuggestion();\n    } else if (footerItemsProps && selectedFooterIndex !== -1 && selectedFooterIndex < footerItemsProps.length) {\n      const selectedFooterItem = footerItemsProps[selectedFooterIndex];\n      if (selectedFooterItem.onExecute) {\n        selectedFooterItem.onExecute();\n      }\n    }\n  }\n\n  public removeSuggestion(index?: number): void {\n    this._suggestions.current?.removeSuggestion(index ? index : this._suggestions.current?.currentIndex);\n  }\n\n  /**\n   * Handles the key down, returns true, if the event was handled, false otherwise\n   * @param keyCode - The keyCode to handle\n   */\n  public handleKeyDown(keyCode: number): boolean {\n    const { selectedHeaderIndex, selectedFooterIndex } = this.state;\n    let isKeyDownHandled = false;\n    if (keyCode === KeyCodes.down) {\n      if (\n        selectedHeaderIndex === -1 &&\n        !this._suggestions.current?.hasSuggestionSelected() &&\n        selectedFooterIndex === -1\n      ) {\n        this.selectFirstItem();\n      } else if (selectedHeaderIndex !== -1) {\n        this.selectNextItem(SuggestionItemType.header);\n        isKeyDownHandled = true;\n      } else if (this._suggestions.current?.hasSuggestionSelected()) {\n        this.selectNextItem(SuggestionItemType.suggestion);\n        isKeyDownHandled = true;\n      } else if (selectedFooterIndex !== -1) {\n        this.selectNextItem(SuggestionItemType.footer);\n        isKeyDownHandled = true;\n      }\n    } else if (keyCode === KeyCodes.up) {\n      if (\n        selectedHeaderIndex === -1 &&\n        !this._suggestions.current?.hasSuggestionSelected() &&\n        selectedFooterIndex === -1\n      ) {\n        this.selectLastItem();\n      } else if (selectedHeaderIndex !== -1) {\n        this.selectPreviousItem(SuggestionItemType.header);\n        isKeyDownHandled = true;\n      } else if (this._suggestions.current?.hasSuggestionSelected()) {\n        this.selectPreviousItem(SuggestionItemType.suggestion);\n        isKeyDownHandled = true;\n      } else if (selectedFooterIndex !== -1) {\n        this.selectPreviousItem(SuggestionItemType.footer);\n        isKeyDownHandled = true;\n      }\n    } else if (keyCode === KeyCodes.enter || keyCode === KeyCodes.tab) {\n      if (this.hasSelection()) {\n        this.executeSelectedAction();\n        isKeyDownHandled = true;\n      }\n    }\n\n    return isKeyDownHandled;\n  }\n\n  // TODO get the element to scroll into view properly regardless of direction.\n  public scrollSelected(): void {\n    if (this._selectedElement.current) {\n      this._selectedElement.current.scrollIntoView(false);\n    }\n  }\n\n  protected renderHeaderItems(): JSX.Element | null {\n    const { headerItemsProps, suggestionsHeaderContainerAriaLabel } = this.props;\n    const { selectedHeaderIndex } = this.state;\n\n    return headerItemsProps ? (\n      <div\n        className={css('ms-Suggestions-headerContainer', styles.suggestionsContainer)}\n        id=\"suggestionHeader-list\"\n        role=\"list\"\n        aria-label={suggestionsHeaderContainerAriaLabel}\n      >\n        {headerItemsProps.map((headerItemProps: ISuggestionsHeaderFooterProps, index: number) => {\n          const isSelected = selectedHeaderIndex !== -1 && selectedHeaderIndex === index;\n          return headerItemProps.shouldShow() ? (\n            <div\n              ref={isSelected ? this._selectedElement : undefined}\n              id={'sug-header' + index}\n              key={'sug-header' + index}\n              role=\"listitem\"\n              aria-label={headerItemProps.ariaLabel}\n            >\n              <SuggestionsHeaderFooterItem\n                id={'sug-header-item' + index}\n                isSelected={isSelected}\n                renderItem={headerItemProps.renderItem}\n                onExecute={headerItemProps.onExecute}\n                className={headerItemProps.className}\n              />\n            </div>\n          ) : null;\n        })}\n      </div>\n    ) : null;\n  }\n\n  protected renderFooterItems(): JSX.Element | null {\n    const { footerItemsProps, suggestionsFooterContainerAriaLabel } = this.props;\n    const { selectedFooterIndex } = this.state;\n    return footerItemsProps ? (\n      <div\n        className={css('ms-Suggestions-footerContainer', styles.suggestionsContainer)}\n        id=\"suggestionFooter-list\"\n        role=\"list\"\n        aria-label={suggestionsFooterContainerAriaLabel}\n      >\n        {footerItemsProps.map((footerItemProps: ISuggestionsHeaderFooterProps, index: number) => {\n          const isSelected = selectedFooterIndex !== -1 && selectedFooterIndex === index;\n          return footerItemProps.shouldShow() ? (\n            <div\n              ref={isSelected ? this._selectedElement : undefined}\n              id={'sug-footer' + index}\n              key={'sug-footer' + index}\n              role=\"listitem\"\n              aria-label={footerItemProps.ariaLabel}\n            >\n              <SuggestionsHeaderFooterItem\n                id={'sug-footer-item' + index}\n                isSelected={isSelected}\n                renderItem={footerItemProps.renderItem}\n                onExecute={footerItemProps.onExecute}\n                className={footerItemProps.className}\n              />\n            </div>\n          ) : null;\n        })}\n      </div>\n    ) : null;\n  }\n\n  protected _renderSuggestions(): JSX.Element {\n    const TypedSuggestions = this.SuggestionsOfProperType;\n\n    return <TypedSuggestions ref={this._suggestions} {...this.props} suggestions={this.state.suggestions} />;\n  }\n\n  /**\n   * Selects the next selectable item\n   */\n  protected selectNextItem(itemType: SuggestionItemType, originalItemType?: SuggestionItemType): void {\n    // If the recursive calling has not found a selectable item in the other suggestion item type groups\n    // And the method is being called again with the original item type,\n    // Select the first selectable item of this suggestion item type group (could be the currently selected item)\n    if (itemType === originalItemType) {\n      this._selectNextItemOfItemType(itemType);\n      return;\n    }\n\n    const startedItemType = originalItemType !== undefined ? originalItemType : itemType;\n\n    // Try to set the selection to the next selectable item, of the same suggestion item type group\n    // If this is the original item type, use the current index\n    const selectionChanged = this._selectNextItemOfItemType(\n      itemType,\n      startedItemType === itemType ? this._getCurrentIndexForType(itemType) : undefined,\n    );\n\n    // If the selection did not change, try to select from the next suggestion type group\n    if (!selectionChanged) {\n      this.selectNextItem(this._getNextItemSectionType(itemType), startedItemType);\n    }\n  }\n\n  /**\n   * Selects the previous selectable item\n   */\n  protected selectPreviousItem(itemType: SuggestionItemType, originalItemType?: SuggestionItemType): void {\n    // If the recursive calling has not found a selectable item in the other suggestion item type groups\n    // And the method is being called again with the original item type,\n    // Select the last selectable item of this suggestion item type group (could be the currently selected item)\n    if (itemType === originalItemType) {\n      this._selectPreviousItemOfItemType(itemType);\n      return;\n    }\n\n    const startedItemType = originalItemType !== undefined ? originalItemType : itemType;\n\n    // Try to set the selection to the previous selectable item, of the same suggestion item type group\n    const selectionChanged = this._selectPreviousItemOfItemType(\n      itemType,\n      startedItemType === itemType ? this._getCurrentIndexForType(itemType) : undefined,\n    );\n\n    // If the selection did not change, try to select from the previous suggestion type group\n    if (!selectionChanged) {\n      this.selectPreviousItem(this._getPreviousItemSectionType(itemType), startedItemType);\n    }\n  }\n\n  /**\n   * Resets the selected state and selects the first selectable item\n   */\n  protected resetSelectedItem(): void {\n    this.setState({ selectedHeaderIndex: -1, selectedFooterIndex: -1 });\n    this._suggestions.current?.deselectAllSuggestions();\n\n    // Select the first item if the shouldSelectFirstItem prop is not set or it is set and it returns true\n    if (this.props.shouldSelectFirstItem === undefined || this.props.shouldSelectFirstItem()) {\n      this.selectFirstItem();\n    }\n  }\n\n  /**\n   * Selects the first item\n   */\n  protected selectFirstItem(): void {\n    if (this._selectNextItemOfItemType(SuggestionItemType.header)) {\n      return;\n    }\n\n    if (this._selectNextItemOfItemType(SuggestionItemType.suggestion)) {\n      return;\n    }\n\n    this._selectNextItemOfItemType(SuggestionItemType.footer);\n  }\n\n  /**\n   * Selects the last item\n   */\n  protected selectLastItem(): void {\n    if (this._selectPreviousItemOfItemType(SuggestionItemType.footer)) {\n      return;\n    }\n\n    if (this._selectPreviousItemOfItemType(SuggestionItemType.suggestion)) {\n      return;\n    }\n\n    this._selectPreviousItemOfItemType(SuggestionItemType.header);\n  }\n\n  /**\n   * Selects the next item in the suggestion item type group, given the current index\n   * If none is able to be selected, returns false, otherwise returns true\n   * @param itemType - The suggestion item type\n   * @param currentIndex - The current index, default is -1\n   */\n  private _selectNextItemOfItemType(itemType: SuggestionItemType, currentIndex: number = -1): boolean {\n    if (itemType === SuggestionItemType.suggestion) {\n      if (this.state.suggestions.length > currentIndex + 1) {\n        this._suggestions.current?.setSelectedSuggestion(currentIndex + 1);\n        this.setState({ selectedHeaderIndex: -1, selectedFooterIndex: -1 });\n        return true;\n      }\n    } else {\n      const isHeader = itemType === SuggestionItemType.header;\n      const itemProps = isHeader ? this.props.headerItemsProps : this.props.footerItemsProps;\n\n      if (itemProps && itemProps.length > currentIndex + 1) {\n        for (let i = currentIndex + 1; i < itemProps.length; i++) {\n          const item = itemProps[i];\n          if (item.onExecute && item.shouldShow()) {\n            this.setState({ selectedHeaderIndex: isHeader ? i : -1 });\n            this.setState({ selectedFooterIndex: isHeader ? -1 : i });\n            this._suggestions.current?.deselectAllSuggestions();\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects the previous item in the suggestion item type group, given the current index\n   * If none is able to be selected, returns false, otherwise returns true\n   * @param itemType - The suggestion item type\n   * @param currentIndex - The current index. If none is provided, the default is the items length of specified type\n   */\n  private _selectPreviousItemOfItemType(itemType: SuggestionItemType, currentIndex?: number): boolean {\n    if (itemType === SuggestionItemType.suggestion) {\n      const index = currentIndex !== undefined ? currentIndex : this.state.suggestions.length;\n      if (index > 0) {\n        this._suggestions.current?.setSelectedSuggestion(index - 1);\n        this.setState({ selectedHeaderIndex: -1, selectedFooterIndex: -1 });\n        return true;\n      }\n    } else {\n      const isHeader = itemType === SuggestionItemType.header;\n      const itemProps = isHeader ? this.props.headerItemsProps : this.props.footerItemsProps;\n      if (itemProps) {\n        const index = currentIndex !== undefined ? currentIndex : itemProps.length;\n        if (index > 0) {\n          for (let i = index - 1; i >= 0; i--) {\n            const item = itemProps[i];\n            if (item.onExecute && item.shouldShow()) {\n              this.setState({ selectedHeaderIndex: isHeader ? i : -1 });\n              this.setState({ selectedFooterIndex: isHeader ? -1 : i });\n              this._suggestions.current?.deselectAllSuggestions();\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private _getCurrentIndexForType(itemType: SuggestionItemType): number {\n    switch (itemType) {\n      case SuggestionItemType.header:\n        return this.state.selectedHeaderIndex;\n      case SuggestionItemType.suggestion:\n        return this._suggestions.current!.currentIndex;\n      case SuggestionItemType.footer:\n        return this.state.selectedFooterIndex;\n    }\n  }\n\n  private _getNextItemSectionType(itemType: SuggestionItemType): SuggestionItemType {\n    switch (itemType) {\n      case SuggestionItemType.header:\n        return SuggestionItemType.suggestion;\n      case SuggestionItemType.suggestion:\n        return SuggestionItemType.footer;\n      case SuggestionItemType.footer:\n        return SuggestionItemType.header;\n    }\n  }\n\n  private _getPreviousItemSectionType(itemType: SuggestionItemType): SuggestionItemType {\n    switch (itemType) {\n      case SuggestionItemType.header:\n        return SuggestionItemType.footer;\n      case SuggestionItemType.suggestion:\n        return SuggestionItemType.header;\n      case SuggestionItemType.footer:\n        return SuggestionItemType.suggestion;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}