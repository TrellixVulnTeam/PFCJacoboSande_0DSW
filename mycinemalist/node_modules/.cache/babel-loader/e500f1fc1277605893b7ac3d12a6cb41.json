{"ast":null,"code":"var _a;\n\nimport { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer'; // Utilites/Helpers\n\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, getWindow, getDocument, initializeComponentRef, Async, EventGroup } from '../../../Utilities';\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../utilities/positioning';\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n}; // In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\n\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = 'slideUpIn20', _a[RectangleEdge.bottom] = 'slideDownIn20', _a[RectangleEdge.left] = 'slideLeftIn20', _a[RectangleEdge.right] = 'slideRightIn20', _a);\n\nvar PositioningContainer =\n/** @class */\nfunction (_super) {\n  __extends(PositioningContainer, _super);\n\n  function PositioningContainer(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The primary positioned div.\n     */\n\n\n    _this._positionedHost = React.createRef(); // @TODO rename to reflect the name of this class\n\n    _this._contentHost = React.createRef();\n    /**\n     * Deprecated, use `onResize` instead.\n     * @deprecated Use `onResize` instead.\n     */\n\n    _this.dismiss = function (ev) {\n      _this.onResize(ev);\n    };\n\n    _this.onResize = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev);\n      } else {\n        _this._updateAsyncPosition();\n      }\n    };\n\n    _this._setInitialFocus = function () {\n      if (_this._contentHost.current && _this.props.setInitialFocus && !_this._didSetInitialFocus && _this.state.positions) {\n        _this._didSetInitialFocus = true;\n        focusFirstChild(_this._contentHost.current);\n      }\n    };\n\n    _this._onComponentDidMount = function () {\n      // This is added so the positioningContainer will dismiss when the window is scrolled\n      // but not when something inside the positioningContainer is scrolled. The delay seems\n      // to be required to avoid React firing an async focus event in IE from\n      // the target changing focus quickly prior to rendering the positioningContainer.\n      _this._async.setTimeout(function () {\n        _this._events.on(_this._targetWindow, 'scroll', _this._async.throttle(_this._dismissOnScroll, 10), true);\n\n        _this._events.on(_this._targetWindow, 'resize', _this._async.throttle(_this.onResize, 10), true);\n\n        _this._events.on(_this._targetWindow.document.body, 'focus', _this._dismissOnLostFocus, true);\n\n        _this._events.on(_this._targetWindow.document.body, 'click', _this._dismissOnLostFocus, true);\n      }, 0);\n\n      if (_this.props.onLayerMounted) {\n        _this.props.onLayerMounted();\n      }\n\n      _this._updateAsyncPosition();\n\n      _this._setHeightOffsetEveryFrame();\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._didSetInitialFocus = false;\n    _this.state = {\n      positions: undefined,\n      heightOffset: 0\n    };\n    _this._positionAttempts = 0;\n    return _this;\n  }\n\n  PositioningContainer.prototype.UNSAFE_componentWillMount = function () {\n    this._setTargetWindowAndElement(this._getTarget());\n  };\n\n  PositioningContainer.prototype.componentDidMount = function () {\n    this._onComponentDidMount();\n  };\n\n  PositioningContainer.prototype.componentDidUpdate = function () {\n    this._setInitialFocus();\n\n    this._updateAsyncPosition();\n  };\n\n  PositioningContainer.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    var newTarget = this._getTarget(newProps);\n\n    var oldTarget = this._getTarget();\n\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  };\n\n  PositioningContainer.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  PositioningContainer.prototype.render = function () {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    var _a = this.props,\n        className = _a.className,\n        positioningContainerWidth = _a.positioningContainerWidth,\n        positioningContainerMaxHeight = _a.positioningContainerMaxHeight,\n        children = _a.children;\n    var positions = this.state.positions;\n    var styles = getClassNames();\n    var directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n    var getContentMaxHeight = this._getMaxHeight() + this.state.heightOffset;\n    var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n    var content = React.createElement(\"div\", {\n      ref: this._positionedHost,\n      className: css('ms-PositioningContainer', styles.container)\n    }, React.createElement(\"div\", {\n      className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n        width: positioningContainerWidth\n      }),\n      style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n      // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n      tabIndex: -1,\n      ref: this._contentHost\n    }, children, // @TODO apply to the content container\n    contentMaxHeight));\n    return this.props.doNotLayer ? content : React.createElement(Layer, null, content);\n  };\n\n  PositioningContainer.prototype._dismissOnScroll = function (ev) {\n    var preventDismissOnScroll = this.props.preventDismissOnScroll;\n\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  };\n\n  PositioningContainer.prototype._dismissOnLostFocus = function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = this._positionedHost.current && !elementContains(this._positionedHost.current, target);\n\n    if (!this._target && clickedOutsideCallout || ev.target !== this._targetWindow && clickedOutsideCallout && (this._target.stopPropagation || !this._target || target !== this._target && !elementContains(this._target, target))) {\n      this.onResize(ev);\n    }\n  };\n\n  PositioningContainer.prototype._updateAsyncPosition = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      return _this._updatePosition();\n    });\n  };\n\n  PositioningContainer.prototype._updatePosition = function () {\n    var positions = this.state.positions;\n    var _a = this.props,\n        offsetFromTarget = _a.offsetFromTarget,\n        onPositioned = _a.onPositioned;\n    var hostElement = this._positionedHost.current;\n    var positioningContainerElement = this._contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      var currentProps = __assign({}, this.props);\n\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target;\n\n      if (document.body.contains(currentProps.target)) {\n        currentProps.gapSpace = offsetFromTarget;\n        var newPositions_1 = positionElement(currentProps, hostElement, positioningContainerElement); // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n\n        if (!positions && newPositions_1 || positions && newPositions_1 && !this._arePositionsEqual(positions, newPositions_1) && this._positionAttempts < 5) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState({\n            positions: newPositions_1\n          }, function () {\n            if (onPositioned) {\n              onPositioned(newPositions_1);\n            }\n          });\n        } else {\n          this._positionAttempts = 0;\n\n          if (onPositioned) {\n            onPositioned(newPositions_1);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined\n        });\n      }\n    }\n  };\n\n  PositioningContainer.prototype._getBounds = function () {\n    if (!this._positioningBounds) {\n      var currentBounds = this.props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding,\n          left: 0 + this.props.minPagePadding,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding * 2\n        };\n      }\n\n      this._positioningBounds = currentBounds;\n    }\n\n    return this._positioningBounds;\n  };\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n\n\n  PositioningContainer.prototype._getMaxHeight = function () {\n    var _a = this.props,\n        directionalHintFixed = _a.directionalHintFixed,\n        offsetFromTarget = _a.offsetFromTarget,\n        directionalHint = _a.directionalHint;\n\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = getMaxHeight(this._target, directionalHint, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n\n    return this._maxHeight;\n  };\n\n  PositioningContainer.prototype._arePositionsEqual = function (positions, newPosition) {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  };\n\n  PositioningContainer.prototype._comparePositions = function (oldPositions, newPositions) {\n    for (var key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        var oldPositionEdge = oldPositions[key];\n        var newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  PositioningContainer.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._positionedHost.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument();\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement); // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if ( // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && ( // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  };\n  /**\n   * Animates the height if finalHeight was given.\n   */\n\n\n  PositioningContainer.prototype._setHeightOffsetEveryFrame = function () {\n    var _this = this;\n\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {\n        if (!_this._contentHost.current) {\n          return;\n        }\n\n        var positioningContainerMainElem = _this._contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n\n        _this.setState({\n          heightOffset: _this.state.heightOffset + scrollDiff\n        });\n\n        if (positioningContainerMainElem.offsetHeight < _this.props.finalHeight) {\n          _this._setHeightOffsetEveryFrame();\n        } else {\n          _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer);\n        }\n      });\n    }\n  };\n\n  PositioningContainer.prototype._getTarget = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var target = props.target;\n    return target;\n  };\n\n  PositioningContainer.defaultProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge\n  };\n  return PositioningContainer;\n}(React.Component);\n\nexport { PositioningContainer };","map":{"version":3,"mappings":"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","names":["React","getClassNames","Layer","DirectionalHint","css","elementContains","focusFirstChild","getWindow","getDocument","initializeComponentRef","Async","EventGroup","getMaxHeight","positionElement","RectangleEdge","AnimationClassNames","mergeStyles","OFF_SCREEN_STYLE","opacity","BORDER_WIDTH","SLIDE_ANIMATIONS","_a","top","bottom","left","right","__extends","props","_super","_this","createRef","ev","onResize","onDismiss","_updateAsyncPosition","_contentHost","current","setInitialFocus","_didSetInitialFocus","state","positions","_async","setTimeout","_events","on","_targetWindow","throttle","_dismissOnScroll","document","body","_dismissOnLostFocus","onLayerMounted","_setHeightOffsetEveryFrame","undefined","heightOffset","_positionAttempts","PositioningContainer","_setTargetWindowAndElement","_getTarget","_onComponentDidMount","_setInitialFocus","newProps","newTarget","oldTarget","String","_maxHeight","offsetFromTarget","finalHeight","dispose","className","positioningContainerWidth","positioningContainerMaxHeight","children","styles","directionalClassName","targetEdge","getContentMaxHeight","_getMaxHeight","contentMaxHeight","content","ref","_positionedHost","container","root","width","style","elementPosition","tabIndex","doNotLayer","preventDismissOnScroll","target","clickedOutsideCallout","_target","stopPropagation","requestAnimationFrame","_updatePosition","onPositioned","hostElement","positioningContainerElement","currentProps","bounds","_getBounds","contains","gapSpace","newPositions_1","_arePositionsEqual","setState","_positioningBounds","currentBounds","minPagePadding","innerWidth","innerHeight","height","directionalHintFixed","directionalHint","newPosition","_comparePositions","oldPositions","newPositions","key","hasOwnProperty","oldPositionEdge","newPositionEdge","toFixed","currentElement","currentDoc","querySelector","x","y","targetElement","_setHeightOffsetTimer","positioningContainerMainElem","lastChild","cardScrollHeight","scrollHeight","cardCurrHeight","offsetHeight","scrollDiff","cancelAnimationFrame","bottomAutoEdge","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\Coachmark\\src\\components\\Coachmark\\PositioningContainer\\PositioningContainer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { IPositioningContainerProps } from './PositioningContainer.types';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer';\n\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport {\n  Point,\n  IRectangle,\n  css,\n  elementContains,\n  focusFirstChild,\n  getWindow,\n  getDocument,\n  initializeComponentRef,\n  Async,\n  EventGroup,\n} from '../../../Utilities';\n\nimport {\n  getMaxHeight,\n  positionElement,\n  IPositionedData,\n  IPositionProps,\n  IPosition,\n  RectangleEdge,\n} from '../../../utilities/positioning';\n\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\n\nconst OFF_SCREEN_STYLE = { opacity: 0 };\n\n// In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\nconst BORDER_WIDTH = 1;\nconst SLIDE_ANIMATIONS: { [key: number]: string } = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20',\n};\n\nexport interface IPositioningContainerState {\n  /**\n   * Current set of calcualted positions for the outermost parent container.\n   */\n  positions?: IPositionedData;\n\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n  heightOffset?: number;\n}\n\nexport class PositioningContainer extends React.Component<IPositioningContainerProps, IPositioningContainerState>\n  implements PositioningContainer {\n  public static defaultProps: IPositioningContainerProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n  };\n\n  private _didSetInitialFocus: boolean;\n\n  /**\n   * The primary positioned div.\n   */\n  private _positionedHost = React.createRef<HTMLDivElement>();\n\n  // @TODO rename to reflect the name of this class\n  private _contentHost = React.createRef<HTMLDivElement>();\n\n  /**\n   * Stores an instance of Window, used to check\n   * for server side rendering and if focus was lost.\n   */\n  private _targetWindow: Window;\n\n  /**\n   * The bounds used when determing if and where the\n   * PositioningContainer should be placed.\n   */\n  private _positioningBounds: IRectangle;\n\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going being the window or target bounds\n   */\n  private _maxHeight: number | undefined;\n  private _positionAttempts: number;\n  private _target: HTMLElement | MouseEvent | Point | null;\n  private _setHeightOffsetTimer: number;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IPositioningContainerProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this._didSetInitialFocus = false;\n    this.state = {\n      positions: undefined,\n      heightOffset: 0,\n    };\n    this._positionAttempts = 0;\n  }\n\n  public UNSAFE_componentWillMount(): void {\n    this._setTargetWindowAndElement(this._getTarget());\n  }\n\n  public componentDidMount(): void {\n    this._onComponentDidMount();\n  }\n\n  public componentDidUpdate(): void {\n    this._setInitialFocus();\n    this._updateAsyncPosition();\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: IPositioningContainerProps): void {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    const newTarget = this._getTarget(newProps);\n    const oldTarget = this._getTarget();\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    const { className, positioningContainerWidth, positioningContainerMaxHeight, children } = this.props;\n    const { positions } = this.state;\n\n    const styles = getClassNames();\n\n    const directionalClassName =\n      positions && positions.targetEdge ? (AnimationClassNames as any)[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n\n    const getContentMaxHeight: number = this._getMaxHeight() + this.state.heightOffset!;\n    const contentMaxHeight: number =\n      positioningContainerMaxHeight! && positioningContainerMaxHeight! > getContentMaxHeight\n        ? getContentMaxHeight\n        : positioningContainerMaxHeight!;\n    const content = (\n      <div ref={this._positionedHost} className={css('ms-PositioningContainer', styles.container)}>\n        <div\n          className={mergeStyles(\n            'ms-PositioningContainer-layerHost',\n            styles.root,\n            className,\n            directionalClassName,\n            !!positioningContainerWidth && { width: positioningContainerWidth },\n          )}\n          style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={this._contentHost}\n        >\n          {children}\n          {\n            // @TODO apply to the content container\n            contentMaxHeight\n          }\n        </div>\n      </div>\n    );\n\n    return this.props.doNotLayer ? content : <Layer>{content}</Layer>;\n  }\n\n  /**\n   * Deprecated, use `onResize` instead.\n   * @deprecated Use `onResize` instead.\n   */\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    this.onResize(ev);\n  };\n\n  public onResize = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      this._updateAsyncPosition();\n    }\n  };\n\n  protected _dismissOnScroll(ev: Event): void {\n    const { preventDismissOnScroll } = this.props;\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  }\n\n  protected _dismissOnLostFocus(ev: Event): void {\n    const target = ev.target as HTMLElement;\n    const clickedOutsideCallout =\n      this._positionedHost.current && !elementContains(this._positionedHost.current, target);\n\n    if (\n      (!this._target && clickedOutsideCallout) ||\n      (ev.target !== this._targetWindow &&\n        clickedOutsideCallout &&\n        ((this._target as MouseEvent).stopPropagation ||\n          !this._target ||\n          (target !== this._target && !elementContains(this._target as HTMLElement, target))))\n    ) {\n      this.onResize(ev);\n    }\n  }\n\n  protected _setInitialFocus = (): void => {\n    if (this._contentHost.current && this.props.setInitialFocus && !this._didSetInitialFocus && this.state.positions) {\n      this._didSetInitialFocus = true;\n      focusFirstChild(this._contentHost.current);\n    }\n  };\n\n  protected _onComponentDidMount = (): void => {\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    this._async.setTimeout(() => {\n      this._events.on(this._targetWindow, 'scroll', this._async.throttle(this._dismissOnScroll, 10), true);\n      this._events.on(this._targetWindow, 'resize', this._async.throttle(this.onResize, 10), true);\n      this._events.on(this._targetWindow.document.body, 'focus', this._dismissOnLostFocus, true);\n      this._events.on(this._targetWindow.document.body, 'click', this._dismissOnLostFocus, true);\n    }, 0);\n\n    if (this.props.onLayerMounted) {\n      this.props.onLayerMounted();\n    }\n\n    this._updateAsyncPosition();\n    this._setHeightOffsetEveryFrame();\n  };\n\n  private _updateAsyncPosition(): void {\n    this._async.requestAnimationFrame(() => this._updatePosition());\n  }\n\n  private _updatePosition(): void {\n    const { positions } = this.state;\n    const { offsetFromTarget, onPositioned } = this.props;\n\n    const hostElement = this._positionedHost.current;\n    const positioningContainerElement = this._contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      const currentProps: IPositionProps = { ...(this.props as any) };\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target!;\n      if (document.body.contains(currentProps.target as Node)) {\n        currentProps.gapSpace = offsetFromTarget;\n        const newPositions: IPositionedData = positionElement(currentProps, hostElement, positioningContainerElement);\n        // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n        if (\n          (!positions && newPositions) ||\n          (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)\n        ) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState(\n            {\n              positions: newPositions,\n            },\n            () => {\n              if (onPositioned) {\n                onPositioned(newPositions);\n              }\n            },\n          );\n        } else {\n          this._positionAttempts = 0;\n          if (onPositioned) {\n            onPositioned(newPositions);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined,\n        });\n      }\n    }\n  }\n\n  private _getBounds(): IRectangle {\n    if (!this._positioningBounds) {\n      let currentBounds = this.props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding!,\n          left: 0 + this.props.minPagePadding!,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding!,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding!,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding! * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding! * 2,\n        };\n      }\n      this._positioningBounds = currentBounds;\n    }\n    return this._positioningBounds;\n  }\n\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  private _getMaxHeight(): number {\n    const { directionalHintFixed, offsetFromTarget, directionalHint } = this.props;\n\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        const gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = getMaxHeight(this._target, directionalHint!, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height! - BORDER_WIDTH * 2;\n      }\n    }\n    return this._maxHeight!;\n  }\n\n  private _arePositionsEqual(positions: IPositionedData, newPosition: IPositionedData): boolean {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  }\n\n  private _comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n    for (const key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        const oldPositionEdge = oldPositions[key];\n        const newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  private _setTargetWindowAndElement(target: HTMLElement | string | MouseEvent | Point | null): void {\n    const currentElement = this._positionedHost.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument()!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as HTMLElement) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target;\n      } else if (\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).left !== undefined || (target as Point).x !== undefined) &&\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).top !== undefined || (target as Point).y !== undefined)\n      ) {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target;\n      } else {\n        const targetElement: HTMLElement = target as HTMLElement;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  /**\n   * Animates the height if finalHeight was given.\n   */\n  private _setHeightOffsetEveryFrame(): void {\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {\n        if (!this._contentHost.current) {\n          return;\n        }\n\n        const positioningContainerMainElem = this._contentHost.current.lastChild as HTMLElement;\n        const cardScrollHeight: number = positioningContainerMainElem.scrollHeight;\n        const cardCurrHeight: number = positioningContainerMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        this.setState({\n          heightOffset: this.state.heightOffset! + scrollDiff,\n        });\n\n        if (positioningContainerMainElem.offsetHeight < this.props.finalHeight!) {\n          this._setHeightOffsetEveryFrame();\n        } else {\n          this._async.cancelAnimationFrame(this._setHeightOffsetTimer);\n        }\n      });\n    }\n  }\n\n  private _getTarget(props: IPositioningContainerProps = this.props): HTMLElement | string | MouseEvent | Point | null {\n    const { target } = props;\n    return target!;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}