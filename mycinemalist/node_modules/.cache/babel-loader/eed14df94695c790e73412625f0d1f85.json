{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { buttonProperties, getNativeProps, memoizeFunction, getId, mergeAriaAttributeValues } from '../../../Utilities';\nimport { ContextualMenuItemWrapper } from './ContextualMenuItemWrapper';\nimport { KeytipData } from '../../../KeytipData';\nimport { getIsChecked, isItemDisabled, hasSubmenu, getMenuItemAriaRole } from '../../../utilities/contextualMenu/index';\nimport { ContextualMenuItem } from '../ContextualMenuItem';\n\nvar ContextualMenuButton =\n/** @class */\nfunction (_super) {\n  __extends(ContextualMenuButton, _super);\n\n  function ContextualMenuButton() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._btn = React.createRef();\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return __assign(__assign({}, keytipProps), {\n        hasMenu: true\n      });\n    });\n\n    _this._renderAriaDescription = function (ariaDescription, className) {\n      // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan\n      return ariaDescription ? React.createElement(\"span\", {\n        id: _this._ariaDescriptionId,\n        className: className\n      }, ariaDescription) : null;\n    };\n\n    _this._getSubmenuTarget = function () {\n      return _this._btn.current ? _this._btn.current : undefined;\n    };\n\n    return _this;\n  }\n\n  ContextualMenuButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        item = _a.item,\n        classNames = _a.classNames,\n        index = _a.index,\n        focusableElementIndex = _a.focusableElementIndex,\n        totalItemCount = _a.totalItemCount,\n        hasCheckmarks = _a.hasCheckmarks,\n        hasIcons = _a.hasIcons,\n        _b = _a.contextualMenuItemAs,\n        ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b,\n        expandedMenuItemKey = _a.expandedMenuItemKey,\n        onItemMouseDown = _a.onItemMouseDown,\n        onItemClick = _a.onItemClick,\n        openSubMenu = _a.openSubMenu,\n        dismissSubMenu = _a.dismissSubMenu,\n        dismissMenu = _a.dismissMenu;\n\n    var subMenuId = this._getSubMenuId(item);\n\n    var isChecked = getIsChecked(item);\n    var canCheck = isChecked !== null;\n    var defaultRole = getMenuItemAriaRole(item);\n    var itemHasSubmenu = hasSubmenu(item);\n    var itemProps = item.itemProps,\n        ariaLabel = item.ariaLabel,\n        ariaDescription = item.ariaDescription;\n    var buttonNativeProperties = getNativeProps(item, buttonProperties); // Do not add the disabled attribute to the button so that it is focusable\n\n    delete buttonNativeProperties.disabled;\n    var itemRole = item.role || defaultRole; // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with\n    // the description in it to be added to ariaDescribedBy\n\n    if (ariaDescription) {\n      this._ariaDescriptionId = getId();\n    }\n\n    var ariaDescribedByIds = ariaDescription ? this._ariaDescriptionId : undefined;\n    var itemButtonProperties = {\n      className: classNames.root,\n      onClick: this._onItemClick,\n      onKeyDown: itemHasSubmenu ? this._onItemKeyDown : undefined,\n      onMouseEnter: this._onItemMouseEnter,\n      onMouseLeave: this._onItemMouseLeave,\n      onMouseDown: function onMouseDown(ev) {\n        return onItemMouseDown ? onItemMouseDown(item, ev) : undefined;\n      },\n      onMouseMove: this._onItemMouseMove,\n      href: item.href,\n      title: item.title,\n      'aria-label': ariaLabel,\n      'aria-describedby': ariaDescribedByIds,\n      'aria-haspopup': itemHasSubmenu || undefined,\n      'aria-owns': item.key === expandedMenuItemKey ? subMenuId : undefined,\n      'aria-expanded': itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,\n      'aria-posinset': focusableElementIndex + 1,\n      'aria-setsize': totalItemCount,\n      'aria-disabled': isItemDisabled(item),\n      'aria-checked': (itemRole === 'menuitemcheckbox' || itemRole === 'menuitemradio') && canCheck ? !!isChecked : undefined,\n      'aria-selected': itemRole === 'menuitem' && canCheck ? !!isChecked : undefined,\n      role: itemRole,\n      // eslint-disable-next-line deprecation/deprecation\n      style: item.style\n    };\n    var keytipProps = item.keytipProps;\n\n    if (keytipProps && itemHasSubmenu) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    return React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      ariaDescribedBy: buttonNativeProperties['aria-describedby'],\n      disabled: isItemDisabled(item)\n    }, function (keytipAttributes) {\n      return React.createElement(\"button\", __assign({\n        ref: _this._btn\n      }, buttonNativeProperties, itemButtonProperties, keytipAttributes, {\n        \"aria-describedby\": mergeAriaAttributeValues(itemButtonProperties['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined)\n      }), React.createElement(ChildrenRenderer, __assign({\n        componentRef: item.componentRef,\n        item: item,\n        classNames: classNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined,\n        hasIcons: hasIcons,\n        openSubMenu: openSubMenu,\n        dismissSubMenu: dismissSubMenu,\n        dismissMenu: dismissMenu,\n        getSubmenuTarget: _this._getSubmenuTarget\n      }, itemProps)), _this._renderAriaDescription(ariaDescription, classNames.screenReaderText));\n    });\n  };\n\n  return ContextualMenuButton;\n}(ContextualMenuItemWrapper);\n\nexport { ContextualMenuButton };","map":{"version":3,"mappings":"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","names":["React","buttonProperties","getNativeProps","memoizeFunction","getId","mergeAriaAttributeValues","ContextualMenuItemWrapper","KeytipData","getIsChecked","isItemDisabled","hasSubmenu","getMenuItemAriaRole","ContextualMenuItem","__extends","_this","createRef","keytipProps","hasMenu","ariaDescription","className","id","_ariaDescriptionId","_btn","current","undefined","ContextualMenuButton","item","classNames","index","focusableElementIndex","totalItemCount","hasCheckmarks","hasIcons","_b","ChildrenRenderer","expandedMenuItemKey","onItemMouseDown","onItemClick","openSubMenu","dismissSubMenu","dismissMenu","subMenuId","_getSubMenuId","isChecked","canCheck","defaultRole","itemHasSubmenu","ariaLabel","buttonNativeProperties","disabled","itemRole","role","ariaDescribedByIds","itemButtonProperties","root","onClick","_onItemClick","onKeyDown","_onItemKeyDown","onMouseEnter","_onItemMouseEnter","onMouseLeave","_onItemMouseLeave","onMouseDown","ev","onMouseMove","_onItemMouseMove","href","title","key","style","_getMemoizedMenuButtonKeytipProps","ariaDescribedBy","keytipAttributes","ref","__assign","componentRef","onCheckmarkClick","getSubmenuTarget","_getSubmenuTarget","itemProps","_renderAriaDescription","screenReaderText"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\ContextualMenu\\src\\components\\ContextualMenu\\ContextualMenuItemWrapper\\ContextualMenuButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport { buttonProperties, getNativeProps, memoizeFunction, getId, mergeAriaAttributeValues } from '../../../Utilities';\nimport { ContextualMenuItemWrapper } from './ContextualMenuItemWrapper';\nimport { KeytipData } from '../../../KeytipData';\nimport { getIsChecked, isItemDisabled, hasSubmenu, getMenuItemAriaRole } from '../../../utilities/contextualMenu/index';\nimport { ContextualMenuItem } from '../ContextualMenuItem';\nimport { IKeytipProps } from '../../Keytip/Keytip.types';\n\nexport class ContextualMenuButton extends ContextualMenuItemWrapper {\n  private _btn = React.createRef<HTMLButtonElement>();\n  private _ariaDescriptionId: string;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true,\n    };\n  });\n\n  public render() {\n    const {\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n      contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem,\n      expandedMenuItemKey,\n      onItemMouseDown,\n      onItemClick,\n      openSubMenu,\n      dismissSubMenu,\n      dismissMenu,\n    } = this.props;\n\n    const subMenuId = this._getSubMenuId(item);\n\n    const isChecked: boolean | null | undefined = getIsChecked(item);\n    const canCheck: boolean = isChecked !== null;\n    const defaultRole = getMenuItemAriaRole(item);\n    const itemHasSubmenu = hasSubmenu(item);\n    const { itemProps, ariaLabel, ariaDescription } = item;\n\n    const buttonNativeProperties = getNativeProps<React.ButtonHTMLAttributes<HTMLButtonElement>>(\n      item,\n      buttonProperties,\n    );\n    // Do not add the disabled attribute to the button so that it is focusable\n    delete buttonNativeProperties.disabled;\n\n    const itemRole = item.role || defaultRole;\n\n    // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with\n    // the description in it to be added to ariaDescribedBy\n    if (ariaDescription) {\n      this._ariaDescriptionId = getId();\n    }\n    const ariaDescribedByIds = ariaDescription ? this._ariaDescriptionId : undefined;\n\n    const itemButtonProperties = {\n      className: classNames.root,\n      onClick: this._onItemClick,\n      onKeyDown: itemHasSubmenu ? this._onItemKeyDown : undefined,\n      onMouseEnter: this._onItemMouseEnter,\n      onMouseLeave: this._onItemMouseLeave,\n      onMouseDown: (ev: React.MouseEvent<HTMLButtonElement>) =>\n        onItemMouseDown ? onItemMouseDown(item, ev) : undefined,\n      onMouseMove: this._onItemMouseMove,\n      href: item.href,\n      title: item.title,\n      'aria-label': ariaLabel,\n      'aria-describedby': ariaDescribedByIds,\n      'aria-haspopup': itemHasSubmenu || undefined,\n      'aria-owns': item.key === expandedMenuItemKey ? subMenuId : undefined,\n      'aria-expanded': itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,\n      'aria-posinset': focusableElementIndex + 1,\n      'aria-setsize': totalItemCount,\n      'aria-disabled': isItemDisabled(item),\n      'aria-checked':\n        (itemRole === 'menuitemcheckbox' || itemRole === 'menuitemradio') && canCheck ? !!isChecked : undefined,\n      'aria-selected': itemRole === 'menuitem' && canCheck ? !!isChecked : undefined,\n      role: itemRole,\n      // eslint-disable-next-line deprecation/deprecation\n      style: item.style,\n    };\n\n    let { keytipProps } = item;\n    if (keytipProps && itemHasSubmenu) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    return (\n      <KeytipData\n        keytipProps={keytipProps}\n        ariaDescribedBy={buttonNativeProperties['aria-describedby']}\n        disabled={isItemDisabled(item)}\n      >\n        {(keytipAttributes: any): JSX.Element => (\n          <button\n            ref={this._btn}\n            {...buttonNativeProperties}\n            {...itemButtonProperties}\n            {...keytipAttributes}\n            aria-describedby={mergeAriaAttributeValues(\n              itemButtonProperties['aria-describedby'],\n              keytipAttributes ? keytipAttributes['aria-describedby'] : undefined,\n            )}\n          >\n            <ChildrenRenderer\n              componentRef={item.componentRef}\n              item={item}\n              classNames={classNames}\n              index={index}\n              onCheckmarkClick={hasCheckmarks && onItemClick ? onItemClick : undefined}\n              hasIcons={hasIcons}\n              openSubMenu={openSubMenu}\n              dismissSubMenu={dismissSubMenu}\n              dismissMenu={dismissMenu}\n              getSubmenuTarget={this._getSubmenuTarget}\n              {...itemProps}\n            />\n            {this._renderAriaDescription(ariaDescription, classNames.screenReaderText)}\n          </button>\n        )}\n      </KeytipData>\n    );\n  }\n\n  protected _renderAriaDescription = (ariaDescription?: string, className?: string) => {\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan\n    return ariaDescription ? (\n      <span id={this._ariaDescriptionId} className={className}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  protected _getSubmenuTarget = (): HTMLElement | undefined => {\n    return this._btn.current ? this._btn.current : undefined;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}