{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { initializeComponentRef, warnMutuallyExclusive, Async, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues, getNativeProps, divProperties } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\n\nvar SpinButton =\n/** @class */\nfunction (_super) {\n  __extends(SpinButton, _super);\n\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n\n      _this._input.current.select();\n\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n\n      _this.setState({\n        isFocused: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n          precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\n     * Validate function to use if one is not passed in\n     */\n\n\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n\n    _this._onIncrement = function (value, event) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value, event);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n          max = _a.max,\n          step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n\n    _this._onDecrement = function (value, event) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value, event);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n          min = _a.min,\n          step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\n     * This is used when validating text entry in the input on blur or when enter key is pressed\n     * (not when changed via the buttons).\n     * @param event - the event that fired\n     */\n\n\n    _this._validate = function (event) {\n      if (_this.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event); // Done validating this value, so clear it\n\n\n        _this._valueToValidate = undefined;\n\n        if (newValue !== undefined) {\n          _this._lastValidValue = newValue;\n\n          _this.setState({\n            value: newValue\n          });\n        } else {\n          // Value was invalid. Reset state to last valid value.\n          _this.setState({\n            value: _this._lastValidValue\n          });\n        }\n      }\n    };\n    /**\n     * The method is needed to ensure we are updating the actual input value.\n     * without this our value will never change (and validation will not have the correct number)\n     * @param event - the event that was fired\n     */\n\n\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n\n      _this.setState({\n        value: value\n      });\n    };\n    /**\n     * Update the value with the given stepFunction\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n     * when spinning in response to a mouseDown\n     * @param stepFunction - function to use to step by\n     * @param event - The event that triggered the updateValue\n     */\n\n\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction, event) {\n      var newValue = stepFunction(_this.value || '', event);\n\n      if (newValue !== undefined) {\n        _this._lastValidValue = newValue;\n\n        _this.setState({\n          value: newValue\n        });\n      }\n\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction, event);\n        }, stepDelay);\n      }\n    };\n    /**\n     * Stop spinning (clear any currently pending update and set spinning to false)\n     */\n\n\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n\n        _this._currentStepFunctionHandle = -1;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\n     * Handle keydown on the text field. We need to update\n     * the value when up or down arrow are depressed\n     * @param event - the keyboardEvent that was fired\n     */\n\n\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.props.disabled) {\n        _this._stop();\n\n        return;\n      }\n\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onIncrement, event);\n\n          break;\n\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onDecrement, event);\n\n          break;\n\n        case KeyCodes.enter:\n          _this._validate(event);\n\n          break;\n\n        case KeyCodes.escape:\n          if (_this.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n\n          break;\n\n        default:\n          break;\n      } // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n\n\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\n     * Make sure that we have stopped spinning on keyUp\n     * if the up or down arrow fired this event\n     * @param event - keyboard event\n     */\n\n\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n\n        return;\n      }\n    };\n\n    _this._onIncrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onIncrement, event);\n    };\n\n    _this._onDecrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onDecrement, event);\n    };\n\n    initializeComponentRef(_this);\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    }); // Don't use || here because it won't handle empty strings properly\n\n    var _a = props.value,\n        value = _a === void 0 ? props.defaultValue : _a;\n\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n\n    _this._lastValidValue = value; // Ensure that the autocalculated precision is not negative.\n\n    _this._precision = _this._calculatePrecision(props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._async = new Async(_this);\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n\n  SpinButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n\n\n  SpinButton.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({\n        value: newProps.value\n      });\n    }\n\n    this._precision = this._calculatePrecision(newProps);\n  };\n\n  SpinButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        max = _a.max,\n        labelPosition = _a.labelPosition,\n        iconProps = _a.iconProps,\n        incrementButtonIcon = _a.incrementButtonIcon,\n        incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n        decrementButtonIcon = _a.decrementButtonIcon,\n        decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        customStyles = _a.styles,\n        customUpArrowButtonStyles = _a.upArrowButtonStyles,\n        customDownArrowButtonStyles = _a.downArrowButtonStyles,\n        theme = _a.theme,\n        ariaPositionInSet = _a.ariaPositionInSet,\n        ariaSetSize = _a.ariaSetSize,\n        ariaValueNow = _a.ariaValueNow,\n        ariaValueText = _a.ariaValueText,\n        keytipProps = _a.keytipProps,\n        className = _a.className,\n        inputProps = _a.inputProps,\n        iconButtonProps = _a.iconButtonProps;\n    var _b = this.state,\n        isFocused = _b.isFocused,\n        keyboardSpinDirection = _b.keyboardSpinDirection;\n    var value = this.value;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, disabled, isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n    var nativeProps = getNativeProps(this.props, divProperties, ['onBlur', 'onFocus', 'className']);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, nativeProps, {\n        className: classNames.spinButtonWrapper,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }), React.createElement(\"input\", __assign({\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": typeof ariaValueNow === 'number' ? ariaValueNow : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? Number(value) : undefined,\n        \"aria-valuetext\": typeof ariaValueText === 'string' ? ariaValueText : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        disabled: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }, inputProps)), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps)), React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps))));\n    }), labelPosition === Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)));\n  };\n\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n\n  Object.defineProperty(SpinButton.prototype, \"value\", {\n    /**\n     * Gets the value of the spin button.\n     */\n    get: function () {\n      // TODO (version 8): value from props should ALWAYS override value from state.\n      // In a class component the code should be:\n      // const { value = this.state.value } = this.props;\n      // return value;\n      return this.state.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpinButton.prototype._onChange = function () {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  };\n\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = __decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(React.Component);\n\nexport { SpinButton };","map":{"version":3,"mappings":"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","names":["React","IconButton","Label","Icon","initializeComponentRef","warnMutuallyExclusive","Async","getId","KeyCodes","customizable","calculatePrecision","precisionRound","mergeAriaAttributeValues","getNativeProps","divProperties","Position","getStyles","getArrowButtonStyles","getClassNames","KeytipData","KeyboardSpinDirection","__extends","props","_super","_this","createRef","ev","_input","current","_spinningByMouse","state","keyboardSpinDirection","notSpinning","_stop","select","setState","isFocused","onFocus","_validate","onBlur","value","event","onValidate","_defaultOnValidate","precision","trim","length","isNaN","Number","_lastValidValue","newValue","Math","min","max","String","onIncrement","_defaultOnIncrement","step","_precision","onDecrement","_defaultOnDecrement","undefined","_valueToValidate","_onValidate","element","target","shouldSpin","stepDelay","stepFunction","_currentStepFunctionHandle","_async","setTimeout","_updateValue","_stepDelay","clearTimeout","which","up","down","enter","preventDefault","stopPropagation","disabled","spinDirection","_initialStepDelay","_onIncrement","_onDecrement","escape","_calculatePrecision","_labelId","_inputId","SpinButton","dispose","newProps","label","labelPosition","iconProps","incrementButtonIcon","incrementButtonAriaLabel","decrementButtonIcon","decrementButtonAriaLabel","ariaLabel","ariaDescribedBy","customStyles","customUpArrowButtonStyles","customDownArrowButtonStyles","theme","ariaPositionInSet","ariaSetSize","ariaValueNow","ariaValueText","keytipProps","className","inputProps","iconButtonProps","classNames","nativeProps","root","bottom","labelWrapper","__assign","icon","id","htmlFor","keytipAttributes","spinButtonWrapper","onChange","_onChange","onInput","_onInputChange","input","type","autoComplete","role","_onBlur","ref","_onFocus","onKeyDown","_handleKeyDown","onKeyUp","_handleKeyUp","arrowBox","styles","checked","onMouseDown","_onIncrementMouseDown","onMouseLeave","onMouseUp","tabIndex","_onDecrementMouseDown","iconName","focus","Object","start","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\SpinButton\\SpinButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  initializeComponentRef,\n  warnMutuallyExclusive,\n  Async,\n  getId,\n  KeyCodes,\n  customizable,\n  calculatePrecision,\n  precisionRound,\n  mergeAriaAttributeValues,\n  getNativeProps,\n  divProperties,\n} from '../../Utilities';\nimport { ISpinButton, ISpinButtonProps } from './SpinButton.types';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\n\nexport enum KeyboardSpinDirection {\n  down = -1,\n  notSpinning = 0,\n  up = 1,\n}\n\nexport interface ISpinButtonState {\n  /**\n   * Is true when the control has focus.\n   */\n  isFocused: boolean;\n\n  /**\n   * the value of the spin button\n   */\n  value: string;\n\n  /**\n   * keyboard spin direction, used to style the up or down button\n   * as active when up/down arrow is pressed\n   */\n  keyboardSpinDirection: KeyboardSpinDirection;\n}\n\n// TODO (Fabric Next): remove default min/max values (issue #11358).\nexport type DefaultProps = Required<\n  Pick<\n    ISpinButtonProps,\n    'step' | 'min' | 'max' | 'disabled' | 'labelPosition' | 'label' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n>;\n\n/** Internal only props */\ntype ISpinButtonInternalProps = ISpinButtonProps & DefaultProps;\n\n@customizable('SpinButton', ['theme', 'styles'], true)\nexport class SpinButton extends React.Component<ISpinButtonProps, ISpinButtonState> implements ISpinButton {\n  public static defaultProps: DefaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n    decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n  };\n\n  private _async: Async;\n  private _input = React.createRef<HTMLInputElement>();\n  private _inputId: string;\n  private _labelId: string;\n  private _lastValidValue: string;\n  private _spinningByMouse: boolean;\n  private _valueToValidate: string | undefined; // To avoid duplicate validations/submissions\n  private _precision: number;\n\n  private _currentStepFunctionHandle: number;\n  private _initialStepDelay = 400;\n  private _stepDelay = 75;\n\n  constructor(props: ISpinButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue',\n    });\n\n    // Don't use || here because it won't handle empty strings properly\n    let { value = props.defaultValue } = props;\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n    this._lastValidValue = value;\n\n    // Ensure that the autocalculated precision is not negative.\n    this._precision = this._calculatePrecision(props as ISpinButtonInternalProps);\n\n    this.state = {\n      isFocused: false,\n      value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning,\n    };\n\n    this._async = new Async(this);\n    this._currentStepFunctionHandle = -1;\n    this._labelId = getId('Label');\n    this._inputId = getId('input');\n    this._spinningByMouse = false;\n    this._valueToValidate = undefined;\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  public UNSAFE_componentWillReceiveProps(newProps: ISpinButtonProps): void {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({ value: newProps.value });\n    }\n    this._precision = this._calculatePrecision(newProps as ISpinButtonProps & DefaultProps);\n  }\n\n  public render(): JSX.Element {\n    const {\n      disabled,\n      label,\n      min,\n      max,\n      labelPosition,\n      iconProps,\n      incrementButtonIcon,\n      incrementButtonAriaLabel,\n      decrementButtonIcon,\n      decrementButtonAriaLabel,\n      ariaLabel,\n      ariaDescribedBy,\n      styles: customStyles,\n      upArrowButtonStyles: customUpArrowButtonStyles,\n      downArrowButtonStyles: customDownArrowButtonStyles,\n      theme,\n      ariaPositionInSet,\n      ariaSetSize,\n      ariaValueNow,\n      ariaValueText,\n      keytipProps,\n      className,\n      inputProps,\n      iconButtonProps,\n    } = this.props as ISpinButtonInternalProps;\n\n    const { isFocused, keyboardSpinDirection } = this.state;\n    const value = this.value;\n\n    const classNames = this.props.getClassNames\n      ? this.props.getClassNames(theme!, disabled, isFocused, keyboardSpinDirection, labelPosition, className)\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          disabled,\n          isFocused,\n          keyboardSpinDirection,\n          labelPosition,\n          className,\n        );\n\n    const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onBlur',\n      'onFocus',\n      'className',\n    ]);\n\n    return (\n      <div className={classNames.root}>\n        {labelPosition !== Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n        <KeytipData keytipProps={keytipProps} disabled={disabled}>\n          {(keytipAttributes: any): JSX.Element => (\n            <div\n              {...nativeProps}\n              className={classNames.spinButtonWrapper}\n              aria-label={ariaLabel && ariaLabel}\n              aria-posinset={ariaPositionInSet}\n              aria-setsize={ariaSetSize}\n              data-ktp-target={keytipAttributes['data-ktp-target']}\n            >\n              <input\n                value={value}\n                id={this._inputId}\n                onChange={this._onChange}\n                onInput={this._onInputChange}\n                className={classNames.input}\n                type=\"text\"\n                autoComplete=\"off\"\n                role=\"spinbutton\"\n                aria-labelledby={label && this._labelId}\n                aria-valuenow={\n                  typeof ariaValueNow === 'number'\n                    ? ariaValueNow\n                    : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? Number(value)\n                    : undefined\n                }\n                aria-valuetext={\n                  typeof ariaValueText === 'string'\n                    ? ariaValueText\n                    : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? value\n                    : undefined\n                }\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])}\n                onBlur={this._onBlur}\n                ref={this._input}\n                onFocus={this._onFocus}\n                onKeyDown={this._handleKeyDown}\n                onKeyUp={this._handleKeyUp}\n                disabled={disabled}\n                aria-disabled={disabled}\n                data-lpignore={true}\n                data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n                {...inputProps}\n              />\n              <span className={classNames.arrowBox}>\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n                  className={'ms-UpButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n                  disabled={disabled}\n                  iconProps={incrementButtonIcon}\n                  onMouseDown={this._onIncrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={incrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n                  className={'ms-DownButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n                  disabled={disabled}\n                  iconProps={decrementButtonIcon}\n                  onMouseDown={this._onDecrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={decrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n              </span>\n            </div>\n          )}\n        </KeytipData>\n        {labelPosition === Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon iconName={iconProps.iconName} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public focus(): void {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  }\n\n  /**\n   * Gets the value of the spin button.\n   */\n  public get value(): string | undefined {\n    // TODO (version 8): value from props should ALWAYS override value from state.\n    // In a class component the code should be:\n    // const { value = this.state.value } = this.props;\n    // return value;\n    return this.state.value;\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!this._input.current) {\n      return;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._stop();\n    }\n\n    this._input.current.select();\n\n    this.setState({ isFocused: true });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n  };\n\n  private _onBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    this._validate(ev);\n    this.setState({ isFocused: false });\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n  };\n\n  private _onValidate = (value: string, event?: React.SyntheticEvent<HTMLElement>): string | void => {\n    if (this.props.onValidate) {\n      return this.props.onValidate(value, event);\n    } else {\n      return this._defaultOnValidate(value);\n    }\n  };\n\n  private _calculatePrecision = (props: ISpinButtonProps & DefaultProps) => {\n    const { precision = Math.max(calculatePrecision(props.step), 0) } = props;\n    return precision;\n  };\n\n  /**\n   * Validate function to use if one is not passed in\n   */\n  private _defaultOnValidate = (value: string) => {\n    if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n      return this._lastValidValue;\n    }\n    const newValue = Math.min(this.props.max as number, Math.max(this.props.min as number, Number(value)));\n    return String(newValue);\n  };\n\n  private _onIncrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onIncrement) {\n      return this.props.onIncrement(value, event);\n    } else {\n      return this._defaultOnIncrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnIncrement = (value: string): string | void => {\n    const { max, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.min(Number(value) + Number(step), max);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onDecrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onDecrement) {\n      return this.props.onDecrement(value, event);\n    } else {\n      return this._defaultOnDecrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnDecrement = (value: string): string | void => {\n    const { min, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.max(Number(value) - Number(step), min);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onChange(): void {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  }\n\n  /**\n   * This is used when validating text entry in the input on blur or when enter key is pressed\n   * (not when changed via the buttons).\n   * @param event - the event that fired\n   */\n  private _validate = (event: React.FocusEvent<HTMLInputElement> | React.KeyboardEvent<HTMLInputElement>): void => {\n    if (\n      this.value !== undefined &&\n      this._valueToValidate !== undefined &&\n      this._valueToValidate !== this._lastValidValue\n    ) {\n      const newValue = this._onValidate!(this._valueToValidate, event);\n      // Done validating this value, so clear it\n      this._valueToValidate = undefined;\n\n      if (newValue !== undefined) {\n        this._lastValidValue = newValue;\n        this.setState({ value: newValue });\n      } else {\n        // Value was invalid. Reset state to last valid value.\n        this.setState({ value: this._lastValidValue });\n      }\n    }\n  };\n\n  /**\n   * The method is needed to ensure we are updating the actual input value.\n   * without this our value will never change (and validation will not have the correct number)\n   * @param event - the event that was fired\n   */\n  private _onInputChange = (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>): void => {\n    const element: HTMLInputElement = event.target as HTMLInputElement;\n    const value: string = element.value;\n    this._valueToValidate = value;\n    this.setState({\n      value: value,\n    });\n  };\n\n  /**\n   * Update the value with the given stepFunction\n   * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n   * when spinning in response to a mouseDown\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  private _updateValue = (\n    shouldSpin: boolean,\n    stepDelay: number,\n    stepFunction: (\n      value: string,\n      event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    ) => string | void,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    const newValue: string | void = stepFunction(this.value || '', event);\n    if (newValue !== undefined) {\n      this._lastValidValue = newValue;\n      this.setState({ value: newValue });\n    }\n\n    if (this._spinningByMouse !== shouldSpin) {\n      this._spinningByMouse = shouldSpin;\n    }\n\n    if (shouldSpin) {\n      this._currentStepFunctionHandle = this._async.setTimeout(() => {\n        this._updateValue(shouldSpin, this._stepDelay, stepFunction, event);\n      }, stepDelay);\n    }\n  };\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  private _stop = (): void => {\n    if (this._currentStepFunctionHandle >= 0) {\n      this._async.clearTimeout(this._currentStepFunctionHandle);\n      this._currentStepFunctionHandle = -1;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._spinningByMouse = false;\n      this.setState({ keyboardSpinDirection: KeyboardSpinDirection.notSpinning });\n    }\n  };\n\n  /**\n   * Handle keydown on the text field. We need to update\n   * the value when up or down arrow are depressed\n   * @param event - the keyboardEvent that was fired\n   */\n  private _handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.props.disabled) {\n      this._stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    switch (event.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n        break;\n      case KeyCodes.enter:\n        this._validate(event);\n        break;\n      case KeyCodes.escape:\n        if (this.value !== this._lastValidValue) {\n          this.setState({ value: this._lastValidValue });\n        }\n        break;\n      default:\n        break;\n    }\n\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (this.state.keyboardSpinDirection !== spinDirection) {\n      this.setState({ keyboardSpinDirection: spinDirection });\n    }\n  };\n\n  /**\n   * Make sure that we have stopped spinning on keyUp\n   * if the up or down arrow fired this event\n   * @param event - keyboard event\n   */\n  private _handleKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n      this._stop();\n      return;\n    }\n  };\n\n  private _onIncrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n  };\n\n  private _onDecrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}