{"ast":null,"code":"/** @license React v0.15.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var enableSchedulerDebugging = false;\n    var enableIsInputPending = false;\n    var requestIdleCallbackBeforeFirstFrame = false;\n    var requestTimerEventBeforeFirstFrame = false;\n    var enableMessageLoopImplementation = false; // The DOM Scheduler implementation is similar to requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    var requestHostCallback = void 0;\n    var requestHostTimeout = void 0;\n    var cancelHostTimeout = void 0;\n    var shouldYieldToHost = void 0;\n    var requestPaint = void 0;\n    exports.unstable_now = void 0;\n    exports.unstable_forceFrameRate = void 0;\n\n    if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' || // Check if MessageChannel is supported, too.\n    typeof MessageChannel !== 'function') {\n      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n      // fallback to a naive implementation.\n      var _callback = null;\n      var _timeoutID = null;\n\n      var _flushCallback = function () {\n        if (_callback !== null) {\n          try {\n            var currentTime = exports.unstable_now();\n            var hasRemainingTime = true;\n\n            _callback(hasRemainingTime, currentTime);\n\n            _callback = null;\n          } catch (e) {\n            setTimeout(_flushCallback, 0);\n            throw e;\n          }\n        }\n      };\n\n      exports.unstable_now = function () {\n        return Date.now();\n      };\n\n      requestHostCallback = function (cb) {\n        if (_callback !== null) {\n          // Protect against re-entrancy.\n          setTimeout(requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0);\n        }\n      };\n\n      requestHostTimeout = function (cb, ms) {\n        _timeoutID = setTimeout(cb, ms);\n      };\n\n      cancelHostTimeout = function () {\n        clearTimeout(_timeoutID);\n      };\n\n      shouldYieldToHost = function () {\n        return false;\n      };\n\n      requestPaint = exports.unstable_forceFrameRate = function () {};\n    } else {\n      // Capture local references to native APIs, in case a polyfill overrides them.\n      var performance = window.performance;\n      var _Date = window.Date;\n      var _setTimeout = window.setTimeout;\n      var _clearTimeout = window.clearTimeout;\n      var requestAnimationFrame = window.requestAnimationFrame;\n      var cancelAnimationFrame = window.cancelAnimationFrame;\n      var requestIdleCallback = window.requestIdleCallback;\n\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof requestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n\n        if (typeof cancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n\n      var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\n      exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\n        return performance.now();\n      } : function () {\n        return _Date.now();\n      };\n      var isRAFLoopRunning = false;\n      var isMessageLoopRunning = false;\n      var scheduledHostCallback = null;\n      var rAFTimeoutID = -1;\n      var taskTimeoutID = -1;\n      var frameLength = enableMessageLoopImplementation ? // We won't attempt to align with the vsync. Instead we'll yield multiple\n      // times per frame, often enough to keep it responsive even at really\n      // high frame rates > 120.\n      5 : // Use a heuristic to measure the frame rate and yield at the end of the\n      // frame. We start out assuming that we run at 30fps but then the\n      // heuristic tracking will adjust this value to a faster fps if we get\n      // more frequent animation frames.\n      33.33;\n      var prevRAFTime = -1;\n      var prevRAFInterval = -1;\n      var frameDeadline = 0;\n      var fpsLocked = false; // TODO: Make this configurable\n      // TODO: Adjust this based on priority?\n\n      var maxFrameLength = 300;\n      var needsPaint = false;\n\n      if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\n        var scheduling = navigator.scheduling;\n\n        shouldYieldToHost = function () {\n          var currentTime = exports.unstable_now();\n\n          if (currentTime >= frameDeadline) {\n            // There's no time left in the frame. We may want to yield control of\n            // the main thread, so the browser can perform high priority tasks. The\n            // main ones are painting and user input. If there's a pending paint or\n            // a pending input, then we should yield. But if there's neither, then\n            // we can yield less often while remaining responsive. We'll eventually\n            // yield regardless, since there could be a pending paint that wasn't\n            // accompanied by a call to `requestPaint`, or other main thread tasks\n            // like network events.\n            if (needsPaint || scheduling.isInputPending()) {\n              // There is either a pending paint or a pending input.\n              return true;\n            } // There's no pending input. Only yield if we've reached the max\n            // frame length.\n\n\n            return currentTime >= frameDeadline + maxFrameLength;\n          } else {\n            // There's still time left in the frame.\n            return false;\n          }\n        };\n\n        requestPaint = function () {\n          needsPaint = true;\n        };\n      } else {\n        // `isInputPending` is not available. Since we have no way of knowing if\n        // there's pending input, always yield at the end of the frame.\n        shouldYieldToHost = function () {\n          return exports.unstable_now() >= frameDeadline;\n        }; // Since we yield every frame regardless, `requestPaint` has no effect.\n\n\n        requestPaint = function () {};\n      }\n\n      exports.unstable_forceFrameRate = function (fps) {\n        if (fps < 0 || fps > 125) {\n          console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\n          return;\n        }\n\n        if (fps > 0) {\n          frameLength = Math.floor(1000 / fps);\n          fpsLocked = true;\n        } else {\n          // reset the framerate\n          frameLength = 33.33;\n          fpsLocked = false;\n        }\n      };\n\n      var performWorkUntilDeadline = function () {\n        if (enableMessageLoopImplementation) {\n          if (scheduledHostCallback !== null) {\n            var currentTime = exports.unstable_now(); // Yield after `frameLength` ms, regardless of where we are in the vsync\n            // cycle. This means there's always time remaining at the beginning of\n            // the message event.\n\n            frameDeadline = currentTime + frameLength;\n            var hasTimeRemaining = true;\n\n            try {\n              var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n\n              if (!hasMoreWork) {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n              } else {\n                // If there's more work, schedule the next message event at the end\n                // of the preceding one.\n                port.postMessage(null);\n              }\n            } catch (error) {\n              // If a scheduler task throws, exit the current browser task so the\n              // error can be observed.\n              port.postMessage(null);\n              throw error;\n            }\n          } // Yielding to the browser will give it a chance to paint, so we can\n          // reset this.\n\n\n          needsPaint = false;\n        } else {\n          if (scheduledHostCallback !== null) {\n            var _currentTime = exports.unstable_now();\n\n            var _hasTimeRemaining = frameDeadline - _currentTime > 0;\n\n            try {\n              var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\n\n              if (!_hasMoreWork) {\n                scheduledHostCallback = null;\n              }\n            } catch (error) {\n              // If a scheduler task throws, exit the current browser task so the\n              // error can be observed, and post a new task as soon as possible\n              // so we can continue where we left off.\n              port.postMessage(null);\n              throw error;\n            }\n          } // Yielding to the browser will give it a chance to paint, so we can\n          // reset this.\n\n\n          needsPaint = false;\n        }\n      };\n\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n\n      var onAnimationFrame = function (rAFTime) {\n        if (scheduledHostCallback === null) {\n          // No scheduled work. Exit.\n          prevRAFTime = -1;\n          prevRAFInterval = -1;\n          isRAFLoopRunning = false;\n          return;\n        } // Eagerly schedule the next animation callback at the beginning of the\n        // frame. If the scheduler queue is not empty at the end of the frame, it\n        // will continue flushing inside that callback. If the queue *is* empty,\n        // then it will exit immediately. Posting the callback at the start of the\n        // frame ensures it's fired within the earliest possible frame. If we\n        // waited until the end of the frame to post the callback, we risk the\n        // browser skipping a frame and not firing the callback until the frame\n        // after that.\n\n\n        isRAFLoopRunning = true;\n        requestAnimationFrame(function (nextRAFTime) {\n          _clearTimeout(rAFTimeoutID);\n\n          onAnimationFrame(nextRAFTime);\n        }); // requestAnimationFrame is throttled when the tab is backgrounded. We\n        // don't want to stop working entirely. So we'll fallback to a timeout loop.\n        // TODO: Need a better heuristic for backgrounded work.\n\n        var onTimeout = function () {\n          frameDeadline = exports.unstable_now() + frameLength / 2;\n          performWorkUntilDeadline();\n          rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n        };\n\n        rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n\n        if (prevRAFTime !== -1 && // Make sure this rAF time is different from the previous one. This check\n        // could fail if two rAFs fire in the same frame.\n        rAFTime - prevRAFTime > 0.1) {\n          var rAFInterval = rAFTime - prevRAFTime;\n\n          if (!fpsLocked && prevRAFInterval !== -1) {\n            // We've observed two consecutive frame intervals. We'll use this to\n            // dynamically adjust the frame rate.\n            //\n            // If one frame goes long, then the next one can be short to catch up.\n            // If two frames are short in a row, then that's an indication that we\n            // actually have a higher frame rate than what we're currently\n            // optimizing. For example, if we're running on 120hz display or 90hz VR\n            // display. Take the max of the two in case one of them was an anomaly\n            // due to missed frame deadlines.\n            if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n              frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n\n              if (frameLength < 8.33) {\n                // Defensive coding. We don't support higher frame rates than 120hz.\n                // If the calculated frame length gets lower than 8, it is probably\n                // a bug.\n                frameLength = 8.33;\n              }\n            }\n          }\n\n          prevRAFInterval = rAFInterval;\n        }\n\n        prevRAFTime = rAFTime;\n        frameDeadline = rAFTime + frameLength; // We use the postMessage trick to defer idle work until after the repaint.\n\n        port.postMessage(null);\n      };\n\n      requestHostCallback = function (callback) {\n        scheduledHostCallback = callback;\n\n        if (enableMessageLoopImplementation) {\n          if (!isMessageLoopRunning) {\n            isMessageLoopRunning = true;\n            port.postMessage(null);\n          }\n        } else {\n          if (!isRAFLoopRunning) {\n            // Start a rAF loop.\n            isRAFLoopRunning = true;\n            requestAnimationFrame(function (rAFTime) {\n              if (requestIdleCallbackBeforeFirstFrame$1) {\n                cancelIdleCallback(idleCallbackID);\n              }\n\n              if (requestTimerEventBeforeFirstFrame) {\n                _clearTimeout(idleTimeoutID);\n              }\n\n              onAnimationFrame(rAFTime);\n            }); // If we just missed the last vsync, the next rAF might not happen for\n            // another frame. To claim as much idle time as possible, post a\n            // callback with `requestIdleCallback`, which should fire if there's\n            // idle time left in the frame.\n            //\n            // This should only be an issue for the first rAF in the loop;\n            // subsequent rAFs are scheduled at the beginning of the\n            // preceding frame.\n\n            var idleCallbackID = void 0;\n\n            if (requestIdleCallbackBeforeFirstFrame$1) {\n              idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\n                if (requestTimerEventBeforeFirstFrame) {\n                  _clearTimeout(idleTimeoutID);\n                }\n\n                frameDeadline = exports.unstable_now() + frameLength;\n                performWorkUntilDeadline();\n              });\n            } // Alternate strategy to address the same problem. Scheduler a timer\n            // with no delay. If this fires before the rAF, that likely indicates\n            // that there's idle time before the next vsync. This isn't always the\n            // case, but we'll be aggressive and assume it is, as a trade off to\n            // prevent idle periods.\n\n\n            var idleTimeoutID = void 0;\n\n            if (requestTimerEventBeforeFirstFrame) {\n              idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\n                if (requestIdleCallbackBeforeFirstFrame$1) {\n                  cancelIdleCallback(idleCallbackID);\n                }\n\n                frameDeadline = exports.unstable_now() + frameLength;\n                performWorkUntilDeadline();\n              }, 0);\n            }\n          }\n        }\n      };\n\n      requestHostTimeout = function (callback, ms) {\n        taskTimeoutID = _setTimeout(function () {\n          callback(exports.unstable_now());\n        }, ms);\n      };\n\n      cancelHostTimeout = function () {\n        _clearTimeout(taskTimeoutID);\n\n        taskTimeoutID = -1;\n      };\n    }\n    /* eslint-disable no-var */\n    // TODO: Use symbols?\n\n\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5; // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY = maxSigned31BitInt; // Tasks are stored as a circular, doubly linked list.\n\n    var firstTask = null;\n    var firstDelayedTask = null; // Pausing the scheduler is useful for debugging.\n\n    var isSchedulerPaused = false;\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false;\n\n    function scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function flushTask(task, currentTime) {\n      // Remove the task from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = task.next;\n\n      if (next === task) {\n        // This is the only scheduled task. Clear the list.\n        firstTask = null;\n      } else {\n        // Remove the task from its position in the list.\n        if (task === firstTask) {\n          firstTask = next;\n        }\n\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      task.next = task.previous = null; // Now it's safe to execute the task.\n\n      var callback = task.callback;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousTask = currentTask;\n      currentPriorityLevel = task.priorityLevel;\n      currentTask = task;\n      var continuationCallback;\n\n      try {\n        var didUserCallbackTimeout = task.expirationTime <= currentTime; // Add an extra function to the callstack. Profiling tools can use this\n        // to infer the priority of work that appears higher in the stack.\n\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n            break;\n\n          case UserBlockingPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n            break;\n\n          case NormalPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n            break;\n\n          case LowPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n            break;\n\n          case IdlePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n            break;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentTask = previousTask;\n      } // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n\n\n      if (typeof continuationCallback === 'function') {\n        var expirationTime = task.expirationTime;\n        var continuationTask = task;\n        continuationTask.callback = continuationCallback; // Insert the new callback into the list, sorted by its timeout. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal timeout instead\n        // of after.\n\n        if (firstTask === null) {\n          // This is the first callback in the list.\n          firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n        } else {\n          var nextAfterContinuation = null;\n          var t = firstTask;\n\n          do {\n            if (expirationTime <= t.expirationTime) {\n              // This task times out at or after the continuation. We will insert\n              // the continuation *before* this task.\n              nextAfterContinuation = t;\n              break;\n            }\n\n            t = t.next;\n          } while (t !== firstTask);\n\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority task was found, which means the new task\n            // is the lowest priority task in the list.\n            nextAfterContinuation = firstTask;\n          } else if (nextAfterContinuation === firstTask) {\n            // The new task is the highest priority task in the list.\n            firstTask = continuationTask;\n          }\n\n          var _previous = nextAfterContinuation.previous;\n          _previous.next = nextAfterContinuation.previous = continuationTask;\n          continuationTask.next = nextAfterContinuation;\n          continuationTask.previous = _previous;\n        }\n      }\n    }\n\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n        do {\n          var task = firstDelayedTask;\n          var next = task.next;\n\n          if (task === next) {\n            firstDelayedTask = null;\n          } else {\n            firstDelayedTask = next;\n            var previous = task.previous;\n            previous.next = next;\n            next.previous = previous;\n          }\n\n          task.next = task.previous = null;\n          insertScheduledTask(task, task.expirationTime);\n        } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n      }\n    }\n\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n\n      if (!isHostCallbackScheduled) {\n        if (firstTask !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else if (firstDelayedTask !== null) {\n          requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n        }\n      }\n    }\n\n    function flushWork(hasTimeRemaining, initialTime) {\n      // Exit right away if we're currently paused\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      } // We'll need a host callback the next time work is scheduled.\n\n\n      isHostCallbackScheduled = false;\n\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      isPerformingWork = true;\n\n      try {\n        if (!hasTimeRemaining) {\n          // Flush all the expired callbacks without yielding.\n          // TODO: Split flushWork into two separate functions instead of using\n          // a boolean argument?\n          while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n            flushTask(firstTask, currentTime);\n            currentTime = exports.unstable_now();\n            advanceTimers(currentTime);\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstTask !== null) {\n            do {\n              flushTask(firstTask, currentTime);\n              currentTime = exports.unstable_now();\n              advanceTimers(currentTime);\n            } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n          }\n        } // Return whether there's additional work\n\n\n        if (firstTask !== null) {\n          return true;\n        } else {\n          if (firstDelayedTask !== null) {\n            requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n          }\n\n          return false;\n        }\n      } finally {\n        isPerformingWork = false;\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n\n    function timeoutForPriorityLevel(priorityLevel) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          return IMMEDIATE_PRIORITY_TIMEOUT;\n\n        case UserBlockingPriority:\n          return USER_BLOCKING_PRIORITY;\n\n        case IdlePriority:\n          return IDLE_PRIORITY;\n\n        case LowPriority:\n          return LOW_PRIORITY_TIMEOUT;\n\n        case NormalPriority:\n        default:\n          return NORMAL_PRIORITY_TIMEOUT;\n      }\n    }\n\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      var timeout;\n\n      if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n\n        timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n      } else {\n        timeout = timeoutForPriorityLevel(priorityLevel);\n        startTime = currentTime;\n      }\n\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        insertDelayedTask(newTask, startTime);\n\n        if (firstTask === null && firstDelayedTask === newTask) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        insertScheduledTask(newTask, expirationTime); // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n\n      return newTask;\n    }\n\n    function insertScheduledTask(newTask, expirationTime) {\n      // Insert the new task into the list, ordered first by its timeout, then by\n      // insertion. So the new task is inserted after any other task the\n      // same timeout\n      if (firstTask === null) {\n        // This is the first task in the list.\n        firstTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstTask;\n\n        do {\n          if (expirationTime < task.expirationTime) {\n            // The new task times out before this one.\n            next = task;\n            break;\n          }\n\n          task = task.next;\n        } while (task !== firstTask);\n\n        if (next === null) {\n          // No task with a later timeout was found, which means the new task has\n          // the latest timeout in the list.\n          next = firstTask;\n        } else if (next === firstTask) {\n          // The new task has the earliest expiration in the entire list.\n          firstTask = newTask;\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n\n    function insertDelayedTask(newTask, startTime) {\n      // Insert the new task into the list, ordered by its start time.\n      if (firstDelayedTask === null) {\n        // This is the first task in the list.\n        firstDelayedTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstDelayedTask;\n\n        do {\n          if (startTime < task.startTime) {\n            // The new task times out before this one.\n            next = task;\n            break;\n          }\n\n          task = task.next;\n        } while (task !== firstDelayedTask);\n\n        if (next === null) {\n          // No task with a later timeout was found, which means the new task has\n          // the latest timeout in the list.\n          next = firstDelayedTask;\n        } else if (next === firstDelayedTask) {\n          // The new task has the earliest expiration in the entire list.\n          firstDelayedTask = newTask;\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n\n    function unstable_getFirstCallbackNode() {\n      return firstTask;\n    }\n\n    function unstable_cancelCallback(task) {\n      var next = task.next;\n\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (task === next) {\n        if (task === firstTask) {\n          firstTask = null;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = null;\n        }\n      } else {\n        if (task === firstTask) {\n          firstTask = next;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = next;\n        }\n\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      task.next = task.previous = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    function unstable_shouldYield() {\n      var currentTime = exports.unstable_now();\n      advanceTimers(currentTime);\n      return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n    }\n\n    var unstable_requestPaint = requestPaint;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","enableSchedulerDebugging","enableIsInputPending","requestIdleCallbackBeforeFirstFrame","requestTimerEventBeforeFirstFrame","enableMessageLoopImplementation","requestHostCallback","requestHostTimeout","cancelHostTimeout","shouldYieldToHost","requestPaint","unstable_now","unstable_forceFrameRate","window","MessageChannel","_callback","_timeoutID","_flushCallback","currentTime","hasRemainingTime","e","setTimeout","Date","now","cb","ms","clearTimeout","performance","_Date","_setTimeout","_clearTimeout","requestAnimationFrame","cancelAnimationFrame","requestIdleCallback","console","error","requestIdleCallbackBeforeFirstFrame$1","cancelIdleCallback","isRAFLoopRunning","isMessageLoopRunning","scheduledHostCallback","rAFTimeoutID","taskTimeoutID","frameLength","prevRAFTime","prevRAFInterval","frameDeadline","fpsLocked","maxFrameLength","needsPaint","navigator","undefined","scheduling","isInputPending","fps","Math","floor","performWorkUntilDeadline","hasTimeRemaining","hasMoreWork","port","postMessage","_currentTime","_hasTimeRemaining","_hasMoreWork","channel","port2","port1","onmessage","onAnimationFrame","rAFTime","nextRAFTime","onTimeout","rAFInterval","callback","idleCallbackID","idleTimeoutID","onIdleCallbackBeforeFirstFrame","onTimerEventBeforeFirstFrame","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstTask","firstDelayedTask","isSchedulerPaused","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","scheduler_flushTaskAtPriority_Immediate","didTimeout","scheduler_flushTaskAtPriority_UserBlocking","scheduler_flushTaskAtPriority_Normal","scheduler_flushTaskAtPriority_Low","scheduler_flushTaskAtPriority_Idle","flushTask","task","next","previous","previousPriorityLevel","previousTask","priorityLevel","continuationCallback","didUserCallbackTimeout","expirationTime","continuationTask","nextAfterContinuation","t","_previous","advanceTimers","startTime","insertScheduledTask","handleTimeout","flushWork","initialTime","unstable_runWithPriority","eventHandler","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","timeoutForPriorityLevel","unstable_scheduleCallback","options","timeout","delay","newTask","insertDelayedTask","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_requestPaint","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority"],"sources":["D:/PFCJACOBO/PFC/mycinemalist/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v0.15.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\nvar enableIsInputPending = false;\nvar requestIdleCallbackBeforeFirstFrame = false;\nvar requestTimerEventBeforeFirstFrame = false;\nvar enableMessageLoopImplementation = false;\n\n// The DOM Scheduler implementation is similar to requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\nvar requestHostCallback = void 0;\n\nvar requestHostTimeout = void 0;\nvar cancelHostTimeout = void 0;\nvar shouldYieldToHost = void 0;\nvar requestPaint = void 0;\nexports.unstable_now = void 0;\nexports.unstable_forceFrameRate = void 0;\n\nif (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _timeoutID = null;\n  var _flushCallback = function () {\n    if (_callback !== null) {\n      try {\n        var currentTime = exports.unstable_now();\n        var hasRemainingTime = true;\n        _callback(hasRemainingTime, currentTime);\n        _callback = null;\n      } catch (e) {\n        setTimeout(_flushCallback, 0);\n        throw e;\n      }\n    }\n  };\n  exports.unstable_now = function () {\n    return Date.now();\n  };\n  requestHostCallback = function (cb) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0);\n    }\n  };\n  requestHostTimeout = function (cb, ms) {\n    _timeoutID = setTimeout(cb, ms);\n  };\n  cancelHostTimeout = function () {\n    clearTimeout(_timeoutID);\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n  requestPaint = exports.unstable_forceFrameRate = function () {};\n} else {\n  // Capture local references to native APIs, in case a polyfill overrides them.\n  var performance = window.performance;\n  var _Date = window.Date;\n  var _setTimeout = window.setTimeout;\n  var _clearTimeout = window.clearTimeout;\n  var requestAnimationFrame = window.requestAnimationFrame;\n  var cancelAnimationFrame = window.cancelAnimationFrame;\n  var requestIdleCallback = window.requestIdleCallback;\n\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof requestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof cancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\n\n  exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\n    return performance.now();\n  } : function () {\n    return _Date.now();\n  };\n\n  var isRAFLoopRunning = false;\n  var isMessageLoopRunning = false;\n  var scheduledHostCallback = null;\n  var rAFTimeoutID = -1;\n  var taskTimeoutID = -1;\n\n  var frameLength = enableMessageLoopImplementation ? // We won't attempt to align with the vsync. Instead we'll yield multiple\n  // times per frame, often enough to keep it responsive even at really\n  // high frame rates > 120.\n  5 : // Use a heuristic to measure the frame rate and yield at the end of the\n  // frame. We start out assuming that we run at 30fps but then the\n  // heuristic tracking will adjust this value to a faster fps if we get\n  // more frequent animation frames.\n  33.33;\n\n  var prevRAFTime = -1;\n  var prevRAFInterval = -1;\n  var frameDeadline = 0;\n\n  var fpsLocked = false;\n\n  // TODO: Make this configurable\n  // TODO: Adjust this based on priority?\n  var maxFrameLength = 300;\n  var needsPaint = false;\n\n  if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\n    var scheduling = navigator.scheduling;\n    shouldYieldToHost = function () {\n      var currentTime = exports.unstable_now();\n      if (currentTime >= frameDeadline) {\n        // There's no time left in the frame. We may want to yield control of\n        // the main thread, so the browser can perform high priority tasks. The\n        // main ones are painting and user input. If there's a pending paint or\n        // a pending input, then we should yield. But if there's neither, then\n        // we can yield less often while remaining responsive. We'll eventually\n        // yield regardless, since there could be a pending paint that wasn't\n        // accompanied by a call to `requestPaint`, or other main thread tasks\n        // like network events.\n        if (needsPaint || scheduling.isInputPending()) {\n          // There is either a pending paint or a pending input.\n          return true;\n        }\n        // There's no pending input. Only yield if we've reached the max\n        // frame length.\n        return currentTime >= frameDeadline + maxFrameLength;\n      } else {\n        // There's still time left in the frame.\n        return false;\n      }\n    };\n\n    requestPaint = function () {\n      needsPaint = true;\n    };\n  } else {\n    // `isInputPending` is not available. Since we have no way of knowing if\n    // there's pending input, always yield at the end of the frame.\n    shouldYieldToHost = function () {\n      return exports.unstable_now() >= frameDeadline;\n    };\n\n    // Since we yield every frame regardless, `requestPaint` has no effect.\n    requestPaint = function () {};\n  }\n\n  exports.unstable_forceFrameRate = function (fps) {\n    if (fps < 0 || fps > 125) {\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\n      return;\n    }\n    if (fps > 0) {\n      frameLength = Math.floor(1000 / fps);\n      fpsLocked = true;\n    } else {\n      // reset the framerate\n      frameLength = 33.33;\n      fpsLocked = false;\n    }\n  };\n\n  var performWorkUntilDeadline = function () {\n    if (enableMessageLoopImplementation) {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now();\n        // Yield after `frameLength` ms, regardless of where we are in the vsync\n        // cycle. This means there's always time remaining at the beginning of\n        // the message event.\n        frameDeadline = currentTime + frameLength;\n        var hasTimeRemaining = true;\n        try {\n          var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n          if (!hasMoreWork) {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          } else {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            port.postMessage(null);\n          }\n        } catch (error) {\n          // If a scheduler task throws, exit the current browser task so the\n          // error can be observed.\n          port.postMessage(null);\n          throw error;\n        }\n      }\n      // Yielding to the browser will give it a chance to paint, so we can\n      // reset this.\n      needsPaint = false;\n    } else {\n      if (scheduledHostCallback !== null) {\n        var _currentTime = exports.unstable_now();\n        var _hasTimeRemaining = frameDeadline - _currentTime > 0;\n        try {\n          var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\n          if (!_hasMoreWork) {\n            scheduledHostCallback = null;\n          }\n        } catch (error) {\n          // If a scheduler task throws, exit the current browser task so the\n          // error can be observed, and post a new task as soon as possible\n          // so we can continue where we left off.\n          port.postMessage(null);\n          throw error;\n        }\n      }\n      // Yielding to the browser will give it a chance to paint, so we can\n      // reset this.\n      needsPaint = false;\n    }\n  };\n\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  var onAnimationFrame = function (rAFTime) {\n    if (scheduledHostCallback === null) {\n      // No scheduled work. Exit.\n      prevRAFTime = -1;\n      prevRAFInterval = -1;\n      isRAFLoopRunning = false;\n      return;\n    }\n\n    // Eagerly schedule the next animation callback at the beginning of the\n    // frame. If the scheduler queue is not empty at the end of the frame, it\n    // will continue flushing inside that callback. If the queue *is* empty,\n    // then it will exit immediately. Posting the callback at the start of the\n    // frame ensures it's fired within the earliest possible frame. If we\n    // waited until the end of the frame to post the callback, we risk the\n    // browser skipping a frame and not firing the callback until the frame\n    // after that.\n    isRAFLoopRunning = true;\n    requestAnimationFrame(function (nextRAFTime) {\n      _clearTimeout(rAFTimeoutID);\n      onAnimationFrame(nextRAFTime);\n    });\n\n    // requestAnimationFrame is throttled when the tab is backgrounded. We\n    // don't want to stop working entirely. So we'll fallback to a timeout loop.\n    // TODO: Need a better heuristic for backgrounded work.\n    var onTimeout = function () {\n      frameDeadline = exports.unstable_now() + frameLength / 2;\n      performWorkUntilDeadline();\n      rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n    };\n    rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n\n    if (prevRAFTime !== -1 &&\n    // Make sure this rAF time is different from the previous one. This check\n    // could fail if two rAFs fire in the same frame.\n    rAFTime - prevRAFTime > 0.1) {\n      var rAFInterval = rAFTime - prevRAFTime;\n      if (!fpsLocked && prevRAFInterval !== -1) {\n        // We've observed two consecutive frame intervals. We'll use this to\n        // dynamically adjust the frame rate.\n        //\n        // If one frame goes long, then the next one can be short to catch up.\n        // If two frames are short in a row, then that's an indication that we\n        // actually have a higher frame rate than what we're currently\n        // optimizing. For example, if we're running on 120hz display or 90hz VR\n        // display. Take the max of the two in case one of them was an anomaly\n        // due to missed frame deadlines.\n        if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n          frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n          if (frameLength < 8.33) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame length gets lower than 8, it is probably\n            // a bug.\n            frameLength = 8.33;\n          }\n        }\n      }\n      prevRAFInterval = rAFInterval;\n    }\n    prevRAFTime = rAFTime;\n    frameDeadline = rAFTime + frameLength;\n\n    // We use the postMessage trick to defer idle work until after the repaint.\n    port.postMessage(null);\n  };\n\n  requestHostCallback = function (callback) {\n    scheduledHostCallback = callback;\n    if (enableMessageLoopImplementation) {\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        port.postMessage(null);\n      }\n    } else {\n      if (!isRAFLoopRunning) {\n        // Start a rAF loop.\n        isRAFLoopRunning = true;\n        requestAnimationFrame(function (rAFTime) {\n          if (requestIdleCallbackBeforeFirstFrame$1) {\n            cancelIdleCallback(idleCallbackID);\n          }\n          if (requestTimerEventBeforeFirstFrame) {\n            _clearTimeout(idleTimeoutID);\n          }\n          onAnimationFrame(rAFTime);\n        });\n\n        // If we just missed the last vsync, the next rAF might not happen for\n        // another frame. To claim as much idle time as possible, post a\n        // callback with `requestIdleCallback`, which should fire if there's\n        // idle time left in the frame.\n        //\n        // This should only be an issue for the first rAF in the loop;\n        // subsequent rAFs are scheduled at the beginning of the\n        // preceding frame.\n        var idleCallbackID = void 0;\n        if (requestIdleCallbackBeforeFirstFrame$1) {\n          idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\n            if (requestTimerEventBeforeFirstFrame) {\n              _clearTimeout(idleTimeoutID);\n            }\n            frameDeadline = exports.unstable_now() + frameLength;\n            performWorkUntilDeadline();\n          });\n        }\n        // Alternate strategy to address the same problem. Scheduler a timer\n        // with no delay. If this fires before the rAF, that likely indicates\n        // that there's idle time before the next vsync. This isn't always the\n        // case, but we'll be aggressive and assume it is, as a trade off to\n        // prevent idle periods.\n        var idleTimeoutID = void 0;\n        if (requestTimerEventBeforeFirstFrame) {\n          idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\n            if (requestIdleCallbackBeforeFirstFrame$1) {\n              cancelIdleCallback(idleCallbackID);\n            }\n            frameDeadline = exports.unstable_now() + frameLength;\n            performWorkUntilDeadline();\n          }, 0);\n        }\n      }\n    }\n  };\n\n  requestHostTimeout = function (callback, ms) {\n    taskTimeoutID = _setTimeout(function () {\n      callback(exports.unstable_now());\n    }, ms);\n  };\n\n  cancelHostTimeout = function () {\n    _clearTimeout(taskTimeoutID);\n    taskTimeoutID = -1;\n  };\n}\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Tasks are stored as a circular, doubly linked list.\nvar firstTask = null;\nvar firstDelayedTask = null;\n\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority;\n\n// This is set while performing work, to prevent re-entrancy.\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false;\n\nfunction scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n  return callback(didTimeout);\n}\n\nfunction flushTask(task, currentTime) {\n  // Remove the task from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = task.next;\n  if (next === task) {\n    // This is the only scheduled task. Clear the list.\n    firstTask = null;\n  } else {\n    // Remove the task from its position in the list.\n    if (task === firstTask) {\n      firstTask = next;\n    }\n    var previous = task.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n  task.next = task.previous = null;\n\n  // Now it's safe to execute the task.\n  var callback = task.callback;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousTask = currentTask;\n  currentPriorityLevel = task.priorityLevel;\n  currentTask = task;\n  var continuationCallback;\n  try {\n    var didUserCallbackTimeout = task.expirationTime <= currentTime;\n    // Add an extra function to the callstack. Profiling tools can use this\n    // to infer the priority of work that appears higher in the stack.\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n        break;\n      case UserBlockingPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n        break;\n      case NormalPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n        break;\n      case LowPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n        break;\n      case IdlePriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n        break;\n    }\n  } catch (error) {\n    throw error;\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentTask = previousTask;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var expirationTime = task.expirationTime;\n    var continuationTask = task;\n    continuationTask.callback = continuationCallback;\n\n    // Insert the new callback into the list, sorted by its timeout. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal timeout instead\n    // of after.\n    if (firstTask === null) {\n      // This is the first callback in the list.\n      firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n    } else {\n      var nextAfterContinuation = null;\n      var t = firstTask;\n      do {\n        if (expirationTime <= t.expirationTime) {\n          // This task times out at or after the continuation. We will insert\n          // the continuation *before* this task.\n          nextAfterContinuation = t;\n          break;\n        }\n        t = t.next;\n      } while (t !== firstTask);\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority task was found, which means the new task\n        // is the lowest priority task in the list.\n        nextAfterContinuation = firstTask;\n      } else if (nextAfterContinuation === firstTask) {\n        // The new task is the highest priority task in the list.\n        firstTask = continuationTask;\n      }\n\n      var _previous = nextAfterContinuation.previous;\n      _previous.next = nextAfterContinuation.previous = continuationTask;\n      continuationTask.next = nextAfterContinuation;\n      continuationTask.previous = _previous;\n    }\n  }\n}\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n    do {\n      var task = firstDelayedTask;\n      var next = task.next;\n      if (task === next) {\n        firstDelayedTask = null;\n      } else {\n        firstDelayedTask = next;\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n      insertScheduledTask(task, task.expirationTime);\n    } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (firstTask !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else if (firstDelayedTask !== null) {\n      requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  // Exit right away if we're currently paused\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  // We'll need a host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n\n  isPerformingWork = true;\n  try {\n    if (!hasTimeRemaining) {\n      // Flush all the expired callbacks without yielding.\n      // TODO: Split flushWork into two separate functions instead of using\n      // a boolean argument?\n      while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        flushTask(firstTask, currentTime);\n        currentTime = exports.unstable_now();\n        advanceTimers(currentTime);\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstTask !== null) {\n        do {\n          flushTask(firstTask, currentTime);\n          currentTime = exports.unstable_now();\n          advanceTimers(currentTime);\n        } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n      }\n    }\n    // Return whether there's additional work\n    if (firstTask !== null) {\n      return true;\n    } else {\n      if (firstDelayedTask !== null) {\n        requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n      }\n      return false;\n    }\n  } finally {\n    isPerformingWork = false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction timeoutForPriorityLevel(priorityLevel) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      return IMMEDIATE_PRIORITY_TIMEOUT;\n    case UserBlockingPriority:\n      return USER_BLOCKING_PRIORITY;\n    case IdlePriority:\n      return IDLE_PRIORITY;\n    case LowPriority:\n      return LOW_PRIORITY_TIMEOUT;\n    case NormalPriority:\n    default:\n      return NORMAL_PRIORITY_TIMEOUT;\n  }\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var startTime;\n  var timeout;\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n  } else {\n    timeout = timeoutForPriorityLevel(priorityLevel);\n    startTime = currentTime;\n  }\n\n  var expirationTime = startTime + timeout;\n\n  var newTask = {\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    insertDelayedTask(newTask, startTime);\n    if (firstTask === null && firstDelayedTask === newTask) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      // Schedule a timeout.\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    insertScheduledTask(newTask, expirationTime);\n    // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction insertScheduledTask(newTask, expirationTime) {\n  // Insert the new task into the list, ordered first by its timeout, then by\n  // insertion. So the new task is inserted after any other task the\n  // same timeout\n  if (firstTask === null) {\n    // This is the first task in the list.\n    firstTask = newTask.next = newTask.previous = newTask;\n  } else {\n    var next = null;\n    var task = firstTask;\n    do {\n      if (expirationTime < task.expirationTime) {\n        // The new task times out before this one.\n        next = task;\n        break;\n      }\n      task = task.next;\n    } while (task !== firstTask);\n\n    if (next === null) {\n      // No task with a later timeout was found, which means the new task has\n      // the latest timeout in the list.\n      next = firstTask;\n    } else if (next === firstTask) {\n      // The new task has the earliest expiration in the entire list.\n      firstTask = newTask;\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newTask;\n    newTask.next = next;\n    newTask.previous = previous;\n  }\n}\n\nfunction insertDelayedTask(newTask, startTime) {\n  // Insert the new task into the list, ordered by its start time.\n  if (firstDelayedTask === null) {\n    // This is the first task in the list.\n    firstDelayedTask = newTask.next = newTask.previous = newTask;\n  } else {\n    var next = null;\n    var task = firstDelayedTask;\n    do {\n      if (startTime < task.startTime) {\n        // The new task times out before this one.\n        next = task;\n        break;\n      }\n      task = task.next;\n    } while (task !== firstDelayedTask);\n\n    if (next === null) {\n      // No task with a later timeout was found, which means the new task has\n      // the latest timeout in the list.\n      next = firstDelayedTask;\n    } else if (next === firstDelayedTask) {\n      // The new task has the earliest expiration in the entire list.\n      firstDelayedTask = newTask;\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newTask;\n    newTask.next = next;\n    newTask.previous = previous;\n  }\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstTask;\n}\n\nfunction unstable_cancelCallback(task) {\n  var next = task.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (task === next) {\n    if (task === firstTask) {\n      firstTask = null;\n    } else if (task === firstDelayedTask) {\n      firstDelayedTask = null;\n    }\n  } else {\n    if (task === firstTask) {\n      firstTask = next;\n    } else if (task === firstDelayedTask) {\n      firstDelayedTask = next;\n    }\n    var previous = task.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  task.next = task.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  var currentTime = exports.unstable_now();\n  advanceTimers(currentTime);\n  return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n}\n\nvar unstable_requestPaint = requestPaint;\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}