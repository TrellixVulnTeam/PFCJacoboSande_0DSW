{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { initializeComponentRef, warnMutuallyExclusive, Async, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues, getNativeProps, divProperties } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\n\nvar SpinButton =\n/** @class */\nfunction (_super) {\n  __extends(SpinButton, _super);\n\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n\n      _this._input.current.select();\n\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n\n      _this.setState({\n        isFocused: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n          precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\n     * Validate function to use if one is not passed in\n     */\n\n\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n\n    _this._onIncrement = function (value, event) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value, event);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n          max = _a.max,\n          step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n\n    _this._onDecrement = function (value, event) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value, event);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n          min = _a.min,\n          step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\n     * This is used when validating text entry in the input on blur or when enter key is pressed\n     * (not when changed via the buttons).\n     * @param event - the event that fired\n     */\n\n\n    _this._validate = function (event) {\n      if (_this.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event); // Done validating this value, so clear it\n\n\n        _this._valueToValidate = undefined;\n\n        if (newValue !== undefined) {\n          _this._lastValidValue = newValue;\n\n          _this.setState({\n            value: newValue\n          });\n        } else {\n          // Value was invalid. Reset state to last valid value.\n          _this.setState({\n            value: _this._lastValidValue\n          });\n        }\n      }\n    };\n    /**\n     * The method is needed to ensure we are updating the actual input value.\n     * without this our value will never change (and validation will not have the correct number)\n     * @param event - the event that was fired\n     */\n\n\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n\n      _this.setState({\n        value: value\n      });\n    };\n    /**\n     * Update the value with the given stepFunction\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n     * when spinning in response to a mouseDown\n     * @param stepFunction - function to use to step by\n     * @param event - The event that triggered the updateValue\n     */\n\n\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction, event) {\n      var newValue = stepFunction(_this.value || '', event);\n\n      if (newValue !== undefined) {\n        _this._lastValidValue = newValue;\n\n        _this.setState({\n          value: newValue\n        });\n      }\n\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction, event);\n        }, stepDelay);\n      }\n    };\n    /**\n     * Stop spinning (clear any currently pending update and set spinning to false)\n     */\n\n\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n\n        _this._currentStepFunctionHandle = -1;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\n     * Handle keydown on the text field. We need to update\n     * the value when up or down arrow are depressed\n     * @param event - the keyboardEvent that was fired\n     */\n\n\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.props.disabled) {\n        _this._stop();\n\n        return;\n      }\n\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onIncrement, event);\n\n          break;\n\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onDecrement, event);\n\n          break;\n\n        case KeyCodes.enter:\n          _this._validate(event);\n\n          break;\n\n        case KeyCodes.escape:\n          if (_this.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n\n          break;\n\n        default:\n          break;\n      } // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n\n\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\n     * Make sure that we have stopped spinning on keyUp\n     * if the up or down arrow fired this event\n     * @param event - keyboard event\n     */\n\n\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n\n        return;\n      }\n    };\n\n    _this._onIncrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onIncrement, event);\n    };\n\n    _this._onDecrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onDecrement, event);\n    };\n\n    initializeComponentRef(_this);\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    }); // Don't use || here because it won't handle empty strings properly\n\n    var _a = props.value,\n        value = _a === void 0 ? props.defaultValue : _a;\n\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n\n    _this._lastValidValue = value; // Ensure that the autocalculated precision is not negative.\n\n    _this._precision = _this._calculatePrecision(props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._async = new Async(_this);\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n\n  SpinButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n\n\n  SpinButton.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({\n        value: newProps.value\n      });\n    }\n\n    this._precision = this._calculatePrecision(newProps);\n  };\n\n  SpinButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        max = _a.max,\n        labelPosition = _a.labelPosition,\n        iconProps = _a.iconProps,\n        incrementButtonIcon = _a.incrementButtonIcon,\n        incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n        decrementButtonIcon = _a.decrementButtonIcon,\n        decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        customStyles = _a.styles,\n        customUpArrowButtonStyles = _a.upArrowButtonStyles,\n        customDownArrowButtonStyles = _a.downArrowButtonStyles,\n        theme = _a.theme,\n        ariaPositionInSet = _a.ariaPositionInSet,\n        ariaSetSize = _a.ariaSetSize,\n        ariaValueNow = _a.ariaValueNow,\n        ariaValueText = _a.ariaValueText,\n        keytipProps = _a.keytipProps,\n        className = _a.className,\n        inputProps = _a.inputProps,\n        iconButtonProps = _a.iconButtonProps;\n    var _b = this.state,\n        isFocused = _b.isFocused,\n        keyboardSpinDirection = _b.keyboardSpinDirection;\n    var value = this.value;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, disabled, isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n    var nativeProps = getNativeProps(this.props, divProperties, ['onBlur', 'onFocus', 'className']);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, nativeProps, {\n        className: classNames.spinButtonWrapper,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }), React.createElement(\"input\", __assign({\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": typeof ariaValueNow === 'number' ? ariaValueNow : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? Number(value) : undefined,\n        \"aria-valuetext\": typeof ariaValueText === 'string' ? ariaValueText : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        disabled: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }, inputProps)), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps)), React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps))));\n    }), labelPosition === Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)));\n  };\n\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n\n  Object.defineProperty(SpinButton.prototype, \"value\", {\n    /**\n     * Gets the value of the spin button.\n     */\n    get: function () {\n      // TODO (version 8): value from props should ALWAYS override value from state.\n      // In a class component the code should be:\n      // const { value = this.state.value } = this.props;\n      // return value;\n      return this.state.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpinButton.prototype._onChange = function () {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  };\n\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = __decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(React.Component);\n\nexport { SpinButton };","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,KAAT,QAAsB,aAAtB;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,SACEC,sBADF,EAEEC,qBAFF,EAGEC,KAHF,EAIEC,KAJF,EAKEC,QALF,EAMEC,YANF,EAOEC,kBAPF,EAQEC,cARF,EASEC,wBATF,EAUEC,cAVF,EAWEC,aAXF,QAYO,iBAZP;AAcA,SAASC,QAAT,QAAyB,6BAAzB;AACA,SAASC,SAAT,EAAoBC,oBAApB,QAAgD,qBAAhD;AACA,SAASC,aAAT,QAA8B,yBAA9B;AACA,SAASC,UAAT,QAA2B,kBAA3B;AAEA,WAAYC,qBAAZ;;AAAA,WAAYA,qBAAZ,EAAiC;EAC/BA;EACAA;EACAA;AACD,CAJD,EAAYA,qBAAqB,KAArBA,qBAAqB,MAAjC;;AAoCA;AAAA;AAAA;EAAgCC;;EAyB9B,oBAAYC,KAAZ,EAAmC;IAAnC,YACEC,kBAAMD,KAAN,KAAY,IADd;;IAZQE,eAASxB,KAAK,CAACyB,SAAN,EAAT;IASAD,0BAAoB,GAApB;IACAA,mBAAa,EAAb;;IA+NAA,iBAAW,UAACE,EAAD,EAAuC;MACxD;MACA,IAAI,CAACF,KAAI,CAACG,MAAL,CAAYC,OAAjB,EAA0B;QACxB;MACD;;MAED,IAAIJ,KAAI,CAACK,gBAAL,IAAyBL,KAAI,CAACM,KAAL,CAAWC,qBAAX,KAAqCX,qBAAqB,CAACY,WAAxF,EAAqG;QACnGR,KAAI,CAACS,KAAL;MACD;;MAEDT,KAAI,CAACG,MAAL,CAAYC,OAAZ,CAAoBM,MAApB;;MAEAV,KAAI,CAACW,QAAL,CAAc;QAAEC,SAAS,EAAE;MAAb,CAAd;;MAEA,IAAIZ,KAAI,CAACF,KAAL,CAAWe,OAAf,EAAwB;QACtBb,KAAI,CAACF,KAAL,CAAWe,OAAX,CAAmBX,EAAnB;MACD;IACF,CAjBO;;IAmBAF,gBAAU,UAACE,EAAD,EAAuC;MACvDF,KAAI,CAACc,SAAL,CAAeZ,EAAf;;MACAF,KAAI,CAACW,QAAL,CAAc;QAAEC,SAAS,EAAE;MAAb,CAAd;;MACA,IAAIZ,KAAI,CAACF,KAAL,CAAWiB,MAAf,EAAuB;QACrBf,KAAI,CAACF,KAAL,CAAWiB,MAAX,CAAkBb,EAAlB;MACD;IACF,CANO;;IAQAF,oBAAc,UAACgB,KAAD,EAAgBC,KAAhB,EAAyD;MAC7E,IAAIjB,KAAI,CAACF,KAAL,CAAWoB,UAAf,EAA2B;QACzB,OAAOlB,KAAI,CAACF,KAAL,CAAWoB,UAAX,CAAsBF,KAAtB,EAA6BC,KAA7B,CAAP;MACD,CAFD,MAEO;QACL,OAAOjB,KAAI,CAACmB,kBAAL,CAAwBH,KAAxB,CAAP;MACD;IACF,CANO;;IAQAhB,4BAAsB,UAACF,KAAD,EAAuC;MAC3D;MAAA;MACR,OAAOsB,SAAP;IACD,CAHO;IAKR;;;;;IAGQpB,2BAAqB,UAACgB,KAAD,EAAc;MACzC,IAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,CAACK,IAAN,GAAaC,MAAb,KAAwB,CAA1C,IAA+CC,KAAK,CAACC,MAAM,CAACR,KAAD,CAAP,CAAxD,EAAyE;QACvE,OAAOhB,KAAI,CAACyB,eAAZ;MACD;;MACD,IAAMC,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAS5B,KAAI,CAACF,KAAL,CAAW+B,GAApB,EAAmCF,IAAI,CAACE,GAAL,CAAS7B,KAAI,CAACF,KAAL,CAAW8B,GAApB,EAAmCJ,MAAM,CAACR,KAAD,CAAzC,CAAnC,CAAjB;MACA,OAAOc,MAAM,CAACJ,QAAD,CAAb;IACD,CANO;;IAQA1B,qBAAe,UACrBgB,KADqB,EAErBC,KAFqB,EAEmD;MAExE,IAAIjB,KAAI,CAACF,KAAL,CAAWiC,WAAf,EAA4B;QAC1B,OAAO/B,KAAI,CAACF,KAAL,CAAWiC,WAAX,CAAuBf,KAAvB,EAA8BC,KAA9B,CAAP;MACD,CAFD,MAEO;QACL,OAAOjB,KAAI,CAACgC,mBAAL,CAAyBhB,KAAzB,CAAP;MACD;IACF,CATO;IAWR;;;;;IAGQhB,4BAAsB,UAACgB,KAAD,EAAc;MACpC;MAAA,IAAEa,YAAF;MAAA,IAAOI,cAAP;MACN,IAAIP,QAAQ,GAAWC,IAAI,CAACC,GAAL,CAASJ,MAAM,CAACR,KAAD,CAAN,GAAgBQ,MAAM,CAACS,IAAD,CAA/B,EAAuCJ,GAAvC,CAAvB;MACAH,QAAQ,GAAGvC,cAAc,CAACuC,QAAD,EAAW1B,KAAI,CAACkC,UAAhB,CAAzB;MACA,OAAOJ,MAAM,CAACJ,QAAD,CAAb;IACD,CALO;;IAOA1B,qBAAe,UACrBgB,KADqB,EAErBC,KAFqB,EAEmD;MAExE,IAAIjB,KAAI,CAACF,KAAL,CAAWqC,WAAf,EAA4B;QAC1B,OAAOnC,KAAI,CAACF,KAAL,CAAWqC,WAAX,CAAuBnB,KAAvB,EAA8BC,KAA9B,CAAP;MACD,CAFD,MAEO;QACL,OAAOjB,KAAI,CAACoC,mBAAL,CAAyBpB,KAAzB,CAAP;MACD;IACF,CATO;IAWR;;;;;IAGQhB,4BAAsB,UAACgB,KAAD,EAAc;MACpC;MAAA,IAAEY,YAAF;MAAA,IAAOK,cAAP;MACN,IAAIP,QAAQ,GAAWC,IAAI,CAACE,GAAL,CAASL,MAAM,CAACR,KAAD,CAAN,GAAgBQ,MAAM,CAACS,IAAD,CAA/B,EAAuCL,GAAvC,CAAvB;MACAF,QAAQ,GAAGvC,cAAc,CAACuC,QAAD,EAAW1B,KAAI,CAACkC,UAAhB,CAAzB;MACA,OAAOJ,MAAM,CAACJ,QAAD,CAAb;IACD,CALO;IAmBR;;;;;;;IAKQ1B,kBAAY,UAACiB,KAAD,EAAkF;MACpG,IACEjB,KAAI,CAACgB,KAAL,KAAeqB,SAAf,IACArC,KAAI,CAACsC,gBAAL,KAA0BD,SAD1B,IAEArC,KAAI,CAACsC,gBAAL,KAA0BtC,KAAI,CAACyB,eAHjC,EAIE;QACA,IAAMC,QAAQ,GAAG1B,KAAI,CAACuC,WAAL,CAAkBvC,KAAI,CAACsC,gBAAvB,EAAyCrB,KAAzC,CAAjB,CADA,CAEA;;;QACAjB,KAAI,CAACsC,gBAAL,GAAwBD,SAAxB;;QAEA,IAAIX,QAAQ,KAAKW,SAAjB,EAA4B;UAC1BrC,KAAI,CAACyB,eAAL,GAAuBC,QAAvB;;UACA1B,KAAI,CAACW,QAAL,CAAc;YAAEK,KAAK,EAAEU;UAAT,CAAd;QACD,CAHD,MAGO;UACL;UACA1B,KAAI,CAACW,QAAL,CAAc;YAAEK,KAAK,EAAEhB,KAAI,CAACyB;UAAd,CAAd;QACD;MACF;IACF,CAlBO;IAoBR;;;;;;;IAKQzB,uBAAiB,UAACiB,KAAD,EAA+D;MACtF,IAAMuB,OAAO,GAAqBvB,KAAK,CAACwB,MAAxC;MACA,IAAMzB,KAAK,GAAWwB,OAAO,CAACxB,KAA9B;MACAhB,KAAI,CAACsC,gBAAL,GAAwBtB,KAAxB;;MACAhB,KAAI,CAACW,QAAL,CAAc;QACZK,KAAK,EAAEA;MADK,CAAd;IAGD,CAPO;IASR;;;;;;;;;IAOQhB,qBAAe,UACrB0C,UADqB,EAErBC,SAFqB,EAGrBC,YAHqB,EAOrB3B,KAPqB,EAOmD;MAExE,IAAMS,QAAQ,GAAkBkB,YAAY,CAAC5C,KAAI,CAACgB,KAAL,IAAc,EAAf,EAAmBC,KAAnB,CAA5C;;MACA,IAAIS,QAAQ,KAAKW,SAAjB,EAA4B;QAC1BrC,KAAI,CAACyB,eAAL,GAAuBC,QAAvB;;QACA1B,KAAI,CAACW,QAAL,CAAc;UAAEK,KAAK,EAAEU;QAAT,CAAd;MACD;;MAED,IAAI1B,KAAI,CAACK,gBAAL,KAA0BqC,UAA9B,EAA0C;QACxC1C,KAAI,CAACK,gBAAL,GAAwBqC,UAAxB;MACD;;MAED,IAAIA,UAAJ,EAAgB;QACd1C,KAAI,CAAC6C,0BAAL,GAAkC7C,KAAI,CAAC8C,MAAL,CAAYC,UAAZ,CAAuB;UACvD/C,KAAI,CAACgD,YAAL,CAAkBN,UAAlB,EAA8B1C,KAAI,CAACiD,UAAnC,EAA+CL,YAA/C,EAA6D3B,KAA7D;QACD,CAFiC,EAE/B0B,SAF+B,CAAlC;MAGD;IACF,CAxBO;IA0BR;;;;;IAGQ3C,cAAQ;MACd,IAAIA,KAAI,CAAC6C,0BAAL,IAAmC,CAAvC,EAA0C;QACxC7C,KAAI,CAAC8C,MAAL,CAAYI,YAAZ,CAAyBlD,KAAI,CAAC6C,0BAA9B;;QACA7C,KAAI,CAAC6C,0BAAL,GAAkC,CAAC,CAAnC;MACD;;MAED,IAAI7C,KAAI,CAACK,gBAAL,IAAyBL,KAAI,CAACM,KAAL,CAAWC,qBAAX,KAAqCX,qBAAqB,CAACY,WAAxF,EAAqG;QACnGR,KAAI,CAACK,gBAAL,GAAwB,KAAxB;;QACAL,KAAI,CAACW,QAAL,CAAc;UAAEJ,qBAAqB,EAAEX,qBAAqB,CAACY;QAA/C,CAAd;MACD;IACF,CAVO;IAYR;;;;;;;IAKQR,uBAAiB,UAACiB,KAAD,EAA6C;MACpE;MACA;MACA,IAAIA,KAAK,CAACkC,KAAN,KAAgBnE,QAAQ,CAACoE,EAAzB,IAA+BnC,KAAK,CAACkC,KAAN,KAAgBnE,QAAQ,CAACqE,IAAxD,IAAgEpC,KAAK,CAACkC,KAAN,KAAgBnE,QAAQ,CAACsE,KAA7F,EAAoG;QAClGrC,KAAK,CAACsC,cAAN;QACAtC,KAAK,CAACuC,eAAN;MACD;;MAED,IAAIxD,KAAI,CAACF,KAAL,CAAW2D,QAAf,EAAyB;QACvBzD,KAAI,CAACS,KAAL;;QACA;MACD;;MAED,IAAIiD,aAAa,GAAG9D,qBAAqB,CAACY,WAA1C;;MAEA,QAAQS,KAAK,CAACkC,KAAd;QACE,KAAKnE,QAAQ,CAACoE,EAAd;UACEM,aAAa,GAAG9D,qBAAqB,CAACwD,EAAtC;;UACApD,KAAI,CAACgD,YAAL,CAAkB;UAAM;UAAxB,EAA0ChD,KAAI,CAAC2D,iBAA/C,EAAkE3D,KAAI,CAAC4D,YAAvE,EAAsF3C,KAAtF;;UACA;;QACF,KAAKjC,QAAQ,CAACqE,IAAd;UACEK,aAAa,GAAG9D,qBAAqB,CAACyD,IAAtC;;UACArD,KAAI,CAACgD,YAAL,CAAkB;UAAM;UAAxB,EAA0ChD,KAAI,CAAC2D,iBAA/C,EAAkE3D,KAAI,CAAC6D,YAAvE,EAAsF5C,KAAtF;;UACA;;QACF,KAAKjC,QAAQ,CAACsE,KAAd;UACEtD,KAAI,CAACc,SAAL,CAAeG,KAAf;;UACA;;QACF,KAAKjC,QAAQ,CAAC8E,MAAd;UACE,IAAI9D,KAAI,CAACgB,KAAL,KAAehB,KAAI,CAACyB,eAAxB,EAAyC;YACvCzB,KAAI,CAACW,QAAL,CAAc;cAAEK,KAAK,EAAEhB,KAAI,CAACyB;YAAd,CAAd;UACD;;UACD;;QACF;UACE;MAlBJ,CAfoE,CAoCpE;MACA;;;MACA,IAAIzB,KAAI,CAACM,KAAL,CAAWC,qBAAX,KAAqCmD,aAAzC,EAAwD;QACtD1D,KAAI,CAACW,QAAL,CAAc;UAAEJ,qBAAqB,EAAEmD;QAAzB,CAAd;MACD;IACF,CAzCO;IA2CR;;;;;;;IAKQ1D,qBAAe,UAACiB,KAAD,EAAwC;MAC7D,IAAIjB,KAAI,CAACF,KAAL,CAAW2D,QAAX,IAAuBxC,KAAK,CAACkC,KAAN,KAAgBnE,QAAQ,CAACoE,EAAhD,IAAsDnC,KAAK,CAACkC,KAAN,KAAgBnE,QAAQ,CAACqE,IAAnF,EAAyF;QACvFrD,KAAI,CAACS,KAAL;;QACA;MACD;IACF,CALO;;IAOAT,8BAAwB,UAACiB,KAAD,EAAqC;MACnEjB,KAAI,CAACgD,YAAL,CAAkB;MAAK;MAAvB,EAAyChD,KAAI,CAAC2D,iBAA9C,EAAiE3D,KAAI,CAAC4D,YAAtE,EAAqF3C,KAArF;IACD,CAFO;;IAIAjB,8BAAwB,UAACiB,KAAD,EAAqC;MACnEjB,KAAI,CAACgD,YAAL,CAAkB;MAAK;MAAvB,EAAyChD,KAAI,CAAC2D,iBAA9C,EAAiE3D,KAAI,CAAC6D,YAAtE,EAAqF5C,KAArF;IACD,CAFO;;IA1dNrC,sBAAsB,CAACoB,KAAD,CAAtB;IAEAnB,qBAAqB,CAAC,YAAD,EAAeiB,KAAf,EAAsB;MACzCkB,KAAK,EAAE;IADkC,CAAtB,CAArB,CALiC,CASjC;;IACM;IAAA;;IACN,IAAIA,KAAK,KAAKqB,SAAd,EAAyB;MACvBrB,KAAK,GAAG,OAAOlB,KAAK,CAAC8B,GAAb,KAAqB,QAArB,GAAgCE,MAAM,CAAChC,KAAK,CAAC8B,GAAP,CAAtC,GAAoD,GAA5D;IACD;;IACD5B,KAAI,CAACyB,eAAL,GAAuBT,KAAvB,CAdiC,CAgBjC;;IACAhB,KAAI,CAACkC,UAAL,GAAkBlC,KAAI,CAAC+D,mBAAL,CAAyBjE,KAAzB,CAAlB;IAEAE,KAAI,CAACM,KAAL,GAAa;MACXM,SAAS,EAAE,KADA;MAEXI,KAAK,OAFM;MAGXT,qBAAqB,EAAEX,qBAAqB,CAACY;IAHlC,CAAb;IAMAR,KAAI,CAAC8C,MAAL,GAAc,IAAIhE,KAAJ,CAAUkB,KAAV,CAAd;IACAA,KAAI,CAAC6C,0BAAL,GAAkC,CAAC,CAAnC;IACA7C,KAAI,CAACgE,QAAL,GAAgBjF,KAAK,CAAC,OAAD,CAArB;IACAiB,KAAI,CAACiE,QAAL,GAAgBlF,KAAK,CAAC,OAAD,CAArB;IACAiB,KAAI,CAACK,gBAAL,GAAwB,KAAxB;IACAL,KAAI,CAACsC,gBAAL,GAAwBD,SAAxB;;EACD;;EAEM6B,4CAAP;IACE,KAAKpB,MAAL,CAAYqB,OAAZ;EACD,CAFM;EAIP;;;;;EAGOD,wDAAP,UAAwCE,QAAxC,EAAkE;IAChE,IAAIA,QAAQ,CAACpD,KAAT,KAAmBqB,SAAvB,EAAkC;MAChC;MACA,KAAKZ,eAAL,GAAuB2C,QAAQ,CAACpD,KAAhC;MACA,KAAKL,QAAL,CAAc;QAAEK,KAAK,EAAEoD,QAAQ,CAACpD;MAAlB,CAAd;IACD;;IACD,KAAKkB,UAAL,GAAkB,KAAK6B,mBAAL,CAAyBK,QAAzB,CAAlB;EACD,CAPM;;EASAF,8BAAP;IAAA;;IACQ;IAAA,IACJT,sBADI;IAAA,IAEJY,gBAFI;IAAA,IAGJzC,YAHI;IAAA,IAIJC,YAJI;IAAA,IAKJyC,gCALI;IAAA,IAMJC,wBANI;IAAA,IAOJC,4CAPI;IAAA,IAQJC,sDARI;IAAA,IASJC,4CATI;IAAA,IAUJC,sDAVI;IAAA,IAWJC,wBAXI;IAAA,IAYJC,oCAZI;IAAA,IAaJC,wBAbI;IAAA,IAcJC,kDAdI;IAAA,IAeJC,sDAfI;IAAA,IAgBJC,gBAhBI;IAAA,IAiBJC,wCAjBI;IAAA,IAkBJC,4BAlBI;IAAA,IAmBJC,8BAnBI;IAAA,IAoBJC,gCApBI;IAAA,IAqBJC,4BArBI;IAAA,IAsBJC,wBAtBI;IAAA,IAuBJC,0BAvBI;IAAA,IAwBJC,oCAxBI;IA2BA;IAAA,IAAE7E,wBAAF;IAAA,IAAaL,gDAAb;IACN,IAAMS,KAAK,GAAG,KAAKA,KAAnB;IAEA,IAAM0E,UAAU,GAAG,KAAK5F,KAAL,CAAWJ,aAAX,GACf,KAAKI,KAAL,CAAWJ,aAAX,CAAyBuF,KAAzB,EAAiCxB,QAAjC,EAA2C7C,SAA3C,EAAsDL,qBAAtD,EAA6E+D,aAA7E,EAA4FiB,SAA5F,CADe,GAEf7F,aAAa,CACXF,SAAS,CAACyF,KAAD,EAASH,YAAT,CADE,EAEXrB,QAFW,EAGX7C,SAHW,EAIXL,qBAJW,EAKX+D,aALW,EAMXiB,SANW,CAFjB;IAWA,IAAMI,WAAW,GAAGtG,cAAc,CAAuC,KAAKS,KAA5C,EAAmDR,aAAnD,EAAkE,CAClG,QADkG,EAElG,SAFkG,EAGlG,WAHkG,CAAlE,CAAlC;IAMA,OACEd;MAAK+G,SAAS,EAAEG,UAAU,CAACE;IAA3B,GACGtB,aAAa,KAAK/E,QAAQ,CAACsG,MAA3B,KAAsCtB,SAAS,IAAIF,KAAnD,KACC7F;MAAK+G,SAAS,EAAEG,UAAU,CAACI;IAA3B,GACGvB,SAAS,IAAI/F,oBAACG,IAAD,EAAKoH,aAAKxB,SAAL,EAAc;MAAEgB,SAAS,EAAEG,UAAU,CAACM,IAAxB;MAA4B,eAAc;IAA1C,CAAd,CAAL,CADhB,EAEG3B,KAAK,IACJ7F,oBAACE,KAAD,EAAM;MAACuH,EAAE,EAAE,KAAKjC,QAAV;MAAoBkC,OAAO,EAAE,KAAKjC,QAAlC;MAA4CsB,SAAS,EAAEG,UAAU,CAACrB,KAAlE;MAAyEZ,QAAQ,EAAEA;IAAnF,CAAN,EACGY,KADH,CAHJ,CAFJ,EAWE7F,oBAACmB,UAAD,EAAW;MAAC2F,WAAW,EAAEA,WAAd;MAA2B7B,QAAQ,EAAEA;IAArC,CAAX,EACG,UAAC0C,gBAAD,EAAsB;MAAkB,OACvC3H,wCACMmH,WADN,EACiB;QACfJ,SAAS,EAAEG,UAAU,CAACU,iBADP;QACwB,cAC3BxB,SAAS,IAAIA,SAFV;QAEmB,iBACnBM,iBAHA;QAGiB,gBAClBC,WAJC;QAIU,mBACRgB,gBAAgB,CAAC,iBAAD;MALlB,CADjB,GAQE3H;QACEwC,KAAK,EAAEA,KADT;QAEEiF,EAAE,EAAEjG,KAAI,CAACiE,QAFX;QAGEoC,QAAQ,EAAErG,KAAI,CAACsG,SAHjB;QAIEC,OAAO,EAAEvG,KAAI,CAACwG,cAJhB;QAKEjB,SAAS,EAAEG,UAAU,CAACe,KALxB;QAMEC,IAAI,EAAC,MANP;QAOEC,YAAY,EAAC,KAPf;QAQEC,IAAI,EAAC,YARP;QAQmB,mBACAvC,KAAK,IAAIrE,KAAI,CAACgE,QATjC;QASyC,iBAErC,OAAOoB,YAAP,KAAwB,QAAxB,GACIA,YADJ,GAEIpE,KAAK,IAAI,CAACO,KAAK,CAACC,MAAM,CAACR,KAAD,CAAP,CAAf,CAA+B;QAA/B,EACAQ,MAAM,CAACR,KAAD,CADN,GAEAqB,SAfR;QAeiB,kBAGb,OAAOgD,aAAP,KAAyB,QAAzB,GACIA,aADJ,GAEI,CAACrE,KAAD,IAAUO,KAAK,CAACC,MAAM,CAACR,KAAD,CAAP,CAAf,CAA+B;QAA/B,EACAA,KADA,GAEAqB,SAtBR;QAsBiB,iBAEAT,GAxBjB;QAwBoB,iBACHC,GAzBjB;QAyBoB,oBACAzC,wBAAwB,CAACyF,eAAD,EAAkBsB,gBAAgB,CAAC,kBAAD,CAAlC,CA1B5C;QA2BEpF,MAAM,EAAEf,KAAI,CAAC6G,OA3Bf;QA4BEC,GAAG,EAAE9G,KAAI,CAACG,MA5BZ;QA6BEU,OAAO,EAAEb,KAAI,CAAC+G,QA7BhB;QA8BEC,SAAS,EAAEhH,KAAI,CAACiH,cA9BlB;QA+BEC,OAAO,EAAElH,KAAI,CAACmH,YA/BhB;QAgCE1D,QAAQ,EAAEA,QAhCZ;QAgCoB,iBACHA,QAjCjB;QAiCyB,iBACR,IAlCjB;QAkCqB,2BACM0C,gBAAgB,CAAC,yBAAD;MAnC3C,GAoCMX,UApCN,EARF,EA8CEhH;QAAM+G,SAAS,EAAEG,UAAU,CAAC0B;MAA5B,GACE5I,oBAACC,UAAD,EAAWsH;QACTsB,MAAM,EAAE5H,oBAAoB,CAACwF,KAAD,EAAS,IAAT,EAAeF,yBAAf,CADnB;QAETQ,SAAS,EAAE,aAFF;QAGT+B,OAAO,EAAE/G,qBAAqB,KAAKX,qBAAqB,CAACwD,EAHhD;QAITK,QAAQ,EAAEA,QAJD;QAKTc,SAAS,EAAEC,mBALF;QAMT+C,WAAW,EAAEvH,KAAI,CAACwH,qBANT;QAOTC,YAAY,EAAEzH,KAAI,CAACS,KAPV;QAQTiH,SAAS,EAAE1H,KAAI,CAACS,KARP;QASTkH,QAAQ,EAAE,CAAC,CATF;QAUT/C,SAAS,EAAEH,wBAVF;QAU0B,qBAChB;MAXV,GAYLgB,eAZK,CAAX,CADF,EAeEjH,oBAACC,UAAD,EAAWsH;QACTsB,MAAM,EAAE5H,oBAAoB,CAACwF,KAAD,EAAS,KAAT,EAAgBD,2BAAhB,CADnB;QAETO,SAAS,EAAE,eAFF;QAGT+B,OAAO,EAAE/G,qBAAqB,KAAKX,qBAAqB,CAACyD,IAHhD;QAITI,QAAQ,EAAEA,QAJD;QAKTc,SAAS,EAAEG,mBALF;QAMT6C,WAAW,EAAEvH,KAAI,CAAC4H,qBANT;QAOTH,YAAY,EAAEzH,KAAI,CAACS,KAPV;QAQTiH,SAAS,EAAE1H,KAAI,CAACS,KARP;QASTkH,QAAQ,EAAE,CAAC,CATF;QAUT/C,SAAS,EAAED,wBAVF;QAU0B,qBAChB;MAXV,GAYLc,eAZK,CAAX,CAfF,CA9CF,CADuC;IA8ExC,CA/EH,CAXF,EA4FGnB,aAAa,KAAK/E,QAAQ,CAACsG,MAA3B,KAAsCtB,SAAS,IAAIF,KAAnD,KACC7F;MAAK+G,SAAS,EAAEG,UAAU,CAACI;IAA3B,GACGvB,SAAS,IAAI/F,oBAACG,IAAD,EAAK;MAACkJ,QAAQ,EAAEtD,SAAS,CAACsD,QAArB;MAA+BtC,SAAS,EAAEG,UAAU,CAACM,IAArD;MAAyD,eAAc;IAAvE,CAAL,CADhB,EAEG3B,KAAK,IACJ7F,oBAACE,KAAD,EAAM;MAACuH,EAAE,EAAE,KAAKjC,QAAV;MAAoBkC,OAAO,EAAE,KAAKjC,QAAlC;MAA4CsB,SAAS,EAAEG,UAAU,CAACrB,KAAlE;MAAyEZ,QAAQ,EAAEA;IAAnF,CAAN,EACGY,KADH,CAHJ,CA7FJ,CADF;EAyGD,CAzJM;;EA2JAH,6BAAP;IACE,IAAI,KAAK/D,MAAL,CAAYC,OAAhB,EAAyB;MACvB,KAAKD,MAAL,CAAYC,OAAZ,CAAoB0H,KAApB;IACD;EACF,CAJM;;EASPC,sBAAW7D,oBAAX,EAAW,OAAX,EAAgB;IAHhB;;;SAGA;MACE;MACA;MACA;MACA;MACA,OAAO,KAAK5D,KAAL,CAAWU,KAAlB;IACD,CANe;oBAAA;;EAAA,CAAhB;;EAqGQkD,iCAAR;IACE;;;;;;;;;EASD,CAVO;;EAlVMA,0BAA6B;IACzCjC,IAAI,EAAE,CADmC;IAEzCL,GAAG,EAAE,CAFoC;IAGzCC,GAAG,EAAE,GAHoC;IAIzC4B,QAAQ,EAAE,KAJ+B;IAKzCa,aAAa,EAAE/E,QAAQ,CAACyI,KALiB;IAMzC3D,KAAK,EAAE,EANkC;IAOzCG,mBAAmB,EAAE;MAAEqD,QAAQ,EAAE;IAAZ,CAPoB;IAQzCnD,mBAAmB,EAAE;MAAEmD,QAAQ,EAAE;IAAZ;EARoB,CAA7B;EADH3D,UAAU,eADtBjF,YAAY,CAAC,YAAD,EAAe,CAAC,OAAD,EAAU,QAAV,CAAf,EAAoC,IAApC,CACU,GAAViF,UAAU,CAAV;EAyfb;AAAC,CAzfD,CAAgC1F,KAAK,CAACyJ,SAAtC;;SAAa/D","names":["React","IconButton","Label","Icon","initializeComponentRef","warnMutuallyExclusive","Async","getId","KeyCodes","customizable","calculatePrecision","precisionRound","mergeAriaAttributeValues","getNativeProps","divProperties","Position","getStyles","getArrowButtonStyles","getClassNames","KeytipData","KeyboardSpinDirection","__extends","props","_super","_this","createRef","ev","_input","current","_spinningByMouse","state","keyboardSpinDirection","notSpinning","_stop","select","setState","isFocused","onFocus","_validate","onBlur","value","event","onValidate","_defaultOnValidate","precision","trim","length","isNaN","Number","_lastValidValue","newValue","Math","min","max","String","onIncrement","_defaultOnIncrement","step","_precision","onDecrement","_defaultOnDecrement","undefined","_valueToValidate","_onValidate","element","target","shouldSpin","stepDelay","stepFunction","_currentStepFunctionHandle","_async","setTimeout","_updateValue","_stepDelay","clearTimeout","which","up","down","enter","preventDefault","stopPropagation","disabled","spinDirection","_initialStepDelay","_onIncrement","_onDecrement","escape","_calculatePrecision","_labelId","_inputId","SpinButton","dispose","newProps","label","labelPosition","iconProps","incrementButtonIcon","incrementButtonAriaLabel","decrementButtonIcon","decrementButtonAriaLabel","ariaLabel","ariaDescribedBy","customStyles","customUpArrowButtonStyles","customDownArrowButtonStyles","theme","ariaPositionInSet","ariaSetSize","ariaValueNow","ariaValueText","keytipProps","className","inputProps","iconButtonProps","classNames","nativeProps","root","bottom","labelWrapper","__assign","icon","id","htmlFor","keytipAttributes","spinButtonWrapper","onChange","_onChange","onInput","_onInputChange","input","type","autoComplete","role","_onBlur","ref","_onFocus","onKeyDown","_handleKeyDown","onKeyUp","_handleKeyUp","arrowBox","styles","checked","onMouseDown","_onIncrementMouseDown","onMouseLeave","onMouseUp","tabIndex","_onDecrementMouseDown","iconName","focus","Object","start","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\SpinButton\\SpinButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  initializeComponentRef,\n  warnMutuallyExclusive,\n  Async,\n  getId,\n  KeyCodes,\n  customizable,\n  calculatePrecision,\n  precisionRound,\n  mergeAriaAttributeValues,\n  getNativeProps,\n  divProperties,\n} from '../../Utilities';\nimport { ISpinButton, ISpinButtonProps } from './SpinButton.types';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\n\nexport enum KeyboardSpinDirection {\n  down = -1,\n  notSpinning = 0,\n  up = 1,\n}\n\nexport interface ISpinButtonState {\n  /**\n   * Is true when the control has focus.\n   */\n  isFocused: boolean;\n\n  /**\n   * the value of the spin button\n   */\n  value: string;\n\n  /**\n   * keyboard spin direction, used to style the up or down button\n   * as active when up/down arrow is pressed\n   */\n  keyboardSpinDirection: KeyboardSpinDirection;\n}\n\n// TODO (Fabric Next): remove default min/max values (issue #11358).\nexport type DefaultProps = Required<\n  Pick<\n    ISpinButtonProps,\n    'step' | 'min' | 'max' | 'disabled' | 'labelPosition' | 'label' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n>;\n\n/** Internal only props */\ntype ISpinButtonInternalProps = ISpinButtonProps & DefaultProps;\n\n@customizable('SpinButton', ['theme', 'styles'], true)\nexport class SpinButton extends React.Component<ISpinButtonProps, ISpinButtonState> implements ISpinButton {\n  public static defaultProps: DefaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n    decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n  };\n\n  private _async: Async;\n  private _input = React.createRef<HTMLInputElement>();\n  private _inputId: string;\n  private _labelId: string;\n  private _lastValidValue: string;\n  private _spinningByMouse: boolean;\n  private _valueToValidate: string | undefined; // To avoid duplicate validations/submissions\n  private _precision: number;\n\n  private _currentStepFunctionHandle: number;\n  private _initialStepDelay = 400;\n  private _stepDelay = 75;\n\n  constructor(props: ISpinButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue',\n    });\n\n    // Don't use || here because it won't handle empty strings properly\n    let { value = props.defaultValue } = props;\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n    this._lastValidValue = value;\n\n    // Ensure that the autocalculated precision is not negative.\n    this._precision = this._calculatePrecision(props as ISpinButtonInternalProps);\n\n    this.state = {\n      isFocused: false,\n      value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning,\n    };\n\n    this._async = new Async(this);\n    this._currentStepFunctionHandle = -1;\n    this._labelId = getId('Label');\n    this._inputId = getId('input');\n    this._spinningByMouse = false;\n    this._valueToValidate = undefined;\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  public UNSAFE_componentWillReceiveProps(newProps: ISpinButtonProps): void {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({ value: newProps.value });\n    }\n    this._precision = this._calculatePrecision(newProps as ISpinButtonProps & DefaultProps);\n  }\n\n  public render(): JSX.Element {\n    const {\n      disabled,\n      label,\n      min,\n      max,\n      labelPosition,\n      iconProps,\n      incrementButtonIcon,\n      incrementButtonAriaLabel,\n      decrementButtonIcon,\n      decrementButtonAriaLabel,\n      ariaLabel,\n      ariaDescribedBy,\n      styles: customStyles,\n      upArrowButtonStyles: customUpArrowButtonStyles,\n      downArrowButtonStyles: customDownArrowButtonStyles,\n      theme,\n      ariaPositionInSet,\n      ariaSetSize,\n      ariaValueNow,\n      ariaValueText,\n      keytipProps,\n      className,\n      inputProps,\n      iconButtonProps,\n    } = this.props as ISpinButtonInternalProps;\n\n    const { isFocused, keyboardSpinDirection } = this.state;\n    const value = this.value;\n\n    const classNames = this.props.getClassNames\n      ? this.props.getClassNames(theme!, disabled, isFocused, keyboardSpinDirection, labelPosition, className)\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          disabled,\n          isFocused,\n          keyboardSpinDirection,\n          labelPosition,\n          className,\n        );\n\n    const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onBlur',\n      'onFocus',\n      'className',\n    ]);\n\n    return (\n      <div className={classNames.root}>\n        {labelPosition !== Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n        <KeytipData keytipProps={keytipProps} disabled={disabled}>\n          {(keytipAttributes: any): JSX.Element => (\n            <div\n              {...nativeProps}\n              className={classNames.spinButtonWrapper}\n              aria-label={ariaLabel && ariaLabel}\n              aria-posinset={ariaPositionInSet}\n              aria-setsize={ariaSetSize}\n              data-ktp-target={keytipAttributes['data-ktp-target']}\n            >\n              <input\n                value={value}\n                id={this._inputId}\n                onChange={this._onChange}\n                onInput={this._onInputChange}\n                className={classNames.input}\n                type=\"text\"\n                autoComplete=\"off\"\n                role=\"spinbutton\"\n                aria-labelledby={label && this._labelId}\n                aria-valuenow={\n                  typeof ariaValueNow === 'number'\n                    ? ariaValueNow\n                    : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? Number(value)\n                    : undefined\n                }\n                aria-valuetext={\n                  typeof ariaValueText === 'string'\n                    ? ariaValueText\n                    : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? value\n                    : undefined\n                }\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])}\n                onBlur={this._onBlur}\n                ref={this._input}\n                onFocus={this._onFocus}\n                onKeyDown={this._handleKeyDown}\n                onKeyUp={this._handleKeyUp}\n                disabled={disabled}\n                aria-disabled={disabled}\n                data-lpignore={true}\n                data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n                {...inputProps}\n              />\n              <span className={classNames.arrowBox}>\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n                  className={'ms-UpButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n                  disabled={disabled}\n                  iconProps={incrementButtonIcon}\n                  onMouseDown={this._onIncrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={incrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n                  className={'ms-DownButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n                  disabled={disabled}\n                  iconProps={decrementButtonIcon}\n                  onMouseDown={this._onDecrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={decrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n              </span>\n            </div>\n          )}\n        </KeytipData>\n        {labelPosition === Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon iconName={iconProps.iconName} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public focus(): void {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  }\n\n  /**\n   * Gets the value of the spin button.\n   */\n  public get value(): string | undefined {\n    // TODO (version 8): value from props should ALWAYS override value from state.\n    // In a class component the code should be:\n    // const { value = this.state.value } = this.props;\n    // return value;\n    return this.state.value;\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!this._input.current) {\n      return;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._stop();\n    }\n\n    this._input.current.select();\n\n    this.setState({ isFocused: true });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n  };\n\n  private _onBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    this._validate(ev);\n    this.setState({ isFocused: false });\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n  };\n\n  private _onValidate = (value: string, event?: React.SyntheticEvent<HTMLElement>): string | void => {\n    if (this.props.onValidate) {\n      return this.props.onValidate(value, event);\n    } else {\n      return this._defaultOnValidate(value);\n    }\n  };\n\n  private _calculatePrecision = (props: ISpinButtonProps & DefaultProps) => {\n    const { precision = Math.max(calculatePrecision(props.step), 0) } = props;\n    return precision;\n  };\n\n  /**\n   * Validate function to use if one is not passed in\n   */\n  private _defaultOnValidate = (value: string) => {\n    if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n      return this._lastValidValue;\n    }\n    const newValue = Math.min(this.props.max as number, Math.max(this.props.min as number, Number(value)));\n    return String(newValue);\n  };\n\n  private _onIncrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onIncrement) {\n      return this.props.onIncrement(value, event);\n    } else {\n      return this._defaultOnIncrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnIncrement = (value: string): string | void => {\n    const { max, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.min(Number(value) + Number(step), max);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onDecrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onDecrement) {\n      return this.props.onDecrement(value, event);\n    } else {\n      return this._defaultOnDecrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnDecrement = (value: string): string | void => {\n    const { min, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.max(Number(value) - Number(step), min);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onChange(): void {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  }\n\n  /**\n   * This is used when validating text entry in the input on blur or when enter key is pressed\n   * (not when changed via the buttons).\n   * @param event - the event that fired\n   */\n  private _validate = (event: React.FocusEvent<HTMLInputElement> | React.KeyboardEvent<HTMLInputElement>): void => {\n    if (\n      this.value !== undefined &&\n      this._valueToValidate !== undefined &&\n      this._valueToValidate !== this._lastValidValue\n    ) {\n      const newValue = this._onValidate!(this._valueToValidate, event);\n      // Done validating this value, so clear it\n      this._valueToValidate = undefined;\n\n      if (newValue !== undefined) {\n        this._lastValidValue = newValue;\n        this.setState({ value: newValue });\n      } else {\n        // Value was invalid. Reset state to last valid value.\n        this.setState({ value: this._lastValidValue });\n      }\n    }\n  };\n\n  /**\n   * The method is needed to ensure we are updating the actual input value.\n   * without this our value will never change (and validation will not have the correct number)\n   * @param event - the event that was fired\n   */\n  private _onInputChange = (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>): void => {\n    const element: HTMLInputElement = event.target as HTMLInputElement;\n    const value: string = element.value;\n    this._valueToValidate = value;\n    this.setState({\n      value: value,\n    });\n  };\n\n  /**\n   * Update the value with the given stepFunction\n   * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n   * when spinning in response to a mouseDown\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  private _updateValue = (\n    shouldSpin: boolean,\n    stepDelay: number,\n    stepFunction: (\n      value: string,\n      event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    ) => string | void,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    const newValue: string | void = stepFunction(this.value || '', event);\n    if (newValue !== undefined) {\n      this._lastValidValue = newValue;\n      this.setState({ value: newValue });\n    }\n\n    if (this._spinningByMouse !== shouldSpin) {\n      this._spinningByMouse = shouldSpin;\n    }\n\n    if (shouldSpin) {\n      this._currentStepFunctionHandle = this._async.setTimeout(() => {\n        this._updateValue(shouldSpin, this._stepDelay, stepFunction, event);\n      }, stepDelay);\n    }\n  };\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  private _stop = (): void => {\n    if (this._currentStepFunctionHandle >= 0) {\n      this._async.clearTimeout(this._currentStepFunctionHandle);\n      this._currentStepFunctionHandle = -1;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._spinningByMouse = false;\n      this.setState({ keyboardSpinDirection: KeyboardSpinDirection.notSpinning });\n    }\n  };\n\n  /**\n   * Handle keydown on the text field. We need to update\n   * the value when up or down arrow are depressed\n   * @param event - the keyboardEvent that was fired\n   */\n  private _handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.props.disabled) {\n      this._stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    switch (event.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n        break;\n      case KeyCodes.enter:\n        this._validate(event);\n        break;\n      case KeyCodes.escape:\n        if (this.value !== this._lastValidValue) {\n          this.setState({ value: this._lastValidValue });\n        }\n        break;\n      default:\n        break;\n    }\n\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (this.state.keyboardSpinDirection !== spinDirection) {\n      this.setState({ keyboardSpinDirection: spinDirection });\n    }\n  };\n\n  /**\n   * Make sure that we have stopped spinning on keyUp\n   * if the up or down arrow fired this event\n   * @param event - keyboard event\n   */\n  private _handleKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n      this._stop();\n      return;\n    }\n  };\n\n  private _onIncrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n  };\n\n  private _onDecrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}