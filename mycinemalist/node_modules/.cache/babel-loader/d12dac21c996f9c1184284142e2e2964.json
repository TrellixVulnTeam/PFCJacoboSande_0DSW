{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, getDocument, focusAsync, initializeComponentRef, on } from '../../Utilities';\n\nvar FocusTrapZone =\n/** @class */\nfunction (_super) {\n  __extends(FocusTrapZone, _super);\n\n  function FocusTrapZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._firstBumper = React.createRef();\n    _this._lastBumper = React.createRef();\n    _this._hasFocus = false;\n\n    _this._onRootFocus = function (ev) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n\n      _this._hasFocus = true;\n    };\n\n    _this._onRootBlur = function (ev) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n\n      var relatedTarget = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = _this._getDocument().activeElement;\n      }\n\n      if (!elementContains(_this._root.current, relatedTarget)) {\n        _this._hasFocus = false;\n      }\n    };\n\n    _this._onFirstBumperFocus = function () {\n      _this._onBumperFocus(true);\n    };\n\n    _this._onLastBumperFocus = function () {\n      _this._onBumperFocus(false);\n    };\n\n    _this._onBumperFocus = function (isFirstBumper) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;\n\n      if (_this._root.current) {\n        var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (_this._isBumper(nextFocusable)) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            _this.focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    };\n\n    _this._onFocusCapture = function (ev) {\n      if (_this.props.onFocusCapture) {\n        _this.props.onFocusCapture(ev);\n      }\n\n      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n\n    _this._forceFocusInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var focusedElement = _this._getDocument().activeElement;\n\n        if (!elementContains(_this._root.current, focusedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    _this._forceClickInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var clickedElement = ev.target;\n\n        if (clickedElement && !elementContains(_this._root.current, clickedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    return _this;\n  }\n\n  FocusTrapZone.prototype.componentDidMount = function () {\n    this._bringFocusIntoZone();\n\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  };\n\n  FocusTrapZone.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;\n\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  };\n\n  FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    var newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  };\n\n  FocusTrapZone.prototype.componentWillUnmount = function () {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (!this.props.disabled || this.props.forceFocusInsideTrap || !elementContains(this._root.current, this._getDocument().activeElement)) {\n      this._returnFocusToInitiator();\n    } // Dispose of event handlers so their closures can be garbage-collected\n\n\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  };\n\n  FocusTrapZone.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        ariaLabelledBy = _a.ariaLabelledBy;\n    var divProps = getNativeProps(this.props, divProperties);\n    var bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed'\n      },\n      tabIndex: disabled ? -1 : 0,\n      'data-is-visible': true\n    };\n    return React.createElement(\"div\", __assign({}, divProps, {\n      className: className,\n      ref: this._root,\n      \"aria-labelledby\": ariaLabelledBy,\n      onFocusCapture: this._onFocusCapture,\n      onFocus: this._onRootFocus,\n      onBlur: this._onRootBlur\n    }), React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._firstBumper,\n      onFocus: this._onFirstBumperFocus\n    })), this.props.children, React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._lastBumper,\n      onFocus: this._onLastBumperFocus\n    })));\n  };\n\n  FocusTrapZone.prototype.focus = function () {\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n        focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement,\n        firstFocusableSelector = _a.firstFocusableSelector,\n        firstFocusableTarget = _a.firstFocusableTarget;\n\n    if (focusPreviouslyFocusedInnerElement && this._previouslyFocusedElementInTrapZone && elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var _firstFocusableChild = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  };\n\n  FocusTrapZone.prototype._focusAsync = function (element) {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  };\n\n  FocusTrapZone.prototype._bringFocusIntoZone = function () {\n    var _a = this.props,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        _c = _a.disableFirstFocus,\n        disableFirstFocus = _c === void 0 ? false : _c;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : this._getDocument().activeElement;\n\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  };\n\n  FocusTrapZone.prototype._returnFocusToInitiator = function () {\n    var _this = this;\n\n    var ignoreExternalFocusing = this.props.ignoreExternalFocusing;\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n      return _this !== value;\n    });\n\n    var doc = this._getDocument();\n\n    var activeElement = doc.activeElement;\n\n    if (!ignoreExternalFocusing && this._previouslyFocusedElementOutsideTrapZone && typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(this._root.current, activeElement) || activeElement === doc.body)) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  };\n\n  FocusTrapZone.prototype._updateEventHandlers = function (newProps) {\n    var _a = newProps.isClickableOutsideFocusTrap,\n        isClickableOutsideFocusTrap = _a === void 0 ? false : _a,\n        _b = newProps.forceFocusInsideTrap,\n        forceFocusInsideTrap = _b === void 0 ? true : _b;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n  };\n\n  FocusTrapZone.prototype._isBumper = function (element) {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  };\n\n  FocusTrapZone.prototype._getDocument = function () {\n    return getDocument(this._root.current);\n  };\n\n  FocusTrapZone._focusStack = [];\n  return FocusTrapZone;\n}(React.Component);\n\nexport { FocusTrapZone };","map":{"version":3,"mappings":"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","names":["React","modalize","elementContains","getNativeProps","divProperties","getFirstTabbable","getLastTabbable","getNextElement","getDocument","focusAsync","initializeComponentRef","on","__extends","props","_super","_this","createRef","ev","onFocus","_hasFocus","onBlur","relatedTarget","_getDocument","activeElement","_root","current","_onBumperFocus","isFirstBumper","disabled","currentBumper","_lastBumper","_firstBumper","nextFocusable","_isBumper","focus","onFocusCapture","target","currentTarget","_previouslyFocusedElementInTrapZone","FocusTrapZone","_focusStack","length","focusedElement","preventDefault","stopPropagation","clickedElement","_bringFocusIntoZone","_updateEventHandlers","enableAriaHiddenSiblings","_unmodalize","nextProps","elementToFocusOnDismiss","_previouslyFocusedElementOutsideTrapZone","prevProps","prevForceFocusInsideTrap","forceFocusInsideTrap","undefined","newForceFocusInsideTrap","prevDisabled","newDisabled","_returnFocusToInitiator","_disposeClickHandler","_disposeFocusHandler","className","_b","ariaLabelledBy","divProps","bumperProps","style","pointerEvents","position","tabIndex","ref","_onFocusCapture","_onRootFocus","_onRootBlur","_onFirstBumperFocus","children","_onLastBumperFocus","focusPreviouslyFocusedInnerElement","firstFocusableSelector","firstFocusableTarget","_focusAsync","focusSelector","_firstFocusableChild","querySelector","firstChild","element","_c","disableFirstFocus","push","filter","value","doc","ignoreExternalFocusing","body","newProps","window","_forceFocusInTrap","isClickableOutsideFocusTrap","_forceClickInTrap","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\FocusTrapZone\\FocusTrapZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  getDocument,\n  focusAsync,\n  initializeComponentRef,\n  on,\n} from '../../Utilities';\nimport { IFocusTrapZone, IFocusTrapZoneProps } from './FocusTrapZone.types';\n\nexport class FocusTrapZone extends React.Component<IFocusTrapZoneProps, {}> implements IFocusTrapZone {\n  private static _focusStack: FocusTrapZone[] = [];\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _firstBumper = React.createRef<HTMLDivElement>();\n  private _lastBumper = React.createRef<HTMLDivElement>();\n  private _hasFocus: boolean = false;\n  private _unmodalize?: () => void;\n\n  private _previouslyFocusedElementOutsideTrapZone: HTMLElement;\n  private _previouslyFocusedElementInTrapZone?: HTMLElement;\n  private _disposeFocusHandler: (() => void) | undefined;\n  private _disposeClickHandler: (() => void) | undefined;\n\n  public constructor(props: IFocusTrapZoneProps) {\n    super(props);\n    initializeComponentRef(this);\n  }\n\n  public componentDidMount(): void {\n    this._bringFocusIntoZone();\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IFocusTrapZoneProps): void {\n    const { elementToFocusOnDismiss } = nextProps;\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  }\n\n  public componentDidUpdate(prevProps: IFocusTrapZoneProps) {\n    const prevForceFocusInsideTrap =\n      prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    const newForceFocusInsideTrap =\n      this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    const prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    const newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (\n      !this.props.disabled ||\n      this.props.forceFocusInsideTrap ||\n      !elementContains(this._root.current, this._getDocument().activeElement as HTMLElement)\n    ) {\n      this._returnFocusToInitiator();\n    }\n\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    }\n\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  }\n\n  public render(): JSX.Element {\n    const { className, disabled = false, ariaLabelledBy } = this.props;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    const bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n      },\n      tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n      'data-is-visible': true,\n    } as React.HTMLAttributes<HTMLDivElement>;\n\n    return (\n      <div\n        {...divProps}\n        className={className}\n        ref={this._root}\n        aria-labelledby={ariaLabelledBy}\n        onFocusCapture={this._onFocusCapture}\n        onFocus={this._onRootFocus}\n        onBlur={this._onRootBlur}\n      >\n        <div {...bumperProps} ref={this._firstBumper} onFocus={this._onFirstBumperFocus} />\n        {this.props.children}\n        <div {...bumperProps} ref={this._lastBumper} onFocus={this._onLastBumperFocus} />\n      </div>\n    );\n  }\n\n  public focus() {\n    // eslint-disable-next-line deprecation/deprecation\n    const { focusPreviouslyFocusedInnerElement, firstFocusableSelector, firstFocusableTarget } = this.props;\n\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      this._previouslyFocusedElementInTrapZone &&\n      elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let _firstFocusableChild: HTMLElement | null = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(\n          this._root.current,\n          this._root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  }\n\n  private _focusAsync(element: HTMLElement): void {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  }\n\n  private _onRootFocus = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n\n    this._hasFocus = true;\n  };\n\n  private _onRootBlur = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = this._getDocument().activeElement as Element;\n    }\n\n    if (!elementContains(this._root.current, relatedTarget as HTMLElement)) {\n      this._hasFocus = false;\n    }\n  };\n\n  private _onFirstBumperFocus = () => {\n    this._onBumperFocus(true);\n  };\n\n  private _onLastBumperFocus = () => {\n    this._onBumperFocus(false);\n  };\n\n  private _onBumperFocus = (isFirstBumper: boolean) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const currentBumper = (isFirstBumper === this._hasFocus\n      ? this._lastBumper.current\n      : this._firstBumper.current) as HTMLElement;\n\n    if (this._root.current) {\n      const nextFocusable =\n        isFirstBumper === this._hasFocus\n          ? getLastTabbable(this._root.current, currentBumper, true, false)\n          : getFirstTabbable(this._root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (this._isBumper(nextFocusable)) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          this.focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  };\n\n  private _bringFocusIntoZone(): void {\n    const { elementToFocusOnDismiss, disabled = false, disableFirstFocus = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n      ? elementToFocusOnDismiss\n      : (this._getDocument().activeElement as HTMLElement);\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  }\n\n  private _returnFocusToInitiator(): void {\n    const { ignoreExternalFocusing } = this.props;\n\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value: FocusTrapZone) => {\n      return this !== value;\n    });\n\n    const doc = this._getDocument();\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !ignoreExternalFocusing &&\n      this._previouslyFocusedElementOutsideTrapZone &&\n      typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n      (elementContains(this._root.current, activeElement) || activeElement === doc.body)\n    ) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  }\n\n  private _updateEventHandlers(newProps: IFocusTrapZoneProps): void {\n    const { isClickableOutsideFocusTrap = false, forceFocusInsideTrap = true } = newProps;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n  }\n\n  private _onFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocusCapture) {\n      this.props.onFocusCapture(ev);\n    }\n\n    if (ev.target !== ev.currentTarget && !this._isBumper(ev.target)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      this._previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  private _isBumper(element: HTMLElement): boolean {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  }\n\n  private _forceFocusInTrap = (ev: FocusEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const focusedElement = this._getDocument().activeElement as HTMLElement;\n\n      if (!elementContains(this._root.current, focusedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _forceClickInTrap = (ev: MouseEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const clickedElement = ev.target as HTMLElement;\n\n      if (clickedElement && !elementContains(this._root.current, clickedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}