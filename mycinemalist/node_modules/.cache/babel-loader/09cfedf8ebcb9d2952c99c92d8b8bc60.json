{"ast":null,"code":"import { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\n\nexport function mergeStyleSets() {\n  var styleSets = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styleSets[_i] = arguments[_i];\n  }\n\n  return mergeCssSets(styleSets, getStyleOptions());\n}\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\n\nexport function mergeCssSets(styleSets, options) {\n  var _a, _b;\n\n  var classNameSet = {\n    subComponentStyles: {}\n  };\n  var styleSet = styleSets[0];\n\n  if (!styleSet && styleSets.length <= 1) {\n    return {\n      subComponentStyles: {}\n    };\n  }\n\n  var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);\n  var registrations = [];\n\n  for (var styleSetArea in concatenatedStyleSet) {\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n      if (styleSetArea === 'subComponentStyles') {\n        classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};\n        continue;\n      }\n\n      var styles = concatenatedStyleSet[styleSetArea];\n\n      var _c = extractStyleParts(styles),\n          classes = _c.classes,\n          objects = _c.objects;\n\n      if ((_a = objects) === null || _a === void 0 ? void 0 : _a.length) {\n        var registration = styleToRegistration(options || {}, {\n          displayName: styleSetArea\n        }, objects);\n\n        if (registration) {\n          registrations.push(registration);\n          classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n        }\n      } else {\n        classNameSet[styleSetArea] = classes.join(' ');\n      }\n    }\n  }\n\n  for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {\n    var registration = registrations_1[_i];\n\n    if (registration) {\n      applyRegistration(registration, (_b = options) === null || _b === void 0 ? void 0 : _b.specificityMultiplier);\n    }\n  }\n\n  return classNameSet;\n}","map":{"version":3,"mappings":"AAAA,SAASA,eAAT,QAAgC,mBAAhC;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AAIA,SAASC,eAAT,QAAgC,qBAAhC;AACA,SAASC,iBAAT,EAA4BC,mBAA5B,QAAuD,oBAAvD;AA2EA;;;;;;;;;AAQA,OAAM,SAAUC,cAAV,GAAwB;EAAC;;OAAA,yCAAyD;IAAzDC;;;EAC7B,OAAOC,YAAY,CAACD,SAAD,EAAmBJ,eAAe,EAAlC,CAAnB;AACD;AAmFD;;;;;;;;;;AASA,OAAM,SAAUK,YAAV,CACJD,SADI,EAEJE,OAFI,EAEmB;;;EAEvB,IAAMC,YAAY,GAA4B;IAAEC,kBAAkB,EAAE;EAAtB,CAA9C;EAEA,IAAMC,QAAQ,GAAGL,SAAS,CAAC,CAAD,CAA1B;;EAEA,IAAI,CAACK,QAAD,IAAaL,SAAS,CAACM,MAAV,IAAoB,CAArC,EAAwC;IACtC,OAAO;MAAEF,kBAAkB,EAAE;IAAtB,CAAP;EACD;;EAED,IAAMG,oBAAoB,GAAGb,eAAe,MAAf,CAAe,MAAf,EAAmBM,SAAnB,CAA7B;EAEA,IAAMQ,aAAa,GAAG,EAAtB;;EAEA,KAAK,IAAMC,YAAX,IAA2BF,oBAA3B,EAAiD;IAC/C,IAAIA,oBAAoB,CAACG,cAArB,CAAoCD,YAApC,CAAJ,EAAuD;MACrD,IAAIA,YAAY,KAAK,oBAArB,EAA2C;QACzCN,YAAY,CAACC,kBAAb,GAAmCG,oBAAmD,CAACH,kBAApD,IAA0E,EAA7G;QACA;MACD;;MAED,IAAMO,MAAM,GAAYJ,oBAA4B,CAACE,YAAD,CAApD;;MAEM;MAAA,IAAEG,oBAAF;MAAA,IAAWC,oBAAX;;MAEN,UAAIA,OAAJ,MAAW,IAAX,IAAWC,aAAX,GAAW,MAAX,GAAWA,GAAER,MAAb,EAAqB;QACnB,IAAMS,YAAY,GAAGjB,mBAAmB,CAACI,OAAO,IAAI,EAAZ,EAAgB;UAAEc,WAAW,EAAEP;QAAf,CAAhB,EAA+CI,OAA/C,CAAxC;;QAEA,IAAIE,YAAJ,EAAkB;UAChBP,aAAa,CAACS,IAAd,CAAmBF,YAAnB;UACAZ,YAAY,CAACM,YAAD,CAAZ,GAA6BG,OAAO,CAACM,MAAR,CAAe,CAACH,YAAY,CAACI,SAAd,CAAf,EAAyCC,IAAzC,CAA8C,GAA9C,CAA7B;QACD;MACF,CAPD,MAOO;QACLjB,YAAY,CAACM,YAAD,CAAZ,GAA6BG,OAAO,CAACQ,IAAR,CAAa,GAAb,CAA7B;MACD;IACF;EACF;;EAED,KAA2B,2CAA3B,EAA2BC,2BAA3B,EAA2BA,IAA3B,EAA0C;IAArC,IAAMN,YAAY,sBAAlB;;IACH,IAAIA,YAAJ,EAAkB;MAChBlB,iBAAiB,CAACkB,YAAD,EAAa,MAAEb,OAAF,MAAS,IAAT,IAASoB,aAAT,GAAS,MAAT,GAASA,GAAEC,qBAAxB,CAAjB;IACD;EACF;;EAED,OAAOpB,YAAP;AACD","names":["concatStyleSets","extractStyleParts","getStyleOptions","applyRegistration","styleToRegistration","mergeStyleSets","styleSets","mergeCssSets","options","classNameSet","subComponentStyles","styleSet","length","concatenatedStyleSet","registrations","styleSetArea","hasOwnProperty","styles","classes","objects","_a","registration","displayName","push","concat","className","join","_i","_b","specificityMultiplier"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\node_modules\\@uifabric\\merge-styles\\src\\mergeStyleSets.ts"],"sourcesContent":["import { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { IStyle } from './IStyle';\nimport { IStyleOptions } from './IStyleOptions';\nimport { IConcatenatedStyleSet, IProcessedStyleSet, IStyleSet } from './IStyleSet';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\nimport { ObjectOnly } from './ObjectOnly';\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet - The first style set to be merged and reigstered.\n */\nexport function mergeStyleSets<TStyleSet>(\n  styleSet: TStyleSet | false | null | undefined,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2>(\n  styleSet1: TStyleSet1 | false | null | undefined,\n  styleSet2: TStyleSet2 | false | null | undefined,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSet1: TStyleSet1 | false | null | undefined,\n  styleSet2: TStyleSet2 | false | null | undefined,\n  styleSet3: TStyleSet3 | false | null | undefined,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n * @param styleSet4 - The fourth style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSet1: TStyleSet1 | false | null | undefined,\n  styleSet2: TStyleSet2 | false | null | undefined,\n  styleSet3: TStyleSet3 | false | null | undefined,\n  styleSet4: TStyleSet4 | false | null | undefined,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(...styleSets: Array<IStyleSet | undefined | false | null>): IProcessedStyleSet<any>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(...styleSets: Array<IStyleSet | undefined | false | null>): IProcessedStyleSet<any> {\n  return mergeCssSets(styleSets as any, getStyleOptions());\n}\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSets: [TStyleSet | false | null | undefined],\n  options?: IStyleOptions,\n): IProcessedStyleSet<TStyleSet>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2>(\n  styleSets: [TStyleSet1 | false | null | undefined, TStyleSet2 | false | null | undefined],\n  options?: IStyleOptions,\n): IProcessedStyleSet<TStyleSet1 & TStyleSet2>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSets: [\n    TStyleSet1 | false | null | undefined,\n    TStyleSet2 | false | null | undefined,\n    TStyleSet3 | false | null | undefined,\n  ],\n  options?: IStyleOptions,\n): IProcessedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSets: [\n    TStyleSet1 | false | null | undefined,\n    TStyleSet2 | false | null | undefined,\n    TStyleSet3 | false | null | undefined,\n    TStyleSet4 | false | null | undefined,\n  ],\n  options?: IStyleOptions,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSet: [TStyleSet | false | null | undefined],\n  options?: IStyleOptions,\n): IProcessedStyleSet<TStyleSet>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(\n  styleSets: Array<IStyleSet | undefined | false | null>,\n  options?: IStyleOptions,\n): IProcessedStyleSet<any> {\n  const classNameSet: IProcessedStyleSet<any> = { subComponentStyles: {} };\n\n  const styleSet = styleSets[0];\n\n  if (!styleSet && styleSets.length <= 1) {\n    return { subComponentStyles: {} } as any;\n  }\n\n  const concatenatedStyleSet = concatStyleSets(...styleSets);\n\n  const registrations = [];\n\n  for (const styleSetArea in concatenatedStyleSet) {\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n      if (styleSetArea === 'subComponentStyles') {\n        classNameSet.subComponentStyles = (concatenatedStyleSet as IConcatenatedStyleSet<any>).subComponentStyles || {};\n        continue;\n      }\n\n      const styles: IStyle = (concatenatedStyleSet as any)[styleSetArea];\n\n      const { classes, objects } = extractStyleParts(styles);\n\n      if (objects?.length) {\n        const registration = styleToRegistration(options || {}, { displayName: styleSetArea }, objects);\n\n        if (registration) {\n          registrations.push(registration);\n          classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n        }\n      } else {\n        classNameSet[styleSetArea] = classes.join(' ');\n      }\n    }\n  }\n\n  for (const registration of registrations) {\n    if (registration) {\n      applyRegistration(registration, options?.specificityMultiplier);\n    }\n  }\n\n  return classNameSet as any;\n}\n"]},"metadata":{},"sourceType":"module"}