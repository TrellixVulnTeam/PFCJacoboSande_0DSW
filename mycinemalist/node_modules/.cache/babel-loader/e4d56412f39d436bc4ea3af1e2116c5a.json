{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction, divProperties, getNativeProps, getRTL, initializeComponentRef } from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nvar getClassNames = classNamesFunction();\n\nvar ScrollablePaneBase =\n/** @class */\nfunction (_super) {\n  __extends(ScrollablePaneBase, _super);\n\n  function ScrollablePaneBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._stickyAboveRef = React.createRef();\n    _this._stickyBelowRef = React.createRef();\n    _this._contentContainer = React.createRef();\n\n    _this.subscribe = function (handler) {\n      _this._subscribers.add(handler);\n    };\n\n    _this.unsubscribe = function (handler) {\n      _this._subscribers.delete(handler);\n    };\n\n    _this.addSticky = function (sticky) {\n      _this._stickies.add(sticky); // If ScrollablePane is mounted, then sort sticky in correct place\n\n\n      if (_this.contentContainer) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n\n        _this.sortSticky(sticky);\n      }\n    };\n\n    _this.removeSticky = function (sticky) {\n      _this._stickies.delete(sticky);\n\n      _this._removeStickyFromContainers(sticky);\n\n      _this.notifySubscribers();\n    };\n\n    _this.sortSticky = function (sticky, sortAgain) {\n      if (_this.stickyAbove && _this.stickyBelow) {\n        if (sortAgain) {\n          _this._removeStickyFromContainers(sticky);\n        }\n\n        if (sticky.canStickyTop && sticky.stickyContentTop) {\n          _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);\n        }\n\n        if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n          _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);\n        }\n      }\n    };\n\n    _this.updateStickyRefHeights = function () {\n      var stickyItems = _this._stickies;\n      var stickyTopHeight = 0;\n      var stickyBottomHeight = 0;\n      stickyItems.forEach(function (sticky) {\n        var _a = sticky.state,\n            isStickyTop = _a.isStickyTop,\n            isStickyBottom = _a.isStickyBottom;\n\n        if (sticky.nonStickyContent) {\n          if (isStickyTop) {\n            stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          if (isStickyBottom) {\n            stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          _this._checkStickyStatus(sticky);\n        }\n      });\n\n      _this.setState({\n        stickyTopHeight: stickyTopHeight,\n        stickyBottomHeight: stickyBottomHeight\n      });\n    };\n\n    _this.notifySubscribers = function () {\n      if (_this.contentContainer) {\n        _this._subscribers.forEach(function (handle) {\n          // this.stickyBelow is passed in for calculating distance to determine Sticky status\n          handle(_this.contentContainer, _this.stickyBelow);\n        });\n      }\n    };\n\n    _this.getScrollPosition = function () {\n      if (_this.contentContainer) {\n        return _this.contentContainer.scrollTop;\n      }\n\n      return 0;\n    };\n\n    _this.syncScrollSticky = function (sticky) {\n      if (sticky && _this.contentContainer) {\n        sticky.syncScroll(_this.contentContainer);\n      }\n    };\n\n    _this._getScrollablePaneContext = function () {\n      return {\n        scrollablePane: {\n          subscribe: _this.subscribe,\n          unsubscribe: _this.unsubscribe,\n          addSticky: _this.addSticky,\n          removeSticky: _this.removeSticky,\n          updateStickyRefHeights: _this.updateStickyRefHeights,\n          sortSticky: _this.sortSticky,\n          notifySubscribers: _this.notifySubscribers,\n          syncScrollSticky: _this.syncScrollSticky\n        }\n      };\n    };\n\n    _this._addToStickyContainer = function (sticky, stickyContainer, stickyContentToAdd) {\n      // If there's no children, append child to list, otherwise, sort though array and append at correct position\n      if (!stickyContainer.children.length) {\n        stickyContainer.appendChild(stickyContentToAdd);\n      } else {\n        // If stickyContentToAdd isn't a child element of target container, then append\n        if (!stickyContainer.contains(stickyContentToAdd)) {\n          var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);\n          var stickyList_1 = []; // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n          // filter by elements that are in the stickyContainer already.\n\n          _this._stickies.forEach(function (stickyItem) {\n            if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {\n              stickyList_1.push(stickyItem);\n            } else if (sticky.canStickyBottom) {\n              stickyList_1.push(stickyItem);\n            }\n          });\n\n          var stickyListSorted = stickyList_1.sort(function (a, b) {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          }).filter(function (item) {\n            var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n\n            if (stickyContent) {\n              return stickyChildrenElements_1.indexOf(stickyContent) > -1;\n            }\n\n            return false;\n          }); // Get first element that has a distance from top that is further than our sticky that is being added\n\n          var targetStickyToAppendBefore = undefined;\n\n          for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {\n            var stickyListItem = stickyListSorted_1[_i];\n\n            if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n              targetStickyToAppendBefore = stickyListItem;\n              break;\n            }\n          } // If target element to append before is known, grab respective stickyContentTop/Bottom element\n          // and insert before\n\n\n          var targetContainer = null;\n\n          if (targetStickyToAppendBefore) {\n            targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;\n          }\n\n          stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n        }\n      }\n    };\n\n    _this._removeStickyFromContainers = function (sticky) {\n      if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {\n        _this.stickyAbove.removeChild(sticky.stickyContentTop);\n      }\n\n      if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {\n        _this.stickyBelow.removeChild(sticky.stickyContentBottom);\n      }\n    };\n\n    _this._onWindowResize = function () {\n      var scrollbarWidth = _this._getScrollbarWidth();\n\n      var scrollbarHeight = _this._getScrollbarHeight();\n\n      _this.setState({\n        scrollbarWidth: scrollbarWidth,\n        scrollbarHeight: scrollbarHeight\n      });\n\n      _this.notifySubscribers();\n    };\n\n    _this._getStickyContainerStyle = function (height, isTop) {\n      return __assign(__assign({\n        height: height\n      }, getRTL(_this.props.theme) ? {\n        right: '0',\n        left: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      } : {\n        left: '0',\n        right: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      }), isTop ? {\n        top: '0'\n      } : {\n        bottom: (_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0) + \"px\"\n      });\n    };\n\n    _this._onScroll = function () {\n      var contentContainer = _this.contentContainer;\n\n      if (contentContainer) {\n        _this._stickies.forEach(function (sticky) {\n          sticky.syncScroll(contentContainer);\n        });\n      }\n\n      _this._notifyThrottled();\n    };\n\n    _this._subscribers = new Set();\n    _this._stickies = new Set();\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0\n    };\n    _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);\n    return _this;\n  }\n\n  Object.defineProperty(ScrollablePaneBase.prototype, \"root\", {\n    get: function get() {\n      return this._root.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyAbove\", {\n    get: function get() {\n      return this._stickyAboveRef.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyBelow\", {\n    get: function get() {\n      return this._stickyBelowRef.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"contentContainer\", {\n    get: function get() {\n      return this._contentContainer.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ScrollablePaneBase.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n\n    this._events.on(window, 'resize', this._onWindowResize);\n\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Set sticky distances from top property, then sort in correct order and notify subscribers\n\n\n    this.setStickiesDistanceFromTop();\n\n    this._stickies.forEach(function (sticky) {\n      _this.sortSticky(sticky);\n    });\n\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(function (mutation) {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord) {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n\n          return false;\n        } // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n\n\n        var scrollbarHeight = _this._getScrollbarHeight(); // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n\n\n        if (scrollbarHeight !== _this.state.scrollbarHeight) {\n          _this.setState({\n            scrollbarHeight: scrollbarHeight\n          });\n        } // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n\n\n        _this.notifySubscribers(); // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n\n\n        if (mutation.some(checkIfMutationIsSticky.bind(_this))) {\n          _this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          var stickyList_2 = [];\n\n          _this._stickies.forEach(function (sticky) {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList_2.push(sticky);\n            }\n          });\n\n          if (stickyList_2.length) {\n            stickyList_2.forEach(function (sticky) {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true\n        });\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }; // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n\n\n  ScrollablePaneBase.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;\n  };\n\n  ScrollablePaneBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n\n\n    if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  };\n\n  ScrollablePaneBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        theme = _a.theme,\n        styles = _a.styles;\n    var _b = this.state,\n        stickyTopHeight = _b.stickyTopHeight,\n        stickyBottomHeight = _b.stickyBottomHeight;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      scrollbarVisibility: this.props.scrollbarVisibility\n    });\n    return React.createElement(\"div\", __assign({}, getNativeProps(this.props, divProperties), {\n      ref: this._root,\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      \"aria-hidden\": \"true\",\n      ref: this._stickyAboveRef,\n      className: classNames.stickyAbove,\n      style: this._getStickyContainerStyle(stickyTopHeight, true)\n    }), React.createElement(\"div\", {\n      ref: this._contentContainer,\n      className: classNames.contentContainer,\n      \"data-is-scrollable\": true\n    }, React.createElement(ScrollablePaneContext.Provider, {\n      value: this._getScrollablePaneContext()\n    }, this.props.children)), React.createElement(\"div\", {\n      \"aria-hidden\": \"true\",\n      className: classNames.stickyBelow,\n      style: this._getStickyContainerStyle(stickyBottomHeight, false)\n    }, React.createElement(\"div\", {\n      ref: this._stickyBelowRef,\n      className: classNames.stickyBelowItems\n    })));\n  };\n\n  ScrollablePaneBase.prototype.setStickiesDistanceFromTop = function () {\n    var _this = this;\n\n    if (this.contentContainer) {\n      this._stickies.forEach(function (sticky) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n      });\n    }\n  };\n\n  ScrollablePaneBase.prototype.forceLayoutUpdate = function () {\n    this._onWindowResize();\n  };\n\n  ScrollablePaneBase.prototype._checkStickyStatus = function (sticky) {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarWidth = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarHeight = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  };\n\n  return ScrollablePaneBase;\n}(React.Component);\n\nexport { ScrollablePaneBase };","map":{"version":3,"mappings":"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","names":["React","Async","EventGroup","classNamesFunction","divProperties","getNativeProps","getRTL","initializeComponentRef","ScrollablePaneContext","getClassNames","__extends","props","_super","_this","createRef","handler","_subscribers","add","delete","sticky","_stickies","contentContainer","setDistanceFromTop","sortSticky","_removeStickyFromContainers","notifySubscribers","sortAgain","stickyAbove","stickyBelow","canStickyTop","stickyContentTop","_addToStickyContainer","canStickyBottom","stickyContentBottom","stickyItems","stickyTopHeight","stickyBottomHeight","forEach","isStickyTop","isStickyBottom","nonStickyContent","offsetHeight","_checkStickyStatus","setState","handle","scrollTop","syncScroll","scrollablePane","subscribe","unsubscribe","addSticky","removeSticky","updateStickyRefHeights","syncScrollSticky","stickyContainer","stickyContentToAdd","children","length","appendChild","contains","stickyChildrenElements_1","slice","call","stickyList_1","push","stickyItem","stickyListSorted","sort","a","b","state","distanceFromTop","filter","stickyContent","item","indexOf","targetStickyToAppendBefore","undefined","_i","stickyListItem","targetContainer","insertBefore","removeChild","scrollbarWidth","_getScrollbarWidth","scrollbarHeight","_getScrollbarHeight","height","isTop","theme","right","left","top","bottom","_notifyThrottled","Set","_async","_events","throttle","Object","ScrollablePaneBase","_root","current","_stickyAboveRef","_stickyBelowRef","_contentContainer","on","_onScroll","window","_onWindowResize","initialScrollPosition","setStickiesDistanceFromTop","_mutationObserver","MutationObserver","checkIfMutationIsSticky","mutationRecord","target","mutation","some","bind","stickyList_2","root","forceUpdate","observe","childList","attributes","subtree","characterData","dispose","disconnect","nextProps","nextState","className","prevProps","prevState","setTimeout","styles","classNames","scrollbarVisibility","ref","style","_getStickyContainerStyle","Provider","value","_getScrollablePaneContext","stickyBelowItems","resetSticky","offsetWidth","clientWidth","clientHeight","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\ScrollablePane\\ScrollablePane.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  classNamesFunction,\n  divProperties,\n  getNativeProps,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport {\n  IScrollablePane,\n  IScrollablePaneContext,\n  IScrollablePaneProps,\n  IScrollablePaneStyleProps,\n  IScrollablePaneStyles,\n  ScrollablePaneContext,\n} from './ScrollablePane.types';\nimport { Sticky } from '../../Sticky';\n\nexport interface IScrollablePaneState {\n  stickyTopHeight: number;\n  stickyBottomHeight: number;\n  scrollbarWidth: number;\n  scrollbarHeight: number;\n}\n\nconst getClassNames = classNamesFunction<IScrollablePaneStyleProps, IScrollablePaneStyles>();\n\nexport class ScrollablePaneBase extends React.Component<IScrollablePaneProps, IScrollablePaneState>\n  implements IScrollablePane {\n  private _root = React.createRef<HTMLDivElement>();\n  private _stickyAboveRef = React.createRef<HTMLDivElement>();\n  private _stickyBelowRef = React.createRef<HTMLDivElement>();\n  private _contentContainer = React.createRef<HTMLDivElement>();\n  private _subscribers: Set<Function>;\n  private _stickies: Set<Sticky>;\n  private _mutationObserver: MutationObserver;\n  private _notifyThrottled: () => void;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IScrollablePaneProps) {\n    super(props);\n    this._subscribers = new Set<Function>();\n    this._stickies = new Set<Sticky>();\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0,\n    };\n\n    this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);\n  }\n\n  public get root(): HTMLDivElement | null {\n    return this._root.current;\n  }\n\n  public get stickyAbove(): HTMLDivElement | null {\n    return this._stickyAboveRef.current;\n  }\n\n  public get stickyBelow(): HTMLDivElement | null {\n    return this._stickyBelowRef.current;\n  }\n\n  public get contentContainer(): HTMLDivElement | null {\n    return this._contentContainer.current;\n  }\n\n  public componentDidMount() {\n    const { initialScrollPosition } = this.props;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(sticky => {\n      this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(mutation => {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord: MutationRecord): boolean {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        const scrollbarHeight = this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== this.state.scrollbarHeight) {\n          this.setState({\n            scrollbarHeight: scrollbarHeight,\n          });\n        }\n\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        this.notifySubscribers();\n\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(this))) {\n          this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          const stickyList: Sticky[] = [];\n          this._stickies.forEach(sticky => {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList.push(sticky);\n            }\n          });\n          if (stickyList.length) {\n            stickyList.forEach(sticky => {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true,\n        });\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.dispose();\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }\n\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  public shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean {\n    return (\n      this.props.children !== nextProps.children ||\n      this.props.initialScrollPosition !== nextProps.initialScrollPosition ||\n      this.props.className !== nextProps.className ||\n      this.state.stickyTopHeight !== nextState.stickyTopHeight ||\n      this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||\n      this.state.scrollbarWidth !== nextState.scrollbarWidth ||\n      this.state.scrollbarHeight !== nextState.scrollbarHeight\n    );\n  }\n\n  public componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState) {\n    const initialScrollPosition = this.props.initialScrollPosition;\n    if (\n      this.contentContainer &&\n      typeof initialScrollPosition === 'number' &&\n      prevProps.initialScrollPosition !== initialScrollPosition\n    ) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (\n      prevState.stickyTopHeight !== this.state.stickyTopHeight ||\n      prevState.stickyBottomHeight !== this.state.stickyBottomHeight\n    ) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  }\n\n  public render(): JSX.Element {\n    const { className, theme, styles } = this.props;\n    const { stickyTopHeight, stickyBottomHeight } = this.state;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      scrollbarVisibility: this.props.scrollbarVisibility,\n    });\n\n    return (\n      <div {...getNativeProps(this.props, divProperties)} ref={this._root} className={classNames.root}>\n        <div\n          aria-hidden=\"true\"\n          ref={this._stickyAboveRef}\n          className={classNames.stickyAbove}\n          style={this._getStickyContainerStyle(stickyTopHeight, true)}\n        />\n        <div ref={this._contentContainer} className={classNames.contentContainer} data-is-scrollable={true}>\n          <ScrollablePaneContext.Provider value={this._getScrollablePaneContext()}>\n            {this.props.children}\n          </ScrollablePaneContext.Provider>\n        </div>\n        <div\n          aria-hidden=\"true\"\n          className={classNames.stickyBelow}\n          style={this._getStickyContainerStyle(stickyBottomHeight, false)}\n        >\n          <div ref={this._stickyBelowRef} className={classNames.stickyBelowItems} />\n        </div>\n      </div>\n    );\n  }\n\n  public setStickiesDistanceFromTop(): void {\n    if (this.contentContainer) {\n      this._stickies.forEach(sticky => {\n        sticky.setDistanceFromTop(this.contentContainer as HTMLDivElement);\n      });\n    }\n  }\n\n  public forceLayoutUpdate() {\n    this._onWindowResize();\n  }\n\n  public subscribe = (handler: Function): void => {\n    this._subscribers.add(handler);\n  };\n\n  public unsubscribe = (handler: Function): void => {\n    this._subscribers.delete(handler);\n  };\n\n  public addSticky = (sticky: Sticky): void => {\n    this._stickies.add(sticky);\n\n    // If ScrollablePane is mounted, then sort sticky in correct place\n    if (this.contentContainer) {\n      sticky.setDistanceFromTop(this.contentContainer);\n      this.sortSticky(sticky);\n    }\n  };\n\n  public removeSticky = (sticky: Sticky): void => {\n    this._stickies.delete(sticky);\n    this._removeStickyFromContainers(sticky);\n    this.notifySubscribers();\n  };\n\n  public sortSticky = (sticky: Sticky, sortAgain?: boolean): void => {\n    if (this.stickyAbove && this.stickyBelow) {\n      if (sortAgain) {\n        this._removeStickyFromContainers(sticky);\n      }\n      if (sticky.canStickyTop && sticky.stickyContentTop) {\n        this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);\n      }\n\n      if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n        this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);\n      }\n    }\n  };\n\n  public updateStickyRefHeights = (): void => {\n    const stickyItems = this._stickies;\n\n    let stickyTopHeight = 0;\n    let stickyBottomHeight = 0;\n\n    stickyItems.forEach((sticky: Sticky) => {\n      const { isStickyTop, isStickyBottom } = sticky.state;\n      if (sticky.nonStickyContent) {\n        if (isStickyTop) {\n          stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        if (isStickyBottom) {\n          stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        this._checkStickyStatus(sticky);\n      }\n    });\n\n    this.setState({\n      stickyTopHeight: stickyTopHeight,\n      stickyBottomHeight: stickyBottomHeight,\n    });\n  };\n\n  public notifySubscribers = (): void => {\n    if (this.contentContainer) {\n      this._subscribers.forEach(handle => {\n        // this.stickyBelow is passed in for calculating distance to determine Sticky status\n        handle(this.contentContainer, this.stickyBelow);\n      });\n    }\n  };\n\n  public getScrollPosition = (): number => {\n    if (this.contentContainer) {\n      return this.contentContainer.scrollTop;\n    }\n\n    return 0;\n  };\n\n  public syncScrollSticky = (sticky: Sticky): void => {\n    if (sticky && this.contentContainer) {\n      sticky.syncScroll(this.contentContainer);\n    }\n  };\n\n  private _getScrollablePaneContext = (): IScrollablePaneContext => {\n    return {\n      scrollablePane: {\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        addSticky: this.addSticky,\n        removeSticky: this.removeSticky,\n        updateStickyRefHeights: this.updateStickyRefHeights,\n        sortSticky: this.sortSticky,\n        notifySubscribers: this.notifySubscribers,\n        syncScrollSticky: this.syncScrollSticky,\n      },\n    };\n  };\n\n  private _checkStickyStatus(sticky: Sticky): void {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (\n          sticky.state.isStickyTop &&\n          !this.stickyAbove.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentTop\n        ) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (\n          sticky.state.isStickyBottom &&\n          !this.stickyBelow.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentBottom\n        ) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  }\n\n  private _addToStickyContainer = (\n    sticky: Sticky,\n    stickyContainer: HTMLDivElement,\n    stickyContentToAdd: HTMLDivElement,\n  ): void => {\n    // If there's no children, append child to list, otherwise, sort though array and append at correct position\n    if (!stickyContainer.children.length) {\n      stickyContainer.appendChild(stickyContentToAdd);\n    } else {\n      // If stickyContentToAdd isn't a child element of target container, then append\n      if (!stickyContainer.contains(stickyContentToAdd)) {\n        const stickyChildrenElements: Element[] = [].slice.call(stickyContainer.children);\n\n        const stickyList: Sticky[] = [];\n        // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n        // filter by elements that are in the stickyContainer already.\n        this._stickies.forEach(stickyItem => {\n          if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {\n            stickyList.push(stickyItem);\n          } else if (sticky.canStickyBottom) {\n            stickyList.push(stickyItem);\n          }\n        });\n\n        const stickyListSorted = stickyList\n          .sort((a, b) => {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          })\n          .filter(item => {\n            const stickyContent =\n              stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n\n        // Get first element that has a distance from top that is further than our sticky that is being added\n        let targetStickyToAppendBefore: Sticky | undefined = undefined;\n        for (const stickyListItem of stickyListSorted) {\n          if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n            targetStickyToAppendBefore = stickyListItem;\n            break;\n          }\n        }\n\n        // If target element to append before is known, grab respective stickyContentTop/Bottom element\n        // and insert before\n        let targetContainer: HTMLDivElement | null = null;\n        if (targetStickyToAppendBefore) {\n          targetContainer =\n            stickyContainer === this.stickyAbove\n              ? targetStickyToAppendBefore.stickyContentTop\n              : targetStickyToAppendBefore.stickyContentBottom;\n        }\n        stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n      }\n    }\n  };\n\n  private _removeStickyFromContainers = (sticky: Sticky): void => {\n    if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {\n      this.stickyAbove.removeChild(sticky.stickyContentTop);\n    }\n    if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {\n      this.stickyBelow.removeChild(sticky.stickyContentBottom);\n    }\n  };\n\n  private _onWindowResize = (): void => {\n    const scrollbarWidth = this._getScrollbarWidth();\n    const scrollbarHeight = this._getScrollbarHeight();\n\n    this.setState({\n      scrollbarWidth,\n      scrollbarHeight,\n    });\n\n    this.notifySubscribers();\n  };\n\n  private _getStickyContainerStyle = (height: number, isTop: boolean): React.CSSProperties => {\n    return {\n      height: height,\n      ...(getRTL(this.props.theme)\n        ? {\n            right: '0',\n            left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }\n        : {\n            left: '0',\n            right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }),\n      ...(isTop\n        ? {\n            top: '0',\n          }\n        : {\n            bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`,\n          }),\n    };\n  };\n\n  private _getScrollbarWidth(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  }\n\n  private _getScrollbarHeight(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  }\n\n  private _onScroll = () => {\n    const { contentContainer } = this;\n\n    if (contentContainer) {\n      this._stickies.forEach((sticky: Sticky) => {\n        sticky.syncScroll(contentContainer);\n      });\n    }\n\n    this._notifyThrottled();\n  };\n}\n"]},"metadata":{},"sourceType":"module"}