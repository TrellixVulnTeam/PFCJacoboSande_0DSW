{"ast":null,"code":"/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare(a, b) {\n  for (var propName in a) {\n    if (a.hasOwnProperty(propName)) {\n      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n\n  for (var propName in b) {\n    if (b.hasOwnProperty(propName)) {\n      if (!a.hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function assign(target) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function filteredAssign(isAllowed, target) {\n  var args = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    args[_i - 2] = arguments[_i];\n  }\n\n  target = target || {};\n\n  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n    var sourceObject = args_1[_a];\n\n    if (sourceObject) {\n      for (var propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\n\nexport function mapEnumByName( // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntheEnum, callback) {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum).map(function (p) {\n    // map on each property name as a string\n    if (String(Number(p)) !== p) {\n      // if the property is not just a number (because enums in TypeScript will map both ways)\n      return callback(p, theEnum[p]);\n    }\n\n    return undefined;\n  }).filter(function (v) {\n    return !!v;\n  }); // only return elements with values\n}\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function values(obj) {\n  return Object.keys(obj).reduce(function (arr, key) {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function omit(obj, exclusions) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var result = {};\n\n  for (var key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["shallowCompare","a","b","propName","hasOwnProperty","assign","target","args","filteredAssign","apply","concat","isAllowed","_a","sourceObject","mapEnumByName","theEnum","callback","Object","keys","map","p","String","Number","undefined","filter","v","values","obj","reduce","arr","key","push","omit","exclusions","result","indexOf"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\node_modules\\@uifabric\\utilities\\src\\object.ts"],"sourcesContent":["/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare<TA extends any, TB extends any>(a: TA, b: TB): boolean {\n  for (let propName in a) {\n    if (a.hasOwnProperty(propName)) {\n      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n  for (let propName in b) {\n    if (b.hasOwnProperty(propName)) {\n      if (!a.hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assign(target: any, ...args: any[]): any {\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function filteredAssign(isAllowed: (propName: string) => boolean, target: any, ...args: any[]): any {\n  target = target || {};\n\n  for (let sourceObject of args) {\n    if (sourceObject) {\n      for (let propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\nexport function mapEnumByName<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  theEnum: any,\n  callback: (name?: string, value?: string | number) => T | undefined,\n): (T | undefined)[] | undefined {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum)\n    .map<T | undefined>((p: string | number) => {\n      // map on each property name as a string\n      if (String(Number(p)) !== p) {\n        // if the property is not just a number (because enums in TypeScript will map both ways)\n        return callback(p as string, theEnum[p]);\n      }\n      return undefined;\n    })\n    .filter((v: T | undefined) => !!v); // only return elements with values\n}\n\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function values<T>(obj: any): T[] {\n  return Object.keys(obj).reduce((arr: T[], key: string): T[] => {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function omit<TObj extends Record<string, any>>(obj: TObj, exclusions: (keyof TObj)[]): TObj {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {};\n\n  for (const key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result as TObj;\n}\n"]},"metadata":{},"sourceType":"module"}