{"ast":null,"code":"import { warn } from './warn';\nimport { isControlled as checkIsControlled } from '../controlled';\nvar warningsMap;\n\nif (process.env.NODE_ENV !== 'production') {\n  warningsMap = {\n    valueOnChange: {},\n    valueDefaultValue: {},\n    controlledToUncontrolled: {},\n    uncontrolledToControlled: {}\n  };\n}\n/** Reset controlled usage warnings for testing purposes. */\n\n\nexport function resetControlledWarnings() {\n  if (process.env.NODE_ENV !== 'production') {\n    warningsMap.valueOnChange = {};\n    warningsMap.valueDefaultValue = {};\n    warningsMap.controlledToUncontrolled = {};\n    warningsMap.uncontrolledToControlled = {};\n  }\n}\n/**\n * Check for and warn on the following error conditions with a form component:\n * - A value prop is provided (indicated it's being used as controlled) without a change handler,\n *    and the component is not read-only\n * - Both the value and defaultValue props are provided\n * - The component is attempting to switch between controlled and uncontrolled\n *\n * The messages mimic the warnings React gives for these error conditions on input elements.\n * The warning will only be displayed once per component ID.\n */\n\nexport function warnControlledUsage(params) {\n  if (process.env.NODE_ENV !== 'production') {\n    var componentId = params.componentId,\n        componentName = params.componentName,\n        defaultValueProp = params.defaultValueProp,\n        props = params.props,\n        oldProps = params.oldProps,\n        onChangeProp = params.onChangeProp,\n        readOnlyProp = params.readOnlyProp,\n        valueProp = params.valueProp; // This warning logic closely follows what React does for native <input> elements.\n\n    var oldIsControlled = oldProps ? checkIsControlled(oldProps, valueProp) : undefined;\n    var newIsControlled = checkIsControlled(props, valueProp);\n\n    if (newIsControlled) {\n      // onChange (or readOnly) must be provided if value is provided\n      var hasOnChange = !!props[onChangeProp];\n      var isReadOnly = !!(readOnlyProp && props[readOnlyProp]);\n\n      if (!(hasOnChange || isReadOnly) && !warningsMap.valueOnChange[componentId]) {\n        warningsMap.valueOnChange[componentId] = true;\n        warn(\"Warning: You provided a '\" + valueProp + \"' prop to a \" + componentName + \" without an '\" + onChangeProp + \"' handler. \" + (\"This will render a read-only field. If the field should be mutable use '\" + defaultValueProp + \"'. \") + (\"Otherwise, set '\" + onChangeProp + \"'\" + (readOnlyProp ? \" or '\" + readOnlyProp + \"'\" : '') + \".\"));\n      } // value and defaultValue are mutually exclusive\n\n\n      var defaultValue = props[defaultValueProp];\n\n      if (defaultValue !== undefined && defaultValue !== null && !warningsMap.valueDefaultValue[componentId]) {\n        warningsMap.valueDefaultValue[componentId] = true;\n        warn(\"Warning: You provided both '\" + valueProp + \"' and '\" + defaultValueProp + \"' to a \" + componentName + \". \" + (\"Form fields must be either controlled or uncontrolled (specify either the '\" + valueProp + \"' prop, \") + (\"or the '\" + defaultValueProp + \"' prop, but not both). Decide between using a controlled or uncontrolled \") + (componentName + \" and remove one of these props. More info: https://fb.me/react-controlled-components\"));\n      }\n    } // Warn if switching between uncontrolled and controlled. (One difference between this implementation\n    // and React's <input> is that if oldIsControlled is indeterminate and newIsControlled true, we don't warn.)\n\n\n    if (oldProps && newIsControlled !== oldIsControlled) {\n      var oldType = oldIsControlled ? 'a controlled' : 'an uncontrolled';\n      var newType = oldIsControlled ? 'uncontrolled' : 'controlled';\n      var warnMap = oldIsControlled ? warningsMap.controlledToUncontrolled : warningsMap.uncontrolledToControlled;\n\n      if (!warnMap[componentId]) {\n        warnMap[componentId] = true;\n        warn(\"Warning: A component is changing \" + oldType + \" \" + componentName + \" to be \" + newType + \". \" + (componentName + \"s should not switch from controlled to uncontrolled (or vice versa). \") + \"Decide between using controlled or uncontrolled for the lifetime of the component. \" + \"More info: https://fb.me/react-controlled-components\");\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["warn","isControlled","checkIsControlled","warningsMap","process","env","NODE_ENV","valueOnChange","valueDefaultValue","controlledToUncontrolled","uncontrolledToControlled","resetControlledWarnings","warnControlledUsage","params","componentName","defaultValueProp","props","oldProps","onChangeProp","readOnlyProp","valueProp","oldIsControlled","undefined","newIsControlled","hasOnChange","isReadOnly","componentId","defaultValue","oldType","newType","warnMap"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\lib\\src\\warn\\warnControlledUsage.ts"],"sourcesContent":["import { warn } from './warn';\nimport { isControlled as checkIsControlled } from '../controlled';\n\ntype WarningMap = { [id: string]: boolean };\n\nlet warningsMap: {\n  valueOnChange: WarningMap;\n  valueDefaultValue: WarningMap;\n  controlledToUncontrolled: WarningMap;\n  uncontrolledToControlled: WarningMap;\n};\nif (process.env.NODE_ENV !== 'production') {\n  warningsMap = {\n    valueOnChange: {},\n    valueDefaultValue: {},\n    controlledToUncontrolled: {},\n    uncontrolledToControlled: {},\n  };\n}\n\n/** Reset controlled usage warnings for testing purposes. */\nexport function resetControlledWarnings(): void {\n  if (process.env.NODE_ENV !== 'production') {\n    warningsMap.valueOnChange = {};\n    warningsMap.valueDefaultValue = {};\n    warningsMap.controlledToUncontrolled = {};\n    warningsMap.uncontrolledToControlled = {};\n  }\n}\n\nexport interface IWarnControlledUsageParams<P> {\n  /** ID of the component instance. Used to prevent showing warnings repeatedly. */\n  componentId: string;\n  /** Name of the component class. */\n  componentName: string;\n  /** Current props to evaluate. */\n  props: P;\n  /** Previous props to evaluate (undefined if called in the constructor). */\n  oldProps?: P;\n  /** Name of the prop for the controlled value. */\n  valueProp: keyof P;\n  /** Name of the prop for the uncontrolled initial value. */\n  defaultValueProp: keyof P;\n  /** Name of the change handler prop. */\n  onChangeProp: keyof P;\n  /** Name of the read-only prop. */\n  readOnlyProp?: keyof P;\n}\n\n/**\n * Check for and warn on the following error conditions with a form component:\n * - A value prop is provided (indicated it's being used as controlled) without a change handler,\n *    and the component is not read-only\n * - Both the value and defaultValue props are provided\n * - The component is attempting to switch between controlled and uncontrolled\n *\n * The messages mimic the warnings React gives for these error conditions on input elements.\n * The warning will only be displayed once per component ID.\n */\nexport function warnControlledUsage<P>(params: IWarnControlledUsageParams<P>): void {\n  if (process.env.NODE_ENV !== 'production') {\n    const {\n      componentId,\n      componentName,\n      defaultValueProp,\n      props,\n      oldProps,\n      onChangeProp,\n      readOnlyProp,\n      valueProp,\n    } = params;\n\n    // This warning logic closely follows what React does for native <input> elements.\n\n    const oldIsControlled = oldProps ? checkIsControlled(oldProps, valueProp) : undefined;\n    const newIsControlled = checkIsControlled(props, valueProp);\n\n    if (newIsControlled) {\n      // onChange (or readOnly) must be provided if value is provided\n      const hasOnChange = !!props[onChangeProp];\n      const isReadOnly = !!(readOnlyProp && props[readOnlyProp]);\n      if (!(hasOnChange || isReadOnly) && !warningsMap.valueOnChange[componentId]) {\n        warningsMap.valueOnChange[componentId] = true;\n        warn(\n          `Warning: You provided a '${valueProp}' prop to a ${componentName} without an '${onChangeProp}' handler. ` +\n            `This will render a read-only field. If the field should be mutable use '${defaultValueProp}'. ` +\n            `Otherwise, set '${onChangeProp}'${readOnlyProp ? ` or '${readOnlyProp}'` : ''}.`,\n        );\n      }\n\n      // value and defaultValue are mutually exclusive\n      const defaultValue = props[defaultValueProp];\n      if (defaultValue !== undefined && defaultValue !== null && !warningsMap.valueDefaultValue[componentId]) {\n        warningsMap.valueDefaultValue[componentId] = true;\n        warn(\n          `Warning: You provided both '${valueProp}' and '${defaultValueProp}' to a ${componentName}. ` +\n            `Form fields must be either controlled or uncontrolled (specify either the '${valueProp}' prop, ` +\n            `or the '${defaultValueProp}' prop, but not both). Decide between using a controlled or uncontrolled ` +\n            `${componentName} and remove one of these props. More info: https://fb.me/react-controlled-components`,\n        );\n      }\n    }\n\n    // Warn if switching between uncontrolled and controlled. (One difference between this implementation\n    // and React's <input> is that if oldIsControlled is indeterminate and newIsControlled true, we don't warn.)\n    if (oldProps && newIsControlled !== oldIsControlled) {\n      const oldType = oldIsControlled ? 'a controlled' : 'an uncontrolled';\n      const newType = oldIsControlled ? 'uncontrolled' : 'controlled';\n      const warnMap = oldIsControlled ? warningsMap.controlledToUncontrolled : warningsMap.uncontrolledToControlled;\n      if (!warnMap[componentId]) {\n        warnMap[componentId] = true;\n        warn(\n          `Warning: A component is changing ${oldType} ${componentName} to be ${newType}. ` +\n            `${componentName}s should not switch from controlled to uncontrolled (or vice versa). ` +\n            `Decide between using controlled or uncontrolled for the lifetime of the component. ` +\n            `More info: https://fb.me/react-controlled-components`,\n        );\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}