{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { FocusZone, FocusZoneDirection } from '@fluentui/react-focus';\nimport { initializeComponentRef, classNamesFunction, divProperties, elementContains, focusFirstChild, getNativeProps, warnMutuallyExclusive } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'OverflowSet';\n\nvar OverflowSetBase =\n/** @class */\nfunction (_super) {\n  __extends(OverflowSetBase, _super);\n\n  function OverflowSetBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._focusZone = React.createRef();\n    _this._persistedKeytips = {};\n    _this._keytipManager = KeytipManager.getInstance();\n    _this._divContainer = React.createRef();\n\n    _this._onRenderItems = function (items) {\n      return items.map(function (item, i) {\n        return React.createElement(\"div\", {\n          key: item.key,\n          className: _this._classNames.item\n        }, _this.props.onRenderItem(item));\n      });\n    };\n\n    _this._onRenderOverflowButtonWrapper = function (items) {\n      var wrapperDivProps = {\n        className: _this._classNames.overflowButton\n      };\n      var overflowKeytipSequences = _this.props.keytipSequences;\n      var newOverflowItems = [];\n\n      if (overflowKeytipSequences) {\n        items.forEach(function (overflowItem) {\n          var keytip = overflowItem.keytipProps;\n\n          if (keytip) {\n            // Create persisted keytip\n            var persistedKeytip = {\n              content: keytip.content,\n              keySequences: keytip.keySequences,\n              disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n              hasDynamicChildren: keytip.hasDynamicChildren,\n              hasMenu: keytip.hasMenu\n            };\n\n            if (keytip.hasDynamicChildren || _this._getSubMenuForItem(overflowItem)) {\n              // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n              persistedKeytip.onExecute = _this._keytipManager.menuExecute.bind(_this._keytipManager, overflowKeytipSequences, overflowItem.keytipProps.keySequences);\n            } else {\n              // If the keytip doesn't have a submenu, just execute the original function\n              persistedKeytip.onExecute = keytip.onExecute;\n            } // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n            // uniqueID will get updated on register\n\n\n            _this._persistedKeytips[persistedKeytip.content] = persistedKeytip; // Add the overflow sequence to this item\n\n            var newOverflowItem = __assign(__assign({}, overflowItem), {\n              keytipProps: __assign(__assign({}, keytip), {\n                overflowSetSequence: overflowKeytipSequences\n              })\n            });\n\n            newOverflowItems.push(newOverflowItem);\n          } else {\n            // Nothing to change, add overflowItem to list\n            newOverflowItems.push(overflowItem);\n          }\n        });\n      } else {\n        newOverflowItems = items;\n      }\n\n      return React.createElement(\"div\", __assign({}, wrapperDivProps), _this.props.onRenderOverflowButton(newOverflowItems));\n    };\n\n    initializeComponentRef(_this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      doNotContainWithinFocusZone: 'focusZoneProps'\n    });\n    return _this;\n  }\n\n  OverflowSetBase.prototype.render = function () {\n    var _a = this.props,\n        items = _a.items,\n        overflowItems = _a.overflowItems,\n        className = _a.className,\n        // eslint-disable-next-line deprecation/deprecation\n    focusZoneProps = _a.focusZoneProps,\n        styles = _a.styles,\n        vertical = _a.vertical,\n        // eslint-disable-next-line deprecation/deprecation\n    doNotContainWithinFocusZone = _a.doNotContainWithinFocusZone,\n        role = _a.role,\n        _b = _a.overflowSide,\n        overflowSide = _b === void 0 ? 'end' : _b;\n    this._classNames = getClassNames(styles, {\n      className: className,\n      vertical: vertical\n    });\n    var Tag;\n    var uniqueComponentProps;\n\n    if (doNotContainWithinFocusZone) {\n      Tag = 'div';\n      uniqueComponentProps = __assign(__assign({}, getNativeProps(this.props, divProperties)), {\n        ref: this._divContainer\n      });\n    } else {\n      Tag = FocusZone;\n      uniqueComponentProps = __assign(__assign(__assign({}, getNativeProps(this.props, divProperties)), focusZoneProps), {\n        componentRef: this._focusZone,\n        direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal\n      });\n    }\n\n    var showOverflow = overflowItems && overflowItems.length > 0;\n    return React.createElement(Tag, __assign({\n      role: role || 'group',\n      \"aria-orientation\": role === 'menubar' ? vertical === true ? 'vertical' : 'horizontal' : undefined\n    }, uniqueComponentProps, {\n      className: this._classNames.root\n    }), overflowSide === 'start' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems), items && this._onRenderItems(items), overflowSide === 'end' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems));\n  };\n  /**\n   * Sets focus to the first tabbable item in the OverflowSet.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element,\n   * even if focus is already in theOverflowSet\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  OverflowSetBase.prototype.focus = function (forceIntoFirstElement) {\n    var focusSucceeded = false; // eslint-disable-next-line deprecation/deprecation\n\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current) {\n        focusSucceeded = focusFirstChild(this._divContainer.current);\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);\n    }\n\n    return focusSucceeded;\n  };\n  /**\n   * Sets focus to a specific child element within the OverflowSet.\n   * @param childElement - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  OverflowSetBase.prototype.focusElement = function (childElement) {\n    var focusSucceeded = false;\n\n    if (!childElement) {\n      return false;\n    } // eslint-disable-next-line deprecation/deprecation\n\n\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {\n        childElement.focus();\n        focusSucceeded = document.activeElement === childElement;\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focusElement(childElement);\n    }\n\n    return focusSucceeded;\n  }; // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips\n\n\n  OverflowSetBase.prototype.componentDidMount = function () {\n    this._registerPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype.componentWillUnmount = function () {\n    this._unregisterPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype.UNSAFE_componentWillUpdate = function () {\n    this._unregisterPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype.componentDidUpdate = function () {\n    this._registerPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype._registerPersistedKeytips = function () {\n    var _this = this;\n\n    Object.keys(this._persistedKeytips).forEach(function (key) {\n      var keytip = _this._persistedKeytips[key];\n\n      var uniqueID = _this._keytipManager.register(keytip, true); // Update map\n\n\n      _this._persistedKeytips[uniqueID] = keytip;\n      delete _this._persistedKeytips[key];\n    });\n  };\n\n  OverflowSetBase.prototype._unregisterPersistedKeytips = function () {\n    var _this = this; // Delete all persisted keytips saved\n\n\n    Object.keys(this._persistedKeytips).forEach(function (uniqueID) {\n      _this._keytipManager.unregister(_this._persistedKeytips[uniqueID], uniqueID, true);\n    });\n    this._persistedKeytips = {};\n  };\n  /**\n   * Gets the subMenu for an overflow item\n   * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n   */\n\n\n  OverflowSetBase.prototype._getSubMenuForItem = function (item) {\n    if (this.props.itemSubMenuProvider) {\n      return this.props.itemSubMenuProvider(item);\n    }\n\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n\n    return undefined;\n  };\n\n  return OverflowSetBase;\n}(React.Component);\n\nexport { OverflowSetBase };","map":{"version":3,"mappings":"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","names":["React","FocusZone","FocusZoneDirection","initializeComponentRef","classNamesFunction","divProperties","elementContains","focusFirstChild","getNativeProps","warnMutuallyExclusive","KeytipManager","getClassNames","COMPONENT_NAME","__extends","props","_super","_this","createRef","getInstance","items","map","item","i","key","className","_classNames","onRenderItem","wrapperDivProps","overflowButton","overflowKeytipSequences","keytipSequences","newOverflowItems","forEach","keytip","overflowItem","keytipProps","persistedKeytip","content","keySequences","disabled","isDisabled","hasDynamicChildren","hasMenu","_getSubMenuForItem","onExecute","_keytipManager","menuExecute","bind","_persistedKeytips","newOverflowItem","overflowSetSequence","push","onRenderOverflowButton","doNotContainWithinFocusZone","OverflowSetBase","overflowItems","focusZoneProps","styles","vertical","role","_b","overflowSide","Tag","uniqueComponentProps","ref","_divContainer","componentRef","_focusZone","direction","horizontal","showOverflow","length","__assign","undefined","root","_onRenderOverflowButtonWrapper","_onRenderItems","forceIntoFirstElement","focusSucceeded","current","focus","childElement","document","activeElement","focusElement","_registerPersistedKeytips","_unregisterPersistedKeytips","Object","keys","uniqueID","register","unregister","itemSubMenuProvider","subMenuProps","Component"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\OverflowSet\\OverflowSet.base.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport { FocusZone, FocusZoneDirection, IFocusZone } from '@fluentui/react-focus';\nimport { IKeytipProps } from '../../Keytip';\nimport {\n  initializeComponentRef,\n  classNamesFunction,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getNativeProps,\n  warnMutuallyExclusive,\n} from '../../Utilities';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport {\n  IOverflowSet,\n  IOverflowSetItemProps,\n  IOverflowSetProps,\n  IOverflowSetStyles,\n  IOverflowSetStyleProps,\n} from './OverflowSet.types';\n\nconst getClassNames = classNamesFunction<IOverflowSetStyleProps, IOverflowSetStyles>();\nconst COMPONENT_NAME = 'OverflowSet';\n\nexport class OverflowSetBase extends React.Component<IOverflowSetProps, {}> implements IOverflowSet {\n  private _focusZone = React.createRef<IFocusZone>();\n  private _persistedKeytips: { [uniqueID: string]: IKeytipProps } = {};\n  private _keytipManager: KeytipManager = KeytipManager.getInstance();\n  private _divContainer = React.createRef<HTMLDivElement>();\n  private _classNames: IProcessedStyleSet<IOverflowSetStyles>;\n\n  constructor(props: IOverflowSetProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      doNotContainWithinFocusZone: 'focusZoneProps',\n    });\n  }\n\n  public render(): JSX.Element {\n    const {\n      items,\n      overflowItems,\n      className,\n      // eslint-disable-next-line deprecation/deprecation\n      focusZoneProps,\n      styles,\n      vertical,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotContainWithinFocusZone,\n      role,\n      overflowSide = 'end',\n    } = this.props;\n\n    this._classNames = getClassNames(styles, { className, vertical });\n\n    let Tag;\n    let uniqueComponentProps;\n\n    if (doNotContainWithinFocusZone) {\n      Tag = 'div';\n      uniqueComponentProps = {\n        ...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties),\n        ref: this._divContainer,\n      };\n    } else {\n      Tag = FocusZone;\n      uniqueComponentProps = {\n        ...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties),\n        ...focusZoneProps,\n        componentRef: this._focusZone,\n        direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal,\n      };\n    }\n\n    const showOverflow = overflowItems && overflowItems.length > 0;\n\n    return (\n      <Tag\n        role={role || 'group'}\n        aria-orientation={role === 'menubar' ? (vertical === true ? 'vertical' : 'horizontal') : undefined}\n        {...uniqueComponentProps}\n        className={this._classNames.root}\n      >\n        {overflowSide === 'start' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems!)}\n        {items && this._onRenderItems(items)}\n        {overflowSide === 'end' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems!)}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the OverflowSet.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element,\n   * even if focus is already in theOverflowSet\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement?: boolean): boolean {\n    let focusSucceeded = false;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current) {\n        focusSucceeded = focusFirstChild(this._divContainer.current);\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);\n    }\n\n    return focusSucceeded;\n  }\n\n  /**\n   * Sets focus to a specific child element within the OverflowSet.\n   * @param childElement - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(childElement?: HTMLElement): boolean {\n    let focusSucceeded = false;\n\n    if (!childElement) {\n      return false;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {\n        childElement.focus();\n        focusSucceeded = document.activeElement === childElement;\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focusElement(childElement);\n    }\n\n    return focusSucceeded;\n  }\n\n  // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips\n  public componentDidMount() {\n    this._registerPersistedKeytips();\n  }\n\n  public componentWillUnmount() {\n    this._unregisterPersistedKeytips();\n  }\n\n  public UNSAFE_componentWillUpdate() {\n    this._unregisterPersistedKeytips();\n  }\n\n  public componentDidUpdate() {\n    this._registerPersistedKeytips();\n  }\n\n  private _registerPersistedKeytips() {\n    Object.keys(this._persistedKeytips).forEach((key: string) => {\n      const keytip = this._persistedKeytips[key];\n      const uniqueID = this._keytipManager.register(keytip, true);\n      // Update map\n      this._persistedKeytips[uniqueID] = keytip;\n      delete this._persistedKeytips[key];\n    });\n  }\n\n  private _unregisterPersistedKeytips() {\n    // Delete all persisted keytips saved\n    Object.keys(this._persistedKeytips).forEach((uniqueID: string) => {\n      this._keytipManager.unregister(this._persistedKeytips[uniqueID], uniqueID, true);\n    });\n    this._persistedKeytips = {};\n  }\n\n  private _onRenderItems = (items: IOverflowSetItemProps[]): JSX.Element[] => {\n    return items.map((item, i) => {\n      return (\n        <div key={item.key} className={this._classNames.item}>\n          {this.props.onRenderItem(item)}\n        </div>\n      );\n    });\n  };\n\n  private _onRenderOverflowButtonWrapper = (items: any[]): JSX.Element => {\n    const wrapperDivProps: React.HTMLProps<HTMLDivElement> = {\n      className: this._classNames.overflowButton,\n    };\n\n    const overflowKeytipSequences = this.props.keytipSequences;\n    let newOverflowItems: any[] = [];\n\n    if (overflowKeytipSequences) {\n      items.forEach(overflowItem => {\n        const keytip = (overflowItem as IOverflowSetItemProps).keytipProps;\n        if (keytip) {\n          // Create persisted keytip\n          const persistedKeytip: IKeytipProps = {\n            content: keytip.content,\n            keySequences: keytip.keySequences,\n            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n            hasDynamicChildren: keytip.hasDynamicChildren,\n            hasMenu: keytip.hasMenu,\n          };\n\n          if (keytip.hasDynamicChildren || this._getSubMenuForItem(overflowItem)) {\n            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n            persistedKeytip.onExecute = this._keytipManager.menuExecute.bind(\n              this._keytipManager,\n              overflowKeytipSequences,\n              overflowItem.keytipProps.keySequences,\n            );\n          } else {\n            // If the keytip doesn't have a submenu, just execute the original function\n            persistedKeytip.onExecute = keytip.onExecute;\n          }\n\n          // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n          // uniqueID will get updated on register\n          this._persistedKeytips[persistedKeytip.content] = persistedKeytip;\n\n          // Add the overflow sequence to this item\n          const newOverflowItem = {\n            ...overflowItem,\n            keytipProps: {\n              ...keytip,\n              overflowSetSequence: overflowKeytipSequences,\n            },\n          };\n          newOverflowItems.push(newOverflowItem);\n        } else {\n          // Nothing to change, add overflowItem to list\n          newOverflowItems.push(overflowItem);\n        }\n      });\n    } else {\n      newOverflowItems = items;\n    }\n    return <div {...wrapperDivProps}>{this.props.onRenderOverflowButton(newOverflowItems)}</div>;\n  };\n\n  /**\n   * Gets the subMenu for an overflow item\n   * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n   */\n  private _getSubMenuForItem(item: any): any[] | undefined {\n    if (this.props.itemSubMenuProvider) {\n      return this.props.itemSubMenuProvider(item);\n    }\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n    return undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}