{"ast":null,"code":"/**\n * Determines the distance between two points.\n *\n * @public\n */\n\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1, point2) {\n  var left1 = point1.left || point1.x || 0;\n  var top1 = point1.top || point1.y || 0;\n  var left2 = point2.left || point2.x || 0;\n  var top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n  return distance;\n}\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\n\nexport function fitContentToBounds(options) {\n  var contentSize = options.contentSize,\n      boundsSize = options.boundsSize,\n      _a = options.mode,\n      mode = _a === void 0 ? 'contain' : _a,\n      _b = options.maxScale,\n      maxScale = _b === void 0 ? 1 : _b;\n  var contentAspectRatio = contentSize.width / contentSize.height;\n  var boundsAspectRatio = boundsSize.width / boundsSize.height;\n  var scale;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  var finalScale = Math.min(maxScale, scale);\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale\n  };\n}\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\n\nexport function calculatePrecision(value) {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  var groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n\n  if (!groups) {\n    return 0;\n  }\n\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n\n  if (groups[2]) {\n    return groups[2].length;\n  }\n\n  return 0;\n}\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\n\nexport function precisionRound(value, precision, base) {\n  if (base === void 0) {\n    base = 10;\n  }\n\n  var exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}","map":{"version":3,"mappings":"AAGA;;;;;;AAKA;AACA,OAAM,SAAUA,wBAAV,CAAmCC,MAAnC,EAAkDC,MAAlD,EAA+D;EACnE,IAAMC,KAAK,GAAGF,MAAM,CAACG,IAAP,IAAeH,MAAM,CAACI,CAAtB,IAA2B,CAAzC;EACA,IAAMC,IAAI,GAAGL,MAAM,CAACM,GAAP,IAAcN,MAAM,CAACO,CAArB,IAA0B,CAAvC;EACA,IAAMC,KAAK,GAAGP,MAAM,CAACE,IAAP,IAAeF,MAAM,CAACG,CAAtB,IAA2B,CAAzC;EACA,IAAMK,IAAI,GAAGR,MAAM,CAACK,GAAP,IAAcL,MAAM,CAACM,CAArB,IAA0B,CAAvC;EACA;;EAEA,IAAIG,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,GAAL,CAASX,KAAK,GAAGM,KAAjB,EAAwB,CAAxB,IAA6BG,IAAI,CAACE,GAAL,CAASR,IAAI,GAAGI,IAAhB,EAAsB,CAAtB,CAAvC,CAAf;EAEA,OAAOC,QAAP;AACD;AA+BD;;;;;;;;;;;;AAWA,OAAM,SAAUI,kBAAV,CAA6BC,OAA7B,EAAgE;EAC5D;EAAA,IAAaC,+BAAb;EAAA,IAAyBC,iBAAzB;EAAA,IAAyBC,qCAAzB;EAAA,IAA2CC,qBAA3C;EAAA,IAA2CC,iCAA3C;EAER,IAAMC,kBAAkB,GAAGC,WAAW,CAACC,KAAZ,GAAoBD,WAAW,CAACE,MAA3D;EACA,IAAMC,iBAAiB,GAAGT,UAAU,CAACO,KAAX,GAAmBP,UAAU,CAACQ,MAAxD;EAEA,IAAIE,KAAJ;;EAEA,IAAIR,IAAI,KAAK,SAAT,GAAqBG,kBAAkB,GAAGI,iBAA1C,GAA8DJ,kBAAkB,GAAGI,iBAAvF,EAA0G;IACxGC,KAAK,GAAGV,UAAU,CAACO,KAAX,GAAmBD,WAAW,CAACC,KAAvC;EACD,CAFD,MAEO;IACLG,KAAK,GAAGV,UAAU,CAACQ,MAAX,GAAoBF,WAAW,CAACE,MAAxC;EACD;;EAED,IAAMG,UAAU,GAAGhB,IAAI,CAACiB,GAAL,CAASR,QAAT,EAAmBM,KAAnB,CAAnB;EAEA,OAAO;IACLH,KAAK,EAAED,WAAW,CAACC,KAAZ,GAAoBI,UADtB;IAELH,MAAM,EAAEF,WAAW,CAACE,MAAZ,GAAqBG;EAFxB,CAAP;AAID;AAED;;;;;;;;AAOA,OAAM,SAAUE,kBAAV,CAA6BC,KAA7B,EAAmD;EACvD;;;;;;EAMA,IAAMC,MAAM,GAAG,0BAA0BC,IAA1B,CAA+BC,MAAM,CAACH,KAAD,CAArC,CAAf;;EACA,IAAI,CAACC,MAAL,EAAa;IACX,OAAO,CAAP;EACD;;EACD,IAAIA,MAAM,CAAC,CAAD,CAAV,EAAe;IACb,OAAO,CAACA,MAAM,CAAC,CAAD,CAAN,CAAUG,MAAlB;EACD;;EACD,IAAIH,MAAM,CAAC,CAAD,CAAV,EAAe;IACb,OAAOA,MAAM,CAAC,CAAD,CAAN,CAAUG,MAAjB;EACD;;EACD,OAAO,CAAP;AACD;AAED;;;;;;AAKA,OAAM,SAAUC,cAAV,CAAyBL,KAAzB,EAAwCM,SAAxC,EAA2DC,IAA3D,EAA4E;EAAjB;IAAAA;EAAiB;;EAChF,IAAMC,GAAG,GAAG3B,IAAI,CAACE,GAAL,CAASwB,IAAT,EAAeD,SAAf,CAAZ;EACA,OAAOzB,IAAI,CAAC4B,KAAL,CAAWT,KAAK,GAAGQ,GAAnB,IAA0BA,GAAjC;AACD","names":["getDistanceBetweenPoints","point1","point2","left1","left","x","top1","top","y","left2","top2","distance","Math","sqrt","pow","fitContentToBounds","options","boundsSize","_a","mode","_b","maxScale","contentAspectRatio","contentSize","width","height","boundsAspectRatio","scale","finalScale","min","calculatePrecision","value","groups","exec","String","length","precisionRound","precision","base","exp","round"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\node_modules\\@uifabric\\utilities\\src\\math.ts"],"sourcesContent":["import { Point } from './Point';\nimport { ISize } from './ISize';\n\n/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1: Point, point2: Point): number {\n  const left1 = point1.left || point1.x || 0;\n  const top1 = point1.top || point1.y || 0;\n  const left2 = point2.left || point2.x || 0;\n  const top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  let distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n\n  return distance;\n}\n\n/**\n * The available fit modes. These should match the fit modes for CSS.\n */\nexport type FitMode = 'contain' | 'cover';\n\n/**\n * Options for fitting content sizes into bounding sizes.\n */\nexport interface IFitContentToBoundsOptions {\n  /**\n   * The size of the content to fit to the bounds.\n   * The output will be proportional to this value.\n   */\n  contentSize: ISize;\n  /**\n   * The size of the bounds.\n   */\n  boundsSize: ISize;\n  /**\n   * The fit mode to apply, either 'contain' or 'cover'.\n   */\n  mode: FitMode;\n  /**\n   * An optional maximum scale factor to apply. The default is 1.\n   * Use Infinity for an unbounded resize.\n   */\n  maxScale?: number;\n}\n\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options: IFitContentToBoundsOptions): ISize {\n  const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;\n\n  const contentAspectRatio = contentSize.width / contentSize.height;\n  const boundsAspectRatio = boundsSize.width / boundsSize.height;\n\n  let scale: number;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  const finalScale = Math.min(maxScale, scale);\n\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale,\n  };\n}\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n"]},"metadata":{},"sourceType":"module"}