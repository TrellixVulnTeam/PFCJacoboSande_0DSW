{"ast":null,"code":"import { Customizations, mergeSettings } from '@uifabric/utilities';\n/**\n * @internal\n * This function is still in experimental phase in support of Foundation experimental development.\n * Its API signature and existence are subject to change.\n *\n * Modify context to activate the specified scheme or theme. For schemes, look in context (if available) and fall back\n * to global Customizations. If both scheme and theme are specified, scheme will be looked up in theme. In this case,\n * scheme must be present in theme arg, otherwise new context will default to theme arg (there is no fallback to\n * settings to look up scheme.)\n *\n * @param context - Context in which to get schemed customizations.\n * @param scheme - Scheme to get customizations for from theme arg (if supplied) OR from context and global settings.\n * @param theme - Theme to merge into context.\n * @returns modified schemed context if scheme is valid and not already applied, unmodified context otherwise.\n */\n\nexport function getThemedContext(context, scheme, theme) {\n  var newContext = context;\n  var newSettings; // Only fall back to context and customizations when theme arg is not provided.\n\n  var schemeSource = theme || Customizations.getSettings(['theme'], undefined, context.customizations).theme;\n\n  if (theme) {\n    newSettings = {\n      theme: theme\n    };\n  }\n\n  var schemeTheme = scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme]; // These first two checks are logically redundant but TS doesn't infer schemeSource.schemes is defined\n  // when schemeTheme is defined.\n\n  if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {\n    newSettings = {\n      theme: schemeTheme\n    };\n    newSettings.theme.schemes = schemeSource.schemes;\n  }\n\n  if (newSettings) {\n    newContext = {\n      customizations: {\n        settings: mergeSettings(context.customizations.settings, newSettings),\n        scopedSettings: context.customizations.scopedSettings\n      }\n    };\n  }\n\n  return newContext;\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,EAAyBC,aAAzB,QAAkE,qBAAlE;AAGA;;;;;;;;;;;;;;;;AAeA,OAAM,SAAUC,gBAAV,CACJC,OADI,EAEJC,MAFI,EAGJC,KAHI,EAGU;AAEd,MAAIC,UAAU,GAAuBH,OAArC;AACA,MAAII,WAAJ,CAHc,CAKd;;AACA,MAAIC,YAAY,GAAGH,KAAK,IAAIL,cAAc,CAACS,WAAf,CAA2B,CAAC,OAAD,CAA3B,EAAsCC,SAAtC,EAAiDP,OAAO,CAACQ,cAAzD,EAAyEN,KAArG;;AAEA,MAAIA,KAAJ,EAAW;AACTE,eAAW,GAAG;AAAEF,WAAK;AAAP,KAAd;AACD;;AAED,MAAMO,WAAW,GACfR,MAAM,IAAII,YAAV,IAA0BA,YAAY,CAACK,OAAvC,IAAkDL,YAAY,CAACK,OAAb,CAAqBT,MAArB,CADpD,CAZc,CAed;AACA;;AACA,MAAII,YAAY,IAAII,WAAhB,IAA+BJ,YAAY,KAAKI,WAApD,EAAiE;AAC/DL,eAAW,GAAG;AAAEF,WAAK,EAAEO;AAAT,KAAd;AACAL,eAAW,CAACF,KAAZ,CAAkBQ,OAAlB,GAA4BL,YAAY,CAACK,OAAzC;AACD;;AAED,MAAIN,WAAJ,EAAiB;AACfD,cAAU,GAAG;AACXK,oBAAc,EAAE;AACdG,gBAAQ,EAAEb,aAAa,CAACE,OAAO,CAACQ,cAAR,CAAuBG,QAAxB,EAAkCP,WAAlC,CADT;AAEdQ,sBAAc,EAAEZ,OAAO,CAACQ,cAAR,CAAuBI;AAFzB;AADL,KAAb;AAMD;;AAED,SAAOT,UAAP;AACD","names":["Customizations","mergeSettings","getThemedContext","context","scheme","theme","newContext","newSettings","schemeSource","getSettings","undefined","customizations","schemeTheme","schemes","settings","scopedSettings"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\styling\\lib\\src\\styles\\scheme.ts"],"sourcesContent":["import { Customizations, mergeSettings, ICustomizerContext } from '@uifabric/utilities';\nimport { ISchemeNames, ITheme } from '../interfaces/index';\n\n/**\n * @internal\n * This function is still in experimental phase in support of Foundation experimental development.\n * Its API signature and existence are subject to change.\n *\n * Modify context to activate the specified scheme or theme. For schemes, look in context (if available) and fall back\n * to global Customizations. If both scheme and theme are specified, scheme will be looked up in theme. In this case,\n * scheme must be present in theme arg, otherwise new context will default to theme arg (there is no fallback to\n * settings to look up scheme.)\n *\n * @param context - Context in which to get schemed customizations.\n * @param scheme - Scheme to get customizations for from theme arg (if supplied) OR from context and global settings.\n * @param theme - Theme to merge into context.\n * @returns modified schemed context if scheme is valid and not already applied, unmodified context otherwise.\n */\nexport function getThemedContext(\n  context: ICustomizerContext,\n  scheme?: ISchemeNames,\n  theme?: ITheme,\n): ICustomizerContext {\n  let newContext: ICustomizerContext = context;\n  let newSettings;\n\n  // Only fall back to context and customizations when theme arg is not provided.\n  let schemeSource = theme || Customizations.getSettings(['theme'], undefined, context.customizations).theme;\n\n  if (theme) {\n    newSettings = { theme };\n  }\n\n  const schemeTheme: ITheme | undefined =\n    scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme];\n\n  // These first two checks are logically redundant but TS doesn't infer schemeSource.schemes is defined\n  // when schemeTheme is defined.\n  if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {\n    newSettings = { theme: schemeTheme };\n    newSettings.theme.schemes = schemeSource.schemes;\n  }\n\n  if (newSettings) {\n    newContext = {\n      customizations: {\n        settings: mergeSettings(context.customizations.settings, newSettings),\n        scopedSettings: context.customizations.scopedSettings,\n      },\n    };\n  }\n\n  return newContext;\n}\n"]},"metadata":{},"sourceType":"module"}