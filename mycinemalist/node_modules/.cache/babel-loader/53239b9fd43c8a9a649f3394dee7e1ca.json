{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, css, divProperties, findIndex, findScrollableParent, getNativeProps, getParent, getWindow, initializeComponentRef } from '../../Utilities';\nimport { ScrollToMode } from './List.types';\nimport { composeRenderFunction } from '../../Utilities';\nvar RESIZE_DELAY = 16;\nvar MIN_SCROLL_UPDATE_DELAY = 100;\nvar MAX_SCROLL_UPDATE_DELAY = 500;\nvar IDLE_DEBOUNCE_DELAY = 200; // The amount of time to wait before declaring that the list isn't scrolling\n\nvar DONE_SCROLLING_WAIT = 500;\nvar DEFAULT_ITEMS_PER_PAGE = 10;\nvar DEFAULT_PAGE_HEIGHT = 30;\nvar DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nvar DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nvar PAGE_KEY_PREFIX = 'page-';\nvar SPACER_KEY_PREFIX = 'spacer-';\nvar EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0\n}; // Naming expensive measures so that they're named in profiles.\n\nvar _measurePageRect = function _measurePageRect(element) {\n  return element.getBoundingClientRect();\n};\n\nvar _measureSurfaceRect = _measurePageRect;\nvar _measureScrollRect = _measurePageRect;\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback\n * if provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if\n * provided by the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time.\n * And we start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\n\nvar List =\n/** @class */\nfunction (_super) {\n  __extends(List, _super);\n\n  function List(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._surface = React.createRef();\n    _this._pageRefs = {};\n\n    _this._getDerivedStateFromProps = function (nextProps, previousState) {\n      if (nextProps.items !== _this.props.items || nextProps.renderCount !== _this.props.renderCount || nextProps.startIndex !== _this.props.startIndex || nextProps.version !== _this.props.version) {\n        // We have received new items so we want to make sure that initially we only render a single window to\n        // fill the currently visible rect, and then later render additional windows.\n        _this._resetRequiredWindows();\n\n        _this._requiredRect = null;\n        _this._measureVersion++;\n\n        _this._invalidatePageCache();\n\n        return _this._updatePages(nextProps, previousState);\n      }\n\n      return previousState;\n    };\n\n    _this._onRenderRoot = function (props) {\n      var rootRef = props.rootRef,\n          surfaceElement = props.surfaceElement,\n          divProps = props.divProps;\n      return React.createElement(\"div\", __assign({\n        ref: rootRef\n      }, divProps), surfaceElement);\n    };\n\n    _this._onRenderSurface = function (props) {\n      var surfaceRef = props.surfaceRef,\n          pageElements = props.pageElements,\n          divProps = props.divProps;\n      return React.createElement(\"div\", __assign({\n        ref: surfaceRef\n      }, divProps), pageElements);\n    };\n\n    _this._onRenderPage = function (pageProps, defaultRender) {\n      var _a = _this.props,\n          onRenderCell = _a.onRenderCell,\n          role = _a.role;\n\n      var _b = pageProps.page,\n          _c = _b.items,\n          items = _c === void 0 ? [] : _c,\n          startIndex = _b.startIndex,\n          divProps = __rest(pageProps, [\"page\"]); // only assign list item role if no role is assigned\n\n\n      var cellRole = role === undefined ? 'listitem' : 'presentation';\n      var cells = [];\n\n      for (var i = 0; i < items.length; i++) {\n        var index = startIndex + i;\n        var item = items[i];\n        var itemKey = _this.props.getKey ? _this.props.getKey(item, index) : item && item.key;\n\n        if (itemKey === null || itemKey === undefined) {\n          itemKey = index;\n        }\n\n        cells.push(React.createElement(\"div\", {\n          role: cellRole,\n          className: 'ms-List-cell',\n          key: itemKey,\n          \"data-list-index\": index,\n          \"data-automationid\": \"ListCell\"\n        }, onRenderCell && onRenderCell(item, index, !_this.props.ignoreScrollingState ? _this.state.isScrolling : undefined)));\n      }\n\n      return React.createElement(\"div\", __assign({}, divProps), cells);\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      pages: [],\n      isScrolling: false,\n      getDerivedStateFromProps: _this._getDerivedStateFromProps\n    };\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._estimatedPageHeight = 0;\n    _this._totalEstimates = 0;\n    _this._requiredWindowsAhead = 0;\n    _this._requiredWindowsBehind = 0; // Track the measure version for everything.\n\n    _this._measureVersion = 0; // Ensure that scrolls are lazy updated.\n\n    _this._onAsyncScroll = _this._async.debounce(_this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\n      leading: false,\n      maxWait: MAX_SCROLL_UPDATE_DELAY\n    });\n    _this._onAsyncIdle = _this._async.debounce(_this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\n      leading: false\n    });\n    _this._onAsyncResize = _this._async.debounce(_this._onAsyncResize, RESIZE_DELAY, {\n      leading: false\n    });\n    _this._onScrollingDone = _this._async.debounce(_this._onScrollingDone, DONE_SCROLLING_WAIT, {\n      leading: false\n    });\n    _this._cachedPageHeights = {};\n    _this._estimatedPageHeight = 0;\n    _this._focusedIndex = -1;\n    _this._pageCache = {};\n    return _this;\n  }\n\n  List.getDerivedStateFromProps = function (nextProps, previousState) {\n    return previousState.getDerivedStateFromProps(nextProps, previousState);\n  };\n\n  Object.defineProperty(List.prototype, \"pageRefs\", {\n    get: function get() {\n      return this._pageRefs;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\n   *\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\n   *\n   * @param index - Index of item to scroll to\n   * @param measureItem - Optional callback to measure the height of an individual item\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\n   */\n\n  List.prototype.scrollToIndex = function (index, measureItem, scrollToMode) {\n    if (scrollToMode === void 0) {\n      scrollToMode = ScrollToMode.auto;\n    }\n\n    var startIndex = this.props.startIndex;\n\n    var renderCount = this._getRenderCount();\n\n    var endIndex = startIndex + renderCount;\n    var allowedRect = this._allowedRect;\n    var scrollTop = 0;\n    var itemsPerPage = 1;\n\n    for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      var pageSpecification = this._getPageSpecification(itemIndex, allowedRect);\n\n      var pageHeight = pageSpecification.height;\n      itemsPerPage = pageSpecification.itemCount;\n      var requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\n\n      if (requestedIndexIsInPage) {\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in\n        // just the given item, otherwise we'll only bring the page into view\n        if (measureItem && this._scrollElement) {\n          var scrollRect = _measureScrollRect(this._scrollElement);\n\n          var scrollWindow = {\n            top: this._scrollElement.scrollTop,\n            bottom: this._scrollElement.scrollTop + scrollRect.height\n          }; // Adjust for actual item position within page\n\n          var itemPositionWithinPage = index - itemIndex;\n\n          for (var itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\n          }\n\n          var scrollBottom = scrollTop + measureItem(index); // If scrollToMode is set to something other than auto, we always want to\n          // scroll the item into a specific position on the page.\n\n          switch (scrollToMode) {\n            case ScrollToMode.top:\n              this._scrollElement.scrollTop = scrollTop;\n              return;\n\n            case ScrollToMode.bottom:\n              this._scrollElement.scrollTop = scrollBottom - scrollRect.height;\n              return;\n\n            case ScrollToMode.center:\n              this._scrollElement.scrollTop = (scrollTop + scrollBottom - scrollRect.height) / 2;\n              return;\n\n            case ScrollToMode.auto:\n            default:\n              break;\n          }\n\n          var itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\n\n          if (itemIsFullyVisible) {\n            // Item is already visible, do nothing.\n            return;\n          }\n\n          var itemIsPartiallyAbove = scrollTop < scrollWindow.top;\n          var itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\n\n          if (itemIsPartiallyAbove) {//  We will just scroll to 'scrollTop'\n            //  .------.   - scrollTop\n            //  |Item  |\n            //  | .----|-. - scrollWindow.top\n            //  '------' |\n            //    |      |\n            //    '------'\n          } else if (itemIsPartiallyBelow) {\n            //  Adjust scrollTop position to just bring in the element\n            // .------.  - scrollTop\n            // |      |\n            // | .------.\n            // '-|----' | - scrollWindow.bottom\n            //   | Item |\n            //   '------' - scrollBottom\n            scrollTop = scrollBottom - scrollRect.height;\n          }\n        }\n\n        this._scrollElement.scrollTop = scrollTop;\n        return;\n      }\n\n      scrollTop += pageHeight;\n    }\n  };\n\n  List.prototype.getStartItemIndexInView = function (measureItem) {\n    var pages = this.state.pages || [];\n\n    for (var _i = 0, pages_1 = pages; _i < pages_1.length; _i++) {\n      var page = pages_1[_i];\n      var isPageVisible = !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\n\n      if (isPageVisible) {\n        if (!measureItem) {\n          var rowHeight = Math.floor(page.height / page.itemCount);\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\n        } else {\n          var totalRowHeight = 0;\n\n          for (var itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\n            var rowHeight = measureItem(itemIndex);\n\n            if (page.top + totalRowHeight <= this._scrollTop && this._scrollTop < page.top + totalRowHeight + rowHeight) {\n              return itemIndex;\n            } else {\n              totalRowHeight += rowHeight;\n            }\n          }\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  List.prototype.componentDidMount = function () {\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n    this._scrollElement = findScrollableParent(this._root.current);\n\n    this._events.on(window, 'resize', this._onAsyncResize);\n\n    if (this._root.current) {\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\n    }\n\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);\n    }\n  };\n\n  List.prototype.componentDidUpdate = function (previousProps, previousState) {\n    var finalProps = this.props;\n    var finalState = this.state;\n\n    if (this.state.pagesVersion !== previousState.pagesVersion) {\n      // If we weren't provided with the page height, measure the pages\n      if (!finalProps.getPageHeight) {\n        // If measured version is invalid since we've updated the DOM\n        var heightsChanged = this._updatePageMeasurements(finalState.pages); // On first render, we should re-measure so that we don't get a visual glitch.\n\n\n        if (heightsChanged) {\n          this._materializedRect = null;\n\n          if (!this._hasCompletedFirstRender) {\n            this._hasCompletedFirstRender = true;\n            this.setState(this._updatePages(finalProps, finalState));\n          } else {\n            this._onAsyncScroll();\n          }\n        } else {\n          // Enqueue an idle bump.\n          this._onAsyncIdle();\n        }\n      } else {\n        // Enqueue an idle bump\n        this._onAsyncIdle();\n      } // Notify the caller that rendering the new pages has completed\n\n\n      if (finalProps.onPagesUpdated) {\n        finalProps.onPagesUpdated(finalState.pages);\n      }\n    }\n  };\n\n  List.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n\n    delete this._scrollElement;\n  };\n\n  List.prototype.shouldComponentUpdate = function (newProps, newState) {\n    var oldPages = this.state.pages;\n    var newPages = newState.pages;\n    var shouldComponentUpdate = false; // Update if the page stops scrolling\n\n    if (!newState.isScrolling && this.state.isScrolling) {\n      return true;\n    }\n\n    if (newProps.version !== this.props.version) {\n      return true;\n    }\n\n    if (newProps.items === this.props.items && oldPages.length === newPages.length) {\n      for (var i = 0; i < oldPages.length; i++) {\n        var oldPage = oldPages[i];\n        var newPage = newPages[i];\n\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n\n    return shouldComponentUpdate;\n  };\n\n  List.prototype.forceUpdate = function () {\n    this._invalidatePageCache(); // Ensure that when the list is force updated we update the pages first before render.\n\n\n    this._updateRenderRects(this.props, this.state, true);\n\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n\n    _super.prototype.forceUpdate.call(this);\n  };\n  /**\n   * Get the current height the list and it's pages.\n   */\n\n\n  List.prototype.getTotalListHeight = function () {\n    return this._surfaceRect.height;\n  };\n\n  List.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.role,\n        role = _b === void 0 ? 'list' : _b,\n        onRenderSurface = _a.onRenderSurface,\n        onRenderRoot = _a.onRenderRoot;\n    var _c = this.state.pages,\n        pages = _c === void 0 ? [] : _c;\n    var pageElements = [];\n    var divProps = getNativeProps(this.props, divProperties);\n\n    for (var _i = 0, pages_2 = pages; _i < pages_2.length; _i++) {\n      var page = pages_2[_i];\n      pageElements.push(this._renderPage(page));\n    }\n\n    var finalOnRenderSurface = onRenderSurface ? composeRenderFunction(onRenderSurface, this._onRenderSurface) : this._onRenderSurface;\n    var finalOnRenderRoot = onRenderRoot ? composeRenderFunction(onRenderRoot, this._onRenderRoot) : this._onRenderRoot;\n    return finalOnRenderRoot({\n      rootRef: this._root,\n      pages: pages,\n      surfaceElement: finalOnRenderSurface({\n        surfaceRef: this._surface,\n        pages: pages,\n        pageElements: pageElements,\n        divProps: {\n          role: 'presentation',\n          className: 'ms-List-surface'\n        }\n      }),\n      divProps: __assign(__assign({}, divProps), {\n        className: css('ms-List', className),\n        role: pageElements.length > 0 ? role : undefined\n      })\n    });\n  };\n\n  List.prototype._shouldVirtualize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var onShouldVirtualize = props.onShouldVirtualize;\n    return !onShouldVirtualize || onShouldVirtualize(props);\n  };\n  /**\n   * when props.items change or forceUpdate called, throw away cached pages\n   */\n\n\n  List.prototype._invalidatePageCache = function () {\n    this._pageCache = {};\n  };\n\n  List.prototype._renderPage = function (page) {\n    var _this = this;\n\n    var usePageCache = this.props.usePageCache;\n    var cachedPage; // if usePageCache is set and cached page element can be found, just return cached page\n\n    if (usePageCache) {\n      cachedPage = this._pageCache[page.key];\n\n      if (cachedPage && cachedPage.pageElement) {\n        return cachedPage.pageElement;\n      }\n    }\n\n    var pageStyle = this._getPageStyle(page);\n\n    var _a = this.props.onRenderPage,\n        onRenderPage = _a === void 0 ? this._onRenderPage : _a;\n    var pageElement = onRenderPage({\n      page: page,\n      className: 'ms-List-page',\n      key: page.key,\n      ref: function ref(newRef) {\n        _this._pageRefs[page.key] = newRef;\n      },\n      style: pageStyle,\n      role: 'presentation'\n    }, this._onRenderPage); // cache the first page for now since it is re-rendered a lot times unnecessarily.\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\n\n    if (usePageCache && page.startIndex === 0) {\n      this._pageCache[page.key] = {\n        page: page,\n        pageElement: pageElement\n      };\n    }\n\n    return pageElement;\n  };\n  /** Generate the style object for the page. */\n\n\n  List.prototype._getPageStyle = function (page) {\n    var getPageStyle = this.props.getPageStyle;\n    return __assign(__assign({}, getPageStyle ? getPageStyle(page) : {}), !page.items ? {\n      height: page.height\n    } : {});\n  };\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n\n\n  List.prototype._onFocus = function (ev) {\n    var target = ev.target;\n\n    while (target !== this._surface.current) {\n      var indexString = target.getAttribute('data-list-index');\n\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n\n      target = getParent(target);\n    }\n  };\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n\n\n  List.prototype._onScroll = function () {\n    if (!this.state.isScrolling && !this.props.ignoreScrollingState) {\n      this.setState({\n        isScrolling: true\n      });\n    }\n\n    this._resetRequiredWindows();\n\n    this._onScrollingDone();\n  };\n\n  List.prototype._resetRequiredWindows = function () {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  };\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n\n\n  List.prototype._onAsyncScroll = function () {\n    this._updateRenderRects(this.props, this.state); // Only update pages when the visible rect falls outside of the materialized rect.\n\n\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {\n      this.setState(this._updatePages(this.props, this.state));\n    } else {// console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  };\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n\n\n  List.prototype._onAsyncIdle = function () {\n    var _a = this.props,\n        renderedWindowsAhead = _a.renderedWindowsAhead,\n        renderedWindowsBehind = _a.renderedWindowsBehind;\n\n    var _b = this,\n        requiredWindowsAhead = _b._requiredWindowsAhead,\n        requiredWindowsBehind = _b._requiredWindowsBehind;\n\n    var windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);\n    var windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);\n\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n      // console.log('idling', windowsBehind, windowsAhead);\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n\n      this._updateRenderRects(this.props, this.state);\n\n      this.setState(this._updatePages(this.props, this.state));\n    }\n\n    if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdle();\n    }\n  };\n  /**\n   * Function to call when the list is done scrolling.\n   * This function is debounced.\n   */\n\n\n  List.prototype._onScrollingDone = function () {\n    if (!this.props.ignoreScrollingState) {\n      this.setState({\n        isScrolling: false\n      });\n    }\n  };\n\n  List.prototype._onAsyncResize = function () {\n    this.forceUpdate();\n  };\n\n  List.prototype._updatePages = function (nextProps, previousState) {\n    // console.log('updating pages');\n    if (!this._requiredRect) {\n      this._updateRenderRects(nextProps, previousState);\n    }\n\n    var newListState = this._buildPages(nextProps, previousState);\n\n    var oldListPages = previousState.pages;\n\n    this._notifyPageChanges(oldListPages, newListState.pages, this.props);\n\n    return __assign(__assign(__assign({}, previousState), newListState), {\n      pagesVersion: {}\n    });\n  };\n  /**\n   * Notify consumers that the rendered pages have changed\n   * @param oldPages - The old pages\n   * @param newPages - The new pages\n   * @param props - The props to use\n   */\n\n\n  List.prototype._notifyPageChanges = function (oldPages, newPages, props) {\n    var onPageAdded = props.onPageAdded,\n        onPageRemoved = props.onPageRemoved;\n\n    if (onPageAdded || onPageRemoved) {\n      var renderedIndexes = {};\n\n      for (var _i = 0, oldPages_1 = oldPages; _i < oldPages_1.length; _i++) {\n        var page = oldPages_1[_i];\n\n        if (page.items) {\n          renderedIndexes[page.startIndex] = page;\n        }\n      }\n\n      for (var _a = 0, newPages_1 = newPages; _a < newPages_1.length; _a++) {\n        var page = newPages_1[_a];\n\n        if (page.items) {\n          if (!renderedIndexes[page.startIndex]) {\n            this._onPageAdded(page);\n          } else {\n            delete renderedIndexes[page.startIndex];\n          }\n        }\n      }\n\n      for (var index in renderedIndexes) {\n        if (renderedIndexes.hasOwnProperty(index)) {\n          this._onPageRemoved(renderedIndexes[index]);\n        }\n      }\n    }\n  };\n\n  List.prototype._updatePageMeasurements = function (pages) {\n    var heightChanged = false; // when not in virtualize mode, we render all the items without page measurement\n\n    if (!this._shouldVirtualize()) {\n      return heightChanged;\n    }\n\n    for (var i = 0; i < pages.length; i++) {\n      var page = pages[i];\n\n      if (page.items) {\n        heightChanged = this._measurePage(page) || heightChanged;\n      }\n    }\n\n    return heightChanged;\n  };\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n\n\n  List.prototype._measurePage = function (page) {\n    var hasChangedHeight = false;\n    var pageElement = this._pageRefs[page.key];\n    var cachedHeight = this._cachedPageHeights[page.startIndex]; // console.log('   * measure attempt', page.startIndex, cachedHeight);\n\n    if (pageElement && this._shouldVirtualize() && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {\n      var newClientRect = {\n        width: pageElement.clientWidth,\n        height: pageElement.clientHeight\n      };\n\n      if (newClientRect.height || newClientRect.width) {\n        hasChangedHeight = page.height !== newClientRect.height; // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n\n        page.height = newClientRect.height;\n        this._cachedPageHeights[page.startIndex] = {\n          height: newClientRect.height,\n          measureVersion: this._measureVersion\n        };\n        this._estimatedPageHeight = Math.round((this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1));\n        this._totalEstimates++;\n      }\n    }\n\n    return hasChangedHeight;\n  };\n  /** Called when a page has been added to the DOM. */\n\n\n  List.prototype._onPageAdded = function (page) {\n    var onPageAdded = this.props.onPageAdded; // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  };\n  /** Called when a page has been removed from the DOM. */\n\n\n  List.prototype._onPageRemoved = function (page) {\n    var onPageRemoved = this.props.onPageRemoved; // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  };\n  /** Build up the pages that should be rendered. */\n\n\n  List.prototype._buildPages = function (props, state) {\n    var renderCount = props.renderCount;\n    var items = props.items,\n        startIndex = props.startIndex,\n        getPageHeight = props.getPageHeight;\n    renderCount = this._getRenderCount(props);\n\n    var materializedRect = __assign({}, EMPTY_RECT);\n\n    var pages = [];\n    var itemsPerPage = 1;\n    var pageTop = 0;\n    var currentSpacer = null;\n    var focusedIndex = this._focusedIndex;\n    var endIndex = startIndex + renderCount;\n\n    var shouldVirtualize = this._shouldVirtualize(props); // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n\n\n    var isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\n    var allowedRect = this._allowedRect;\n\n    var _loop_1 = function _loop_1(itemIndex) {\n      var pageSpecification = this_1._getPageSpecification(itemIndex, allowedRect);\n\n      var pageHeight = pageSpecification.height;\n      var pageData = pageSpecification.data;\n      var key = pageSpecification.key;\n      itemsPerPage = pageSpecification.itemCount;\n      var pageBottom = pageTop + pageHeight - 1;\n      var isPageRendered = findIndex(state.pages, function (page) {\n        return !!page.items && page.startIndex === itemIndex;\n      }) > -1;\n      var isPageInAllowedRange = !allowedRect || pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom;\n      var isPageInRequiredRange = !this_1._requiredRect || pageBottom >= this_1._requiredRect.top && pageTop <= this_1._requiredRect.bottom;\n      var isPageVisible = !isFirstRender && (isPageInRequiredRange || isPageInAllowedRange && isPageRendered) || !shouldVirtualize;\n      var isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\n      var isFirstPage = itemIndex === startIndex; // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' +\n      // isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);\n      // Only render whats visible, focused, or first page,\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\n\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n\n        var itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n\n        var newPage = this_1._createPage(key, items.slice(itemIndex, itemIndex + itemsInPage), itemIndex, undefined, undefined, pageData);\n\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n\n        if (this_1._visibleRect && this_1._visibleRect.bottom) {\n          newPage.isVisible = pageBottom >= this_1._visibleRect.top && pageTop <= this_1._visibleRect.bottom;\n        }\n\n        pages.push(newPage);\n\n        if (isPageInRequiredRange && this_1._allowedRect) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: allowedRect.left,\n            right: allowedRect.right,\n            width: allowedRect.width\n          });\n        }\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this_1._createPage(SPACER_KEY_PREFIX + itemIndex, undefined, itemIndex, 0, undefined, pageData, true\n          /*isSpacer*/\n          );\n        }\n\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n\n      pageTop += pageBottom - pageTop + 1; // in virtualized mode, we render need to render first page then break and measure,\n      // otherwise, we render all items without measurement to make rendering fast\n\n      if (isFirstRender && shouldVirtualize) {\n        return \"break\";\n      }\n    };\n\n    var this_1 = this;\n\n    for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      var state_1 = _loop_1(itemIndex);\n\n      if (state_1 === \"break\") break;\n    }\n\n    if (currentSpacer) {\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\n      pages.push(currentSpacer);\n    }\n\n    this._materializedRect = materializedRect; // console.log('materialized: ', materializedRect);\n\n    return __assign(__assign({}, state), {\n      pages: pages,\n      measureVersion: this._measureVersion\n    });\n  };\n\n  List.prototype._getPageSpecification = function (itemIndex, visibleRect) {\n    var getPageSpecification = this.props.getPageSpecification;\n\n    if (getPageSpecification) {\n      var pageData = getPageSpecification(itemIndex, visibleRect);\n      var _a = pageData.itemCount,\n          itemCount = _a === void 0 ? this._getItemCountForPage(itemIndex, visibleRect) : _a;\n      var _b = pageData.height,\n          height = _b === void 0 ? this._getPageHeight(itemIndex, visibleRect, itemCount) : _b;\n      return {\n        itemCount: itemCount,\n        height: height,\n        data: pageData.data,\n        key: pageData.key\n      };\n    } else {\n      var itemCount = this._getItemCountForPage(itemIndex, visibleRect);\n\n      return {\n        itemCount: itemCount,\n        height: this._getPageHeight(itemIndex, visibleRect, itemCount)\n      };\n    }\n  };\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n\n\n  List.prototype._getPageHeight = function (itemIndex, visibleRect, itemsPerPage) {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage);\n    } else {\n      var cachedHeight = this._cachedPageHeights[itemIndex];\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\n    }\n  };\n\n  List.prototype._getItemCountForPage = function (itemIndex, visibileRect) {\n    var itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  };\n\n  List.prototype._createPage = function (pageKey, items, startIndex, count, style, data, isSpacer) {\n    if (startIndex === void 0) {\n      startIndex = -1;\n    }\n\n    if (count === void 0) {\n      count = items ? items.length : 0;\n    }\n\n    if (style === void 0) {\n      style = {};\n    }\n\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\n    var cachedPage = this._pageCache[pageKey];\n\n    if (cachedPage && cachedPage.page) {\n      return cachedPage.page;\n    }\n\n    return {\n      key: pageKey,\n      startIndex: startIndex,\n      itemCount: count,\n      items: items,\n      style: style,\n      top: 0,\n      height: 0,\n      data: data,\n      isSpacer: isSpacer || false\n    };\n  };\n\n  List.prototype._getRenderCount = function (props) {\n    var _a = props || this.props,\n        items = _a.items,\n        startIndex = _a.startIndex,\n        renderCount = _a.renderCount;\n\n    return renderCount === undefined ? items ? items.length - startIndex : 0 : renderCount;\n  };\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n\n\n  List.prototype._updateRenderRects = function (props, state, forceUpdate) {\n    var renderedWindowsAhead = props.renderedWindowsAhead,\n        renderedWindowsBehind = props.renderedWindowsBehind;\n    var pages = state.pages; // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\n\n    if (!this._shouldVirtualize(props)) {\n      return;\n    }\n\n    var surfaceRect = this._surfaceRect || __assign({}, EMPTY_RECT);\n\n    var scrollHeight = this._scrollElement && this._scrollElement.scrollHeight;\n    var scrollTop = this._scrollElement ? this._scrollElement.scrollTop : 0; // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    // This needs to be called to recalculate when new pages should be loaded.\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\n\n    if (this._surface.current && (forceUpdate || !pages || !this._surfaceRect || !scrollHeight || scrollHeight !== this._scrollHeight || Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)) {\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\n      this._scrollTop = scrollTop;\n    } // If the scroll height has changed, something in the container likely resized and\n    // we should redo the page heights incase their content resized.\n\n\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\n      this._measureVersion++;\n    }\n\n    this._scrollHeight = scrollHeight; // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n\n    var visibleTop = Math.max(0, -surfaceRect.top);\n    var win = getWindow(this._root.current);\n    var visibleRect = {\n      top: visibleTop,\n      left: surfaceRect.left,\n      bottom: visibleTop + win.innerHeight,\n      right: surfaceRect.right,\n      width: surfaceRect.width,\n      height: win.innerHeight\n    }; // The required/allowed rects are adjusted versions of the visible rect.\n\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead); // store the visible rect for later use.\n\n    this._visibleRect = visibleRect;\n  };\n\n  List.defaultProps = {\n    startIndex: 0,\n    onRenderCell: function onRenderCell(item, index, containsFocus) {\n      return React.createElement(React.Fragment, null, item && item.name || '');\n    },\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND\n  };\n  return List;\n}(React.Component);\n\nexport { List };\n\nfunction _expandRect(rect, pagesBefore, pagesAfter) {\n  var top = rect.top - pagesBefore * rect.height;\n  var height = rect.height + (pagesBefore + pagesAfter) * rect.height;\n  return {\n    top: top,\n    bottom: top + height,\n    height: height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width\n  };\n}\n\nfunction _isContainedWithin(innerRect, outerRect) {\n  return innerRect.top >= outerRect.top && innerRect.left >= outerRect.left && innerRect.bottom <= outerRect.bottom && innerRect.right <= outerRect.right;\n}\n\nfunction _mergeRect(targetRect, newRect) {\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\n  targetRect.bottom = newRect.bottom > targetRect.bottom || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\n  targetRect.right = newRect.right > targetRect.right || targetRect.right === -1 ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right - targetRect.left + 1;\n  targetRect.height = targetRect.bottom - targetRect.top + 1;\n  return targetRect;\n}","map":{"version":3,"mappings":"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","names":["React","Async","EventGroup","css","divProperties","findIndex","findScrollableParent","getNativeProps","getParent","getWindow","initializeComponentRef","ScrollToMode","composeRenderFunction","RESIZE_DELAY","MIN_SCROLL_UPDATE_DELAY","MAX_SCROLL_UPDATE_DELAY","IDLE_DEBOUNCE_DELAY","DONE_SCROLLING_WAIT","DEFAULT_ITEMS_PER_PAGE","DEFAULT_PAGE_HEIGHT","DEFAULT_RENDERED_WINDOWS_BEHIND","DEFAULT_RENDERED_WINDOWS_AHEAD","PAGE_KEY_PREFIX","SPACER_KEY_PREFIX","EMPTY_RECT","top","bottom","left","right","width","height","_measurePageRect","element","getBoundingClientRect","_measureSurfaceRect","_measureScrollRect","__extends","props","_super","_this","createRef","nextProps","previousState","items","renderCount","startIndex","version","_resetRequiredWindows","_requiredRect","_measureVersion","_invalidatePageCache","_updatePages","surfaceElement","divProps","ref","rootRef","pageElements","surfaceRef","pageProps","defaultRender","onRenderCell","role","_c","cellRole","undefined","cells","i","length","index","item","itemKey","getKey","key","push","className","ignoreScrollingState","state","isScrolling","pages","getDerivedStateFromProps","_getDerivedStateFromProps","_async","_events","_estimatedPageHeight","_totalEstimates","_requiredWindowsAhead","_requiredWindowsBehind","_onAsyncScroll","debounce","leading","maxWait","_onAsyncIdle","_onAsyncResize","_onScrollingDone","_cachedPageHeights","_focusedIndex","_pageCache","List","Object","_pageRefs","measureItem","scrollToMode","auto","_getRenderCount","endIndex","allowedRect","_allowedRect","scrollTop","itemsPerPage","itemIndex","pageSpecification","_getPageSpecification","pageHeight","itemCount","requestedIndexIsInPage","_scrollElement","scrollRect","scrollWindow","itemPositionWithinPage","itemIndexInPage","scrollBottom","center","itemIsFullyVisible","itemIsPartiallyAbove","itemIsPartiallyBelow","_i","page","isPageVisible","isSpacer","_scrollTop","rowHeight","Math","floor","totalRowHeight","setState","_root","current","on","window","_onFocus","_onScroll","previousProps","finalProps","finalState","pagesVersion","getPageHeight","heightsChanged","_updatePageMeasurements","_materializedRect","_hasCompletedFirstRender","onPagesUpdated","dispose","newProps","newState","shouldComponentUpdate","oldPages","newPages","oldPage","newPage","_updateRenderRects","forceUpdate","call","_surfaceRect","_b","onRenderSurface","onRenderRoot","_renderPage","finalOnRenderSurface","_onRenderSurface","finalOnRenderRoot","_onRenderRoot","_surface","onShouldVirtualize","cachedPage","usePageCache","pageElement","pageStyle","_getPageStyle","onRenderPage","newRef","style","_onRenderPage","getPageStyle","ev","target","indexString","getAttribute","Number","_isContainedWithin","renderedWindowsAhead","renderedWindowsBehind","requiredWindowsAhead","requiredWindowsBehind","windowsAhead","min","windowsBehind","newListState","_buildPages","oldListPages","_notifyPageChanges","onPageRemoved","onPageAdded","renderedIndexes","_a","_onPageAdded","hasOwnProperty","_onPageRemoved","heightChanged","_shouldVirtualize","_measurePage","hasChangedHeight","cachedHeight","measureVersion","newClientRect","clientWidth","clientHeight","round","materializedRect","pageTop","currentSpacer","focusedIndex","shouldVirtualize","isFirstRender","this_1","pageData","data","pageBottom","isPageRendered","isPageInAllowedRange","isPageInRequiredRange","isPageFocused","isFirstPage","itemsInPage","_createPage","slice","_visibleRect","isVisible","_mergeRect","visibleRect","getPageSpecification","_getItemCountForPage","_getPageHeight","visibileRect","getItemCountForPage","pageKey","count","surfaceRect","__assign","scrollHeight","_scrollHeight","abs","visibleTop","max","win","innerHeight","_expandRect","containsFocus","name","Component","rect","pagesBefore","pagesAfter","innerRect","outerRect","targetRect","newRect"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\office-ui-fabric-react\\lib\\components\\src\\components\\List\\List.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  IRectangle,\n  IRenderFunction,\n  css,\n  divProperties,\n  findIndex,\n  findScrollableParent,\n  getNativeProps,\n  getParent,\n  getWindow,\n  initializeComponentRef,\n} from '../../Utilities';\nimport {\n  IList,\n  IListProps,\n  IPage,\n  IPageProps,\n  ScrollToMode,\n  IListOnRenderSurfaceProps,\n  IListOnRenderRootProps,\n} from './List.types';\nimport { composeRenderFunction } from '../../Utilities';\n\nconst RESIZE_DELAY = 16;\nconst MIN_SCROLL_UPDATE_DELAY = 100;\nconst MAX_SCROLL_UPDATE_DELAY = 500;\nconst IDLE_DEBOUNCE_DELAY = 200;\n// The amount of time to wait before declaring that the list isn't scrolling\nconst DONE_SCROLLING_WAIT = 500;\nconst DEFAULT_ITEMS_PER_PAGE = 10;\nconst DEFAULT_PAGE_HEIGHT = 30;\nconst DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nconst DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nconst PAGE_KEY_PREFIX = 'page-';\nconst SPACER_KEY_PREFIX = 'spacer-';\n\nexport interface IListState<T = any> {\n  pages?: IPage<T>[];\n\n  /** The last versionstamp for  */\n  measureVersion?: number;\n  isScrolling?: boolean;\n  getDerivedStateFromProps(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T>;\n\n  pagesVersion?: {};\n}\n\ninterface IPageCacheItem<T> {\n  page: IPage<T>;\n  pageElement?: JSX.Element;\n}\n\ninterface IPageCache<T> {\n  [key: string]: IPageCacheItem<T>;\n}\n\nconst EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0,\n};\n\n// Naming expensive measures so that they're named in profiles.\nconst _measurePageRect = (element: HTMLElement) => element.getBoundingClientRect();\nconst _measureSurfaceRect = _measurePageRect;\nconst _measureScrollRect = _measurePageRect;\n\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback\n * if provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if\n * provided by the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time.\n * And we start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\nexport class List<T = any> extends React.Component<IListProps<T>, IListState<T>> implements IList {\n  public static defaultProps = {\n    startIndex: 0,\n    onRenderCell: (item: any, index: number, containsFocus: boolean) => <>{(item && item.name) || ''}</>,\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND,\n  };\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _surface = React.createRef<HTMLDivElement>();\n  private _pageRefs: Record<string, unknown> = {};\n  private _async: Async;\n  private _events: EventGroup;\n  private _estimatedPageHeight: number;\n  private _totalEstimates: number;\n  private _cachedPageHeights: {\n    [key: string]: {\n      height: number;\n      measureVersion: number;\n    };\n  };\n  private _focusedIndex: number;\n  private _scrollElement: HTMLElement;\n  private _hasCompletedFirstRender: boolean;\n\n  // surface rect relative to window\n  private _surfaceRect: IRectangle | undefined;\n\n  // The visible rect that we're required to render given the current list state.\n  private _requiredRect: IRectangle | null;\n\n  // The visible rect that we're allowed to keep rendered. Pages outside of this rect will be removed.\n  private _allowedRect: IRectangle;\n\n  // The rect that is visible to the user\n  private _visibleRect: IRectangle | undefined;\n\n  // materialized rect around visible items, relative to surface\n  private _materializedRect: IRectangle | null;\n\n  private _requiredWindowsAhead: number;\n  private _requiredWindowsBehind: number;\n\n  private _measureVersion: number;\n  private _scrollHeight: number;\n  private _scrollTop: number;\n  private _pageCache: IPageCache<T>;\n\n  public static getDerivedStateFromProps<T = any>(\n    nextProps: IListProps<T>,\n    previousState: IListState<T>,\n  ): IListState<T> {\n    return previousState.getDerivedStateFromProps(nextProps, previousState);\n  }\n\n  constructor(props: IListProps<T>) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      pages: [],\n      isScrolling: false,\n      getDerivedStateFromProps: this._getDerivedStateFromProps,\n    };\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    this._estimatedPageHeight = 0;\n    this._totalEstimates = 0;\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n\n    // Track the measure version for everything.\n    this._measureVersion = 0;\n\n    // Ensure that scrolls are lazy updated.\n    this._onAsyncScroll = this._async.debounce(this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\n      leading: false,\n      maxWait: MAX_SCROLL_UPDATE_DELAY,\n    });\n\n    this._onAsyncIdle = this._async.debounce(this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\n      leading: false,\n    });\n\n    this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n      leading: false,\n    });\n\n    this._onScrollingDone = this._async.debounce(this._onScrollingDone, DONE_SCROLLING_WAIT, {\n      leading: false,\n    });\n\n    this._cachedPageHeights = {};\n    this._estimatedPageHeight = 0;\n    this._focusedIndex = -1;\n    this._pageCache = {};\n  }\n\n  public get pageRefs(): Readonly<Record<string, unknown>> {\n    return this._pageRefs;\n  }\n\n  /**\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\n   *\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\n   *\n   * @param index - Index of item to scroll to\n   * @param measureItem - Optional callback to measure the height of an individual item\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\n   */\n  public scrollToIndex(\n    index: number,\n    measureItem?: (itemIndex: number) => number,\n    scrollToMode: ScrollToMode = ScrollToMode.auto,\n  ): void {\n    const startIndex = this.props.startIndex as number;\n    const renderCount = this._getRenderCount();\n    const endIndex = startIndex + renderCount;\n\n    const allowedRect = this._allowedRect;\n\n    let scrollTop = 0;\n\n    let itemsPerPage = 1;\n    for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      const pageSpecification = this._getPageSpecification(itemIndex, allowedRect);\n\n      const pageHeight = pageSpecification.height;\n      itemsPerPage = pageSpecification.itemCount;\n\n      const requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\n      if (requestedIndexIsInPage) {\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in\n        // just the given item, otherwise we'll only bring the page into view\n        if (measureItem && this._scrollElement) {\n          const scrollRect = _measureScrollRect(this._scrollElement);\n          const scrollWindow = {\n            top: this._scrollElement.scrollTop,\n            bottom: this._scrollElement.scrollTop + scrollRect.height,\n          };\n\n          // Adjust for actual item position within page\n          const itemPositionWithinPage = index - itemIndex;\n          for (let itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\n          }\n          const scrollBottom = scrollTop + measureItem(index);\n\n          // If scrollToMode is set to something other than auto, we always want to\n          // scroll the item into a specific position on the page.\n          switch (scrollToMode) {\n            case ScrollToMode.top:\n              this._scrollElement.scrollTop = scrollTop;\n              return;\n            case ScrollToMode.bottom:\n              this._scrollElement.scrollTop = scrollBottom - scrollRect.height;\n              return;\n            case ScrollToMode.center:\n              this._scrollElement.scrollTop = (scrollTop + scrollBottom - scrollRect.height) / 2;\n              return;\n            case ScrollToMode.auto:\n            default:\n              break;\n          }\n\n          const itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\n          if (itemIsFullyVisible) {\n            // Item is already visible, do nothing.\n            return;\n          }\n\n          const itemIsPartiallyAbove = scrollTop < scrollWindow.top;\n          const itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\n\n          if (itemIsPartiallyAbove) {\n            //  We will just scroll to 'scrollTop'\n            //  .------.   - scrollTop\n            //  |Item  |\n            //  | .----|-. - scrollWindow.top\n            //  '------' |\n            //    |      |\n            //    '------'\n          } else if (itemIsPartiallyBelow) {\n            //  Adjust scrollTop position to just bring in the element\n            // .------.  - scrollTop\n            // |      |\n            // | .------.\n            // '-|----' | - scrollWindow.bottom\n            //   | Item |\n            //   '------' - scrollBottom\n            scrollTop = scrollBottom - scrollRect.height;\n          }\n        }\n\n        this._scrollElement.scrollTop = scrollTop;\n        return;\n      }\n\n      scrollTop += pageHeight;\n    }\n  }\n\n  public getStartItemIndexInView(measureItem?: (itemIndex: number) => number): number {\n    const pages = this.state.pages || [];\n    for (const page of pages) {\n      const isPageVisible =\n        !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\n      if (isPageVisible) {\n        if (!measureItem) {\n          const rowHeight = Math.floor(page.height / page.itemCount);\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\n        } else {\n          let totalRowHeight = 0;\n          for (let itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\n            const rowHeight = measureItem(itemIndex);\n            if (\n              page.top + totalRowHeight <= this._scrollTop &&\n              this._scrollTop < page.top + totalRowHeight + rowHeight\n            ) {\n              return itemIndex;\n            } else {\n              totalRowHeight += rowHeight;\n            }\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n  public componentDidMount(): void {\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n    this._scrollElement = findScrollableParent(this._root.current) as HTMLElement;\n\n    this._events.on(window, 'resize', this._onAsyncResize);\n    if (this._root.current) {\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\n    }\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);\n    }\n  }\n\n  public componentDidUpdate(previousProps: IListProps, previousState: IListState<T>): void {\n    const finalProps = this.props;\n    const finalState = this.state;\n\n    if (this.state.pagesVersion !== previousState.pagesVersion) {\n      // If we weren't provided with the page height, measure the pages\n      if (!finalProps.getPageHeight) {\n        // If measured version is invalid since we've updated the DOM\n        const heightsChanged = this._updatePageMeasurements(finalState.pages!);\n\n        // On first render, we should re-measure so that we don't get a visual glitch.\n        if (heightsChanged) {\n          this._materializedRect = null;\n          if (!this._hasCompletedFirstRender) {\n            this._hasCompletedFirstRender = true;\n            this.setState(this._updatePages(finalProps, finalState));\n          } else {\n            this._onAsyncScroll();\n          }\n        } else {\n          // Enqueue an idle bump.\n          this._onAsyncIdle();\n        }\n      } else {\n        // Enqueue an idle bump\n        this._onAsyncIdle();\n      }\n\n      // Notify the caller that rendering the new pages has completed\n      if (finalProps.onPagesUpdated) {\n        finalProps.onPagesUpdated(finalState.pages as IPage<T>[]);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n\n    delete this._scrollElement;\n  }\n\n  public shouldComponentUpdate(newProps: IListProps<T>, newState: IListState<T>): boolean {\n    const { pages: oldPages } = this.state;\n    const { pages: newPages } = newState;\n    let shouldComponentUpdate = false;\n\n    // Update if the page stops scrolling\n    if (!newState.isScrolling && this.state.isScrolling) {\n      return true;\n    }\n\n    if (newProps.version !== this.props.version) {\n      return true;\n    }\n\n    if (newProps.items === this.props.items && oldPages!.length === newPages!.length) {\n      for (let i = 0; i < oldPages!.length; i++) {\n        const oldPage = oldPages![i];\n        const newPage = newPages![i];\n\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n\n    return shouldComponentUpdate;\n  }\n\n  public forceUpdate(): void {\n    this._invalidatePageCache();\n    // Ensure that when the list is force updated we update the pages first before render.\n    this._updateRenderRects(this.props, this.state, true);\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n\n    super.forceUpdate();\n  }\n\n  /**\n   * Get the current height the list and it's pages.\n   */\n  public getTotalListHeight(): number {\n    return this._surfaceRect!.height;\n  }\n\n  public render(): JSX.Element | null {\n    const { className, role = 'list', onRenderSurface, onRenderRoot } = this.props;\n    const { pages = [] } = this.state;\n    const pageElements: JSX.Element[] = [];\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    for (const page of pages) {\n      pageElements.push(this._renderPage(page));\n    }\n\n    const finalOnRenderSurface = onRenderSurface\n      ? composeRenderFunction(onRenderSurface, this._onRenderSurface)\n      : this._onRenderSurface;\n\n    const finalOnRenderRoot = onRenderRoot\n      ? composeRenderFunction(onRenderRoot, this._onRenderRoot)\n      : this._onRenderRoot;\n\n    return finalOnRenderRoot({\n      rootRef: this._root,\n      pages,\n      surfaceElement: finalOnRenderSurface({\n        surfaceRef: this._surface,\n        pages,\n        pageElements,\n        divProps: {\n          role: 'presentation',\n          className: 'ms-List-surface',\n        },\n      }),\n      divProps: {\n        ...divProps,\n        className: css('ms-List', className),\n        role: pageElements.length > 0 ? role : undefined,\n      },\n    });\n  }\n\n  private _getDerivedStateFromProps = (nextProps: IListProps<T>, previousState: IListState<T>): IListState<T> => {\n    if (\n      nextProps.items !== this.props.items ||\n      nextProps.renderCount !== this.props.renderCount ||\n      nextProps.startIndex !== this.props.startIndex ||\n      nextProps.version !== this.props.version\n    ) {\n      // We have received new items so we want to make sure that initially we only render a single window to\n      // fill the currently visible rect, and then later render additional windows.\n      this._resetRequiredWindows();\n      this._requiredRect = null;\n\n      this._measureVersion++;\n      this._invalidatePageCache();\n\n      return this._updatePages(nextProps, previousState);\n    }\n\n    return previousState;\n  };\n\n  private _shouldVirtualize(props: IListProps<T> = this.props): boolean {\n    const { onShouldVirtualize } = props;\n    return !onShouldVirtualize || onShouldVirtualize(props);\n  }\n\n  /**\n   * when props.items change or forceUpdate called, throw away cached pages\n   */\n  private _invalidatePageCache(): void {\n    this._pageCache = {};\n  }\n\n  private _renderPage(page: IPage<T>): JSX.Element {\n    const { usePageCache } = this.props;\n    let cachedPage;\n    // if usePageCache is set and cached page element can be found, just return cached page\n    if (usePageCache) {\n      cachedPage = this._pageCache[page.key];\n      if (cachedPage && cachedPage.pageElement) {\n        return cachedPage.pageElement;\n      }\n    }\n\n    const pageStyle = this._getPageStyle(page);\n\n    const { onRenderPage = this._onRenderPage } = this.props;\n\n    const pageElement = onRenderPage(\n      {\n        page: page,\n        className: 'ms-List-page',\n        key: page.key,\n        ref: (newRef: unknown) => {\n          this._pageRefs[page.key] = newRef;\n        },\n        style: pageStyle,\n        role: 'presentation',\n      },\n      this._onRenderPage,\n    );\n\n    // cache the first page for now since it is re-rendered a lot times unnecessarily.\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\n    if (usePageCache && page.startIndex === 0) {\n      this._pageCache[page.key] = {\n        page: page,\n        pageElement: pageElement,\n      };\n    }\n    return pageElement;\n  }\n\n  private _onRenderRoot = (props: IListOnRenderRootProps<T>): JSX.Element => {\n    const { rootRef, surfaceElement, divProps } = props;\n\n    return (\n      <div ref={rootRef} {...divProps}>\n        {surfaceElement}\n      </div>\n    );\n  };\n\n  private _onRenderSurface = (props: IListOnRenderSurfaceProps<T>): JSX.Element => {\n    const { surfaceRef, pageElements, divProps } = props;\n\n    return (\n      <div ref={surfaceRef} {...divProps}>\n        {pageElements}\n      </div>\n    );\n  };\n\n  /** Generate the style object for the page. */\n  private _getPageStyle(page: IPage<T>): React.StyleHTMLAttributes<HTMLDivElement> {\n    const { getPageStyle } = this.props;\n\n    return {\n      ...(getPageStyle ? getPageStyle(page) : {}),\n      ...(!page.items\n        ? {\n            height: page.height,\n          }\n        : {}),\n    };\n  }\n\n  private _onRenderPage = (pageProps: IPageProps<T>, defaultRender?: IRenderFunction<IPageProps<T>>): any => {\n    const { onRenderCell, role } = this.props;\n\n    const {\n      page: { items = [], startIndex },\n      ...divProps\n    } = pageProps;\n\n    // only assign list item role if no role is assigned\n    const cellRole = role === undefined ? 'listitem' : 'presentation';\n    const cells: React.ReactNode[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const index = startIndex + i;\n      const item = items[i];\n\n      let itemKey = this.props.getKey ? this.props.getKey(item, index) : item && (item as any).key;\n\n      if (itemKey === null || itemKey === undefined) {\n        itemKey = index;\n      }\n\n      cells.push(\n        <div\n          role={cellRole}\n          className={'ms-List-cell'}\n          key={itemKey}\n          data-list-index={index}\n          data-automationid=\"ListCell\"\n        >\n          {onRenderCell &&\n            onRenderCell(item, index, !this.props.ignoreScrollingState ? this.state.isScrolling : undefined)}\n        </div>,\n      );\n    }\n\n    return <div {...divProps}>{cells}</div>;\n  };\n\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n  private _onFocus(ev: any): void {\n    let target = ev.target as HTMLElement;\n\n    while (target !== this._surface.current) {\n      const indexString = target.getAttribute('data-list-index');\n\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  }\n\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n  private _onScroll(): void {\n    if (!this.state.isScrolling && !this.props.ignoreScrollingState) {\n      this.setState({ isScrolling: true });\n    }\n    this._resetRequiredWindows();\n    this._onScrollingDone();\n  }\n\n  private _resetRequiredWindows(): void {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  }\n\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n  private _onAsyncScroll(): void {\n    this._updateRenderRects(this.props, this.state);\n\n    // Only update pages when the visible rect falls outside of the materialized rect.\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect as IRectangle, this._materializedRect)) {\n      this.setState(this._updatePages(this.props, this.state));\n    } else {\n      // console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  }\n\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n  private _onAsyncIdle(): void {\n    const { renderedWindowsAhead, renderedWindowsBehind } = this.props;\n    const { _requiredWindowsAhead: requiredWindowsAhead, _requiredWindowsBehind: requiredWindowsBehind } = this;\n    const windowsAhead = Math.min(renderedWindowsAhead as number, requiredWindowsAhead + 1);\n    const windowsBehind = Math.min(renderedWindowsBehind as number, requiredWindowsBehind + 1);\n\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n      // console.log('idling', windowsBehind, windowsAhead);\n\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n      this._updateRenderRects(this.props, this.state);\n      this.setState(this._updatePages(this.props, this.state));\n    }\n\n    if (renderedWindowsAhead! > windowsAhead || renderedWindowsBehind! > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdle();\n    }\n  }\n\n  /**\n   * Function to call when the list is done scrolling.\n   * This function is debounced.\n   */\n  private _onScrollingDone(): void {\n    if (!this.props.ignoreScrollingState) {\n      this.setState({ isScrolling: false });\n    }\n  }\n\n  private _onAsyncResize(): void {\n    this.forceUpdate();\n  }\n\n  private _updatePages(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T> {\n    // console.log('updating pages');\n\n    if (!this._requiredRect) {\n      this._updateRenderRects(nextProps, previousState);\n    }\n\n    const newListState = this._buildPages(nextProps, previousState);\n    const oldListPages = previousState.pages!;\n\n    this._notifyPageChanges(oldListPages, newListState.pages!, this.props);\n\n    return {\n      ...previousState,\n      ...newListState,\n      pagesVersion: {},\n    };\n  }\n\n  /**\n   * Notify consumers that the rendered pages have changed\n   * @param oldPages - The old pages\n   * @param newPages - The new pages\n   * @param props - The props to use\n   */\n  private _notifyPageChanges(oldPages: IPage<T>[], newPages: IPage<T>[], props: IListProps<T>): void {\n    const { onPageAdded, onPageRemoved } = props;\n\n    if (onPageAdded || onPageRemoved) {\n      const renderedIndexes: {\n        [index: number]: IPage<T>;\n      } = {};\n\n      for (const page of oldPages) {\n        if (page.items) {\n          renderedIndexes[page.startIndex] = page;\n        }\n      }\n\n      for (const page of newPages) {\n        if (page.items) {\n          if (!renderedIndexes[page.startIndex]) {\n            this._onPageAdded(page);\n          } else {\n            delete renderedIndexes[page.startIndex];\n          }\n        }\n      }\n\n      for (const index in renderedIndexes) {\n        if (renderedIndexes.hasOwnProperty(index)) {\n          this._onPageRemoved(renderedIndexes[index]);\n        }\n      }\n    }\n  }\n\n  private _updatePageMeasurements(pages: IPage<T>[]): boolean {\n    let heightChanged = false;\n\n    // when not in virtualize mode, we render all the items without page measurement\n    if (!this._shouldVirtualize()) {\n      return heightChanged;\n    }\n\n    for (let i = 0; i < pages.length; i++) {\n      const page = pages[i];\n\n      if (page.items) {\n        heightChanged = this._measurePage(page) || heightChanged;\n      }\n    }\n\n    return heightChanged;\n  }\n\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n  private _measurePage(page: IPage<T>): boolean {\n    let hasChangedHeight = false;\n    const pageElement = this._pageRefs[page.key] as HTMLElement;\n    const cachedHeight = this._cachedPageHeights[page.startIndex];\n\n    // console.log('   * measure attempt', page.startIndex, cachedHeight);\n\n    if (\n      pageElement &&\n      this._shouldVirtualize() &&\n      (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)\n    ) {\n      const newClientRect = {\n        width: pageElement.clientWidth,\n        height: pageElement.clientHeight,\n      };\n\n      if (newClientRect.height || newClientRect.width) {\n        hasChangedHeight = page.height !== newClientRect.height;\n\n        // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n\n        page.height = newClientRect.height;\n\n        this._cachedPageHeights[page.startIndex] = {\n          height: newClientRect.height,\n          measureVersion: this._measureVersion,\n        };\n\n        this._estimatedPageHeight = Math.round(\n          (this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1),\n        );\n\n        this._totalEstimates++;\n      }\n    }\n\n    return hasChangedHeight;\n  }\n\n  /** Called when a page has been added to the DOM. */\n  private _onPageAdded(page: IPage<T>): void {\n    const { onPageAdded } = this.props;\n\n    // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  }\n\n  /** Called when a page has been removed from the DOM. */\n  private _onPageRemoved(page: IPage<T>): void {\n    const { onPageRemoved } = this.props;\n\n    // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  }\n\n  /** Build up the pages that should be rendered. */\n  private _buildPages(props: IListProps<T>, state: IListState<T>): IListState<T> {\n    let { renderCount } = props;\n    const { items, startIndex, getPageHeight } = props;\n\n    renderCount = this._getRenderCount(props);\n\n    const materializedRect = { ...EMPTY_RECT };\n    const pages: IPage<T>[] = [];\n\n    let itemsPerPage = 1;\n    let pageTop = 0;\n    let currentSpacer = null;\n    const focusedIndex = this._focusedIndex;\n    const endIndex = startIndex! + renderCount;\n    const shouldVirtualize = this._shouldVirtualize(props);\n\n    // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n    const isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\n\n    const allowedRect = this._allowedRect;\n\n    for (let itemIndex = startIndex!; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      const pageSpecification = this._getPageSpecification(itemIndex, allowedRect);\n      const pageHeight = pageSpecification.height;\n      const pageData = pageSpecification.data;\n      const key = pageSpecification.key;\n\n      itemsPerPage = pageSpecification.itemCount;\n\n      const pageBottom = pageTop + pageHeight - 1;\n\n      const isPageRendered =\n        findIndex(state.pages as IPage<T>[], (page: IPage<T>) => !!page.items && page.startIndex === itemIndex) > -1;\n      const isPageInAllowedRange = !allowedRect || (pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom!);\n      const isPageInRequiredRange =\n        !this._requiredRect || (pageBottom >= this._requiredRect.top && pageTop <= this._requiredRect.bottom!);\n      const isPageVisible =\n        (!isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered))) || !shouldVirtualize;\n      const isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\n      const isFirstPage = itemIndex === startIndex;\n\n      // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' +\n      // isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);\n\n      // Only render whats visible, focused, or first page,\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n\n        const itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n        const newPage = this._createPage(\n          key,\n          items!.slice(itemIndex, itemIndex + itemsInPage),\n          itemIndex,\n          undefined,\n          undefined,\n          pageData,\n        );\n\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n        if (this._visibleRect && this._visibleRect.bottom) {\n          newPage.isVisible = pageBottom >= this._visibleRect.top && pageTop <= this._visibleRect.bottom;\n        }\n\n        pages.push(newPage);\n\n        if (isPageInRequiredRange && this._allowedRect) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: allowedRect.left,\n            right: allowedRect.right,\n            width: allowedRect.width,\n          });\n        }\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this._createPage(\n            SPACER_KEY_PREFIX + itemIndex,\n            undefined,\n            itemIndex,\n            0,\n            undefined,\n            pageData,\n            true /*isSpacer*/,\n          );\n        }\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n      pageTop += pageBottom - pageTop + 1;\n\n      // in virtualized mode, we render need to render first page then break and measure,\n      // otherwise, we render all items without measurement to make rendering fast\n      if (isFirstRender && shouldVirtualize) {\n        break;\n      }\n    }\n\n    if (currentSpacer) {\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\n      pages.push(currentSpacer);\n    }\n\n    this._materializedRect = materializedRect;\n\n    // console.log('materialized: ', materializedRect);\n    return {\n      ...state,\n      pages: pages,\n      measureVersion: this._measureVersion,\n    };\n  }\n\n  private _getPageSpecification(\n    itemIndex: number,\n    visibleRect: IRectangle,\n  ): {\n    // These return values are now no longer optional.\n    itemCount: number;\n    height: number;\n    data?: any;\n    key?: string;\n  } {\n    const { getPageSpecification } = this.props;\n    if (getPageSpecification) {\n      const pageData = getPageSpecification(itemIndex, visibleRect);\n\n      const { itemCount = this._getItemCountForPage(itemIndex, visibleRect) } = pageData;\n\n      const { height = this._getPageHeight(itemIndex, visibleRect, itemCount) } = pageData;\n\n      return {\n        itemCount: itemCount,\n        height: height,\n        data: pageData.data,\n        key: pageData.key,\n      };\n    } else {\n      const itemCount = this._getItemCountForPage(itemIndex, visibleRect);\n\n      return {\n        itemCount: itemCount,\n        height: this._getPageHeight(itemIndex, visibleRect, itemCount),\n      };\n    }\n  }\n\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n  private _getPageHeight(itemIndex: number, visibleRect: IRectangle, itemsPerPage: number): number {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage);\n    } else {\n      const cachedHeight = this._cachedPageHeights[itemIndex];\n\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\n    }\n  }\n\n  private _getItemCountForPage(itemIndex: number, visibileRect: IRectangle): number {\n    const itemsPerPage = this.props.getItemCountForPage\n      ? this.props.getItemCountForPage(itemIndex, visibileRect)\n      : DEFAULT_ITEMS_PER_PAGE;\n\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  }\n\n  private _createPage(\n    pageKey: string | undefined,\n    items: any[] | undefined,\n    startIndex: number = -1,\n    count: number = items ? items.length : 0,\n    style: React.CSSProperties = {},\n    data?: any,\n    isSpacer?: boolean,\n  ): IPage<T> {\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\n    const cachedPage = this._pageCache[pageKey];\n    if (cachedPage && cachedPage.page) {\n      return cachedPage.page;\n    }\n\n    return {\n      key: pageKey,\n      startIndex: startIndex,\n      itemCount: count,\n      items: items,\n      style: style,\n      top: 0,\n      height: 0,\n      data: data,\n      isSpacer: isSpacer || false,\n    };\n  }\n\n  private _getRenderCount(props?: IListProps<T>): number {\n    const { items, startIndex, renderCount } = props || this.props;\n\n    return renderCount === undefined ? (items ? items.length - startIndex! : 0) : renderCount;\n  }\n\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n  private _updateRenderRects(props: IListProps<T>, state: IListState<T>, forceUpdate?: boolean): void {\n    const { renderedWindowsAhead, renderedWindowsBehind } = props;\n    const { pages } = state;\n    // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\n    if (!this._shouldVirtualize(props)) {\n      return;\n    }\n\n    let surfaceRect = this._surfaceRect || { ...EMPTY_RECT };\n    const scrollHeight = this._scrollElement && this._scrollElement.scrollHeight;\n    const scrollTop = this._scrollElement ? this._scrollElement.scrollTop : 0;\n\n    // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    // This needs to be called to recalculate when new pages should be loaded.\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\n    if (\n      this._surface.current &&\n      (forceUpdate ||\n        !pages ||\n        !this._surfaceRect ||\n        !scrollHeight ||\n        scrollHeight !== this._scrollHeight ||\n        Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)\n    ) {\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\n      this._scrollTop = scrollTop;\n    }\n\n    // If the scroll height has changed, something in the container likely resized and\n    // we should redo the page heights incase their content resized.\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\n      this._measureVersion++;\n    }\n\n    this._scrollHeight = scrollHeight;\n\n    // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n    const visibleTop = Math.max(0, -surfaceRect.top);\n    const win = getWindow(this._root.current);\n    const visibleRect = {\n      top: visibleTop,\n      left: surfaceRect.left,\n      bottom: visibleTop + win!.innerHeight,\n      right: surfaceRect.right,\n      width: surfaceRect.width,\n      height: win!.innerHeight,\n    };\n\n    // The required/allowed rects are adjusted versions of the visible rect.\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind!, renderedWindowsAhead!);\n\n    // store the visible rect for later use.\n    this._visibleRect = visibleRect;\n  }\n}\n\nfunction _expandRect(rect: IRectangle, pagesBefore: number, pagesAfter: number): IRectangle {\n  const top = rect.top - pagesBefore * rect.height;\n  const height = rect.height + (pagesBefore + pagesAfter) * rect.height;\n\n  return {\n    top: top,\n    bottom: top + height,\n    height: height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width,\n  };\n}\n\nfunction _isContainedWithin(innerRect: IRectangle, outerRect: IRectangle): boolean {\n  return (\n    innerRect.top >= outerRect.top &&\n    innerRect.left >= outerRect.left &&\n    innerRect.bottom! <= outerRect.bottom! &&\n    innerRect.right! <= outerRect.right!\n  );\n}\n\nfunction _mergeRect(targetRect: IRectangle, newRect: IRectangle): IRectangle {\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\n  targetRect.bottom =\n    newRect.bottom! > targetRect.bottom! || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\n  targetRect.right = newRect.right! > targetRect.right! || targetRect.right === -1 ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right! - targetRect.left + 1;\n  targetRect.height = targetRect.bottom! - targetRect.top + 1;\n\n  return targetRect;\n}\n"]},"metadata":{},"sourceType":"module"}