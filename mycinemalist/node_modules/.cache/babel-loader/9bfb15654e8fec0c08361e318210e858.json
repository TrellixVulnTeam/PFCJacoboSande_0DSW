{"ast":null,"code":"import { EventGroup } from './EventGroup';\nimport { findScrollableParent } from './scroll';\nimport { getRect } from './dom/getRect';\nvar SCROLL_ITERATION_DELAY = 16;\nvar SCROLL_GUTTER = 100;\nvar MAX_SCROLL_VELOCITY = 15;\n/**\n * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container\n * up/down depending on how close the mouse is to the top/bottom of the container.\n *\n * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.\n *\n * @public\n * {@docCategory AutoScroll}\n */\n\nvar AutoScroll =\n/** @class */\nfunction () {\n  function AutoScroll(element) {\n    this._events = new EventGroup(this);\n    this._scrollableParent = findScrollableParent(element);\n    this._incrementScroll = this._incrementScroll.bind(this);\n    this._scrollRect = getRect(this._scrollableParent); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    if (this._scrollableParent === window) {\n      this._scrollableParent = document.body;\n    }\n\n    if (this._scrollableParent) {\n      this._events.on(window, 'mousemove', this._onMouseMove, true);\n\n      this._events.on(window, 'touchmove', this._onTouchMove, true);\n    }\n  }\n\n  AutoScroll.prototype.dispose = function () {\n    this._events.dispose();\n\n    this._stopScroll();\n  };\n\n  AutoScroll.prototype._onMouseMove = function (ev) {\n    this._computeScrollVelocity(ev);\n  };\n\n  AutoScroll.prototype._onTouchMove = function (ev) {\n    if (ev.touches.length > 0) {\n      this._computeScrollVelocity(ev);\n    }\n  };\n\n  AutoScroll.prototype._computeScrollVelocity = function (ev) {\n    if (!this._scrollRect) {\n      return;\n    }\n\n    var clientX;\n    var clientY;\n\n    if ('clientX' in ev) {\n      clientX = ev.clientX;\n      clientY = ev.clientY;\n    } else {\n      clientX = ev.touches[0].clientX;\n      clientY = ev.touches[0].clientY;\n    }\n\n    var scrollRectTop = this._scrollRect.top;\n    var scrollRectLeft = this._scrollRect.left;\n    var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;\n    var scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER; // variables to use for alternating scroll direction\n\n    var scrollRect;\n    var clientDirection;\n    var scrollClient; // if either of these conditions are met we are scrolling vertically else horizontally\n\n    if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {\n      clientDirection = clientY;\n      scrollRect = scrollRectTop;\n      scrollClient = scrollClientBottom;\n      this._isVerticalScroll = true;\n    } else {\n      clientDirection = clientX;\n      scrollRect = scrollRectLeft;\n      scrollClient = scrollClientRight;\n      this._isVerticalScroll = false;\n    } // calculate scroll velocity and direction\n\n\n    if (clientDirection < scrollRect + SCROLL_GUTTER) {\n      this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER));\n    } else if (clientDirection > scrollClient) {\n      this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER));\n    } else {\n      this._scrollVelocity = 0;\n    }\n\n    if (this._scrollVelocity) {\n      this._startScroll();\n    } else {\n      this._stopScroll();\n    }\n  };\n\n  AutoScroll.prototype._startScroll = function () {\n    if (!this._timeoutId) {\n      this._incrementScroll();\n    }\n  };\n\n  AutoScroll.prototype._incrementScroll = function () {\n    if (this._scrollableParent) {\n      if (this._isVerticalScroll) {\n        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);\n      } else {\n        this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);\n      }\n    }\n\n    this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);\n  };\n\n  AutoScroll.prototype._stopScroll = function () {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      delete this._timeoutId;\n    }\n  };\n\n  return AutoScroll;\n}();\n\nexport { AutoScroll };","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AACA,SAASC,oBAAT,QAAqC,UAArC;AACA,SAASC,OAAT,QAAwB,eAAxB;AAKA,IAAMC,sBAAsB,GAAG,EAA/B;AACA,IAAMC,aAAa,GAAG,GAAtB;AACA,IAAMC,mBAAmB,GAAG,EAA5B;AAEA;;;;;;;;;;AASA;AAAA;AAAA;AAQE,sBAAYC,OAAZ,EAAgC;AAC9B,SAAKC,OAAL,GAAe,IAAIP,UAAJ,CAAe,IAAf,CAAf;AACA,SAAKQ,iBAAL,GAAyBP,oBAAoB,CAACK,OAAD,CAA7C;AAEA,SAAKG,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBC,IAAtB,CAA2B,IAA3B,CAAxB;AACA,SAAKC,WAAL,GAAmBT,OAAO,CAAC,KAAKM,iBAAN,CAA1B,CAL8B,CAO9B;;AACA,QAAI,KAAKA,iBAAL,KAA4BI,MAAhC,EAAgD;AAC9C,WAAKJ,iBAAL,GAAyBK,QAAQ,CAACC,IAAlC;AACD;;AAED,QAAI,KAAKN,iBAAT,EAA4B;AAC1B,WAAKD,OAAL,CAAaQ,EAAb,CAAgBH,MAAhB,EAAwB,WAAxB,EAAqC,KAAKI,YAA1C,EAAwD,IAAxD;;AACA,WAAKT,OAAL,CAAaQ,EAAb,CAAgBH,MAAhB,EAAwB,WAAxB,EAAqC,KAAKK,YAA1C,EAAwD,IAAxD;AACD;AACF;;AAEMC,iCAAP;AACE,SAAKX,OAAL,CAAaY,OAAb;;AACA,SAAKC,WAAL;AACD,GAHM;;AAKCF,sCAAR,UAAqBG,EAArB,EAAmC;AACjC,SAAKC,sBAAL,CAA4BD,EAA5B;AACD,GAFO;;AAIAH,sCAAR,UAAqBG,EAArB,EAAmC;AACjC,QAAIA,EAAE,CAACE,OAAH,CAAWC,MAAX,GAAoB,CAAxB,EAA2B;AACzB,WAAKF,sBAAL,CAA4BD,EAA5B;AACD;AACF,GAJO;;AAMAH,gDAAR,UAA+BG,EAA/B,EAA0D;AACxD,QAAI,CAAC,KAAKV,WAAV,EAAuB;AACrB;AACD;;AAED,QAAIc,OAAJ;AACA,QAAIC,OAAJ;;AACA,QAAI,aAAaL,EAAjB,EAAqB;AACnBI,aAAO,GAAGJ,EAAE,CAACI,OAAb;AACAC,aAAO,GAAGL,EAAE,CAACK,OAAb;AACD,KAHD,MAGO;AACLD,aAAO,GAAGJ,EAAE,CAACE,OAAH,CAAW,CAAX,EAAcE,OAAxB;AACAC,aAAO,GAAGL,EAAE,CAACE,OAAH,CAAW,CAAX,EAAcG,OAAxB;AACD;;AAED,QAAIC,aAAa,GAAG,KAAKhB,WAAL,CAAiBiB,GAArC;AACA,QAAIC,cAAc,GAAG,KAAKlB,WAAL,CAAiBmB,IAAtC;AACA,QAAIC,kBAAkB,GAAGJ,aAAa,GAAG,KAAKhB,WAAL,CAAiBqB,MAAjC,GAA0C5B,aAAnE;AACA,QAAI6B,iBAAiB,GAAGJ,cAAc,GAAG,KAAKlB,WAAL,CAAiBuB,KAAlC,GAA0C9B,aAAlE,CAlBwD,CAoBxD;;AACA,QAAI+B,UAAJ;AACA,QAAIC,eAAJ;AACA,QAAIC,YAAJ,CAvBwD,CAyBxD;;AACA,QAAIX,OAAO,GAAGC,aAAa,GAAGvB,aAA1B,IAA2CsB,OAAO,GAAGK,kBAAzD,EAA6E;AAC3EK,qBAAe,GAAGV,OAAlB;AACAS,gBAAU,GAAGR,aAAb;AACAU,kBAAY,GAAGN,kBAAf;AACA,WAAKO,iBAAL,GAAyB,IAAzB;AACD,KALD,MAKO;AACLF,qBAAe,GAAGX,OAAlB;AACAU,gBAAU,GAAGN,cAAb;AACAQ,kBAAY,GAAGJ,iBAAf;AACA,WAAKK,iBAAL,GAAyB,KAAzB;AACD,KApCuD,CAsCxD;;;AACA,QAAIF,eAAgB,GAAGD,UAAU,GAAG/B,aAApC,EAAmD;AACjD,WAAKmC,eAAL,GAAuBC,IAAI,CAACC,GAAL,CACrB,CAACpC,mBADoB,EAErB,CAACA,mBAAD,IAAwB,CAACD,aAAa,IAAIgC,eAAe,GAAGD,UAAtB,CAAd,IAAmD/B,aAA3E,CAFqB,CAAvB;AAID,KALD,MAKO,IAAIgC,eAAe,GAAGC,YAAtB,EAAoC;AACzC,WAAKE,eAAL,GAAuBC,IAAI,CAACE,GAAL,CACrBrC,mBADqB,EAErBA,mBAAmB,IAAI,CAAC+B,eAAe,GAAGC,YAAnB,IAAmCjC,aAAvC,CAFE,CAAvB;AAID,KALM,MAKA;AACL,WAAKmC,eAAL,GAAuB,CAAvB;AACD;;AAED,QAAI,KAAKA,eAAT,EAA0B;AACxB,WAAKI,YAAL;AACD,KAFD,MAEO;AACL,WAAKvB,WAAL;AACD;AACF,GA1DO;;AA4DAF,sCAAR;AACE,QAAI,CAAC,KAAK0B,UAAV,EAAsB;AACpB,WAAKnC,gBAAL;AACD;AACF,GAJO;;AAMAS,0CAAR;AACE,QAAI,KAAKV,iBAAT,EAA4B;AAC1B,UAAI,KAAK8B,iBAAT,EAA4B;AAC1B,aAAK9B,iBAAL,CAAuBqC,SAAvB,IAAoCL,IAAI,CAACM,KAAL,CAAW,KAAKP,eAAhB,CAApC;AACD,OAFD,MAEO;AACL,aAAK/B,iBAAL,CAAuBuC,UAAvB,IAAqCP,IAAI,CAACM,KAAL,CAAW,KAAKP,eAAhB,CAArC;AACD;AACF;;AAED,SAAKK,UAAL,GAAkBI,UAAU,CAAC,KAAKvC,gBAAN,EAAwBN,sBAAxB,CAA5B;AACD,GAVO;;AAYAe,qCAAR;AACE,QAAI,KAAK0B,UAAT,EAAqB;AACnBK,kBAAY,CAAC,KAAKL,UAAN,CAAZ;AACA,aAAO,KAAKA,UAAZ;AACD;AACF,GALO;;AAMV;AAAC,CA7HD","names":["EventGroup","findScrollableParent","getRect","SCROLL_ITERATION_DELAY","SCROLL_GUTTER","MAX_SCROLL_VELOCITY","element","_events","_scrollableParent","_incrementScroll","bind","_scrollRect","window","document","body","on","_onMouseMove","_onTouchMove","AutoScroll","dispose","_stopScroll","ev","_computeScrollVelocity","touches","length","clientX","clientY","scrollRectTop","top","scrollRectLeft","left","scrollClientBottom","height","scrollClientRight","width","scrollRect","clientDirection","scrollClient","_isVerticalScroll","_scrollVelocity","Math","max","min","_startScroll","_timeoutId","scrollTop","round","scrollLeft","setTimeout","clearTimeout"],"sources":["D:\\PFCJACOBO\\PFC\\mycinemalist\\node_modules\\@uifabric\\utilities\\src\\AutoScroll.ts"],"sourcesContent":["import { EventGroup } from './EventGroup';\nimport { findScrollableParent } from './scroll';\nimport { getRect } from './dom/getRect';\nimport { IRectangle } from './IRectangle';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\n\nconst SCROLL_ITERATION_DELAY = 16;\nconst SCROLL_GUTTER = 100;\nconst MAX_SCROLL_VELOCITY = 15;\n\n/**\n * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container\n * up/down depending on how close the mouse is to the top/bottom of the container.\n *\n * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.\n *\n * @public\n * {@docCategory AutoScroll}\n */\nexport class AutoScroll {\n  private _events: EventGroup;\n  private _scrollableParent: HTMLElement | null;\n  private _scrollRect: IRectangle | undefined;\n  private _scrollVelocity: number;\n  private _isVerticalScroll: boolean;\n  private _timeoutId: number;\n\n  constructor(element: HTMLElement) {\n    this._events = new EventGroup(this);\n    this._scrollableParent = findScrollableParent(element) as HTMLElement;\n\n    this._incrementScroll = this._incrementScroll.bind(this);\n    this._scrollRect = getRect(this._scrollableParent);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (this._scrollableParent === (window as any)) {\n      this._scrollableParent = document.body;\n    }\n\n    if (this._scrollableParent) {\n      this._events.on(window, 'mousemove', this._onMouseMove, true);\n      this._events.on(window, 'touchmove', this._onTouchMove, true);\n    }\n  }\n\n  public dispose(): void {\n    this._events.dispose();\n    this._stopScroll();\n  }\n\n  private _onMouseMove(ev: MouseEvent): void {\n    this._computeScrollVelocity(ev);\n  }\n\n  private _onTouchMove(ev: TouchEvent): void {\n    if (ev.touches.length > 0) {\n      this._computeScrollVelocity(ev);\n    }\n  }\n\n  private _computeScrollVelocity(ev: MouseEvent | TouchEvent): void {\n    if (!this._scrollRect) {\n      return;\n    }\n\n    let clientX: number;\n    let clientY: number;\n    if ('clientX' in ev) {\n      clientX = ev.clientX;\n      clientY = ev.clientY;\n    } else {\n      clientX = ev.touches[0].clientX;\n      clientY = ev.touches[0].clientY;\n    }\n\n    let scrollRectTop = this._scrollRect.top;\n    let scrollRectLeft = this._scrollRect.left;\n    let scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;\n    let scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;\n\n    // variables to use for alternating scroll direction\n    let scrollRect;\n    let clientDirection;\n    let scrollClient;\n\n    // if either of these conditions are met we are scrolling vertically else horizontally\n    if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {\n      clientDirection = clientY;\n      scrollRect = scrollRectTop;\n      scrollClient = scrollClientBottom;\n      this._isVerticalScroll = true;\n    } else {\n      clientDirection = clientX;\n      scrollRect = scrollRectLeft;\n      scrollClient = scrollClientRight;\n      this._isVerticalScroll = false;\n    }\n\n    // calculate scroll velocity and direction\n    if (clientDirection! < scrollRect + SCROLL_GUTTER) {\n      this._scrollVelocity = Math.max(\n        -MAX_SCROLL_VELOCITY,\n        -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER),\n      );\n    } else if (clientDirection > scrollClient) {\n      this._scrollVelocity = Math.min(\n        MAX_SCROLL_VELOCITY,\n        MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER),\n      );\n    } else {\n      this._scrollVelocity = 0;\n    }\n\n    if (this._scrollVelocity) {\n      this._startScroll();\n    } else {\n      this._stopScroll();\n    }\n  }\n\n  private _startScroll(): void {\n    if (!this._timeoutId) {\n      this._incrementScroll();\n    }\n  }\n\n  private _incrementScroll(): void {\n    if (this._scrollableParent) {\n      if (this._isVerticalScroll) {\n        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);\n      } else {\n        this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);\n      }\n    }\n\n    this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);\n  }\n\n  private _stopScroll(): void {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      delete this._timeoutId;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}